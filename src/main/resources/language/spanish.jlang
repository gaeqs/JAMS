Spanish

GENERAL_CONFIRM=Aceptar
GENERAL_OK=Ok
GENERAL_FINISH=Terminar
GENERAL_CANCEL=Cancelar
GENERAL_CREATE=Crear
GENERAL_CONFIRMATION=Confirmación
GENERAL_ADD=Añadir
GENERAL_REMOVE=Eliminar
GENERAL_COPY=Copiar
GENERAL_PASTE=Pegar
GENERAL_SORT=Ordenar

START_TITLE=JAMS {VERSION}
START_PROJECTS=Proyectos
START_NEW_PROJECT=Nuevo proyecto
START_ABOUT=Acerca de

BOTTOM_BAR_MEMORY={USED} de {TOTAL}MiB
BOTTOM_BAR_MEMORY_TOOLTIP=Pulsa para ejecutar el recolector de basura.

PROJECT_CREATOR_MIPS_ASSEMBLER=Ensamblador:
PROJECT_CREATOR_MIPS_INSTRUCTION_SET=Conjunto de instrucciones:
PROJECT_CREATOR_MIPS_DIRECTIVE_SET=Conjunto de directivas:
PROJECT_CREATOR_MIPS_REGISTERS=Registros:

PROJECT_CREATOR_MIPS_EMPTY=Proyecto MIPS vacío

MAIN_MENU_FILE=Archivo
MAIN_MENU_EDIT=Editar
MAIN_MENU_SIMULATION=Simulación
MAIN_MENU_TOOLS=Herramientas
MAIN_MENU_HELP=Ayuda

MAIN_MENU_FILE_EXIT=Salir
MAIN_MENU_FILE_SETTINGS=Configuración
MAIN_MENU_FILE_OPEN_PROJECT=Abrir proyecto
MAIN_MENU_FILE_CREATE_PROJECT=Crear proyecto
MAIN_MENU_FILE_CREATE_PROJECT_TITLE=Crear proyecto
MAIN_MENU_FILE_CREATE_PROJECT_NAME=Nombre:
MAIN_MENU_FILE_CREATE_PROJECT_PATH=Dirección:

MAIN_MENU_HELP_ABOUT=Acerca de

PROJECT_TAB_STRUCTURE=Estructura del protecto
PROJECT_TAB_SIMULATION=Simulación

BAR_VIEW_MODE_PANE=Mostrar en el panel
BAR_VIEW_MODE_WINDOW=Mostrar en una ventana
BAR_VIEW_MODE_PERSISTENT_WINDOW=Mostrar en una ventana persistente

BAR_EXPLORER_NAME=Explorador
BAR_FILES_TO_ASSEMBLE_NAME=Archivos a ensamblar
BAR_LOG_NAME=Log
BAR_SEARCH_RESULTS={RESULTS} resultados

EDITOR_INDEXING=Indexando...

SIMULATION_CONFIGURATION_CONFIGURATIONS=Configuraciones:
SIMULATION_CONFIGURATION_INFO=Ajustes de las configuraciones
SIMULATION_CONFIGURATION_GENERAL=General
SIMULATION_CONFIGURATION_GENERAL_REGION=Datos generales
SIMULATION_CONFIGURATION_NAME=Nombre:
SIMULATION_CONFIGURATION_ARCHITECTURE=Arquitectura:
SIMULATION_CONFIGURATION_ARCHITECTURE_TOOLTIP=La arquitectura que el simulador usará.\n\nAlgunas opciones solo están disponibles en arquitecturas específicas.
SIMULATION_CONFIGURATION_MEMORY=Memoria:
SIMULATION_CONFIGURATION_MEMORY_TOOLTIP=La memoria que el simulador usará.
SIMULATION_CONFIGURATION_CALL_EVENTS=Llamar a eventos de registros, memoria e instrucciones
SIMULATION_CONFIGURATION_CALL_EVENTS_TOOLTIP=Permite al simulador notificar cambios en la memoria, registros e instrucciones.\n\nSi esta opción está deshabilitada, el simulador funcionará más rápido, pero algunas opciones del depurador o de los plugins no funcionarán. Los eventos si funcionarán cuando el simulador esté parado.
SIMULATION_CONFIGURATION_ENABLE_UNDO=Permitir deshacer pasos
SIMULATION_CONFIGURATION_ENABLE_UNDO_TOOLTIP=Permite al usuario deshacer pasos del simulador.\n\nSi esta opción está desactivada, el simulador irá más rápido y consumira menos memoria, pero serás incapaz de deshacer pasos.\n\nEsta opción requiere que los eventos estén activados.
SIMULATION_CONFIGURATION_ENABLE_FORWARDING=Activar adelantamientos
SIMULATION_CONFIGURATION_ENABLE_FORWARDING_TOOLTIP=Permite a las instrucciones adelantar datos en una arquitectura segmentada.
SIMULATION_CONFIGURATION_SOLVE_BRANCH_ON_DECODE=Resolver saltos en la fase de decodificación
SIMULATION_CONFIGURATION_SOLVE_BRANCH_ON_DECODE_TOOLTIP=Permite resolver saltos en la fase de decodificación. Esta opción solo funciona en arquitecturas con varias etapas.
SIMULATION_CONFIGURATION_ENABLE_DELAY_SLOTS=Habilitar salto retardado.
SIMULATION_CONFIGURATION_ENABLE_DELAY_SLOTS_TOOLTIP=Habilita el relleno de ranura.\n\nSi esta opción está habilitada, toda instrucción situada después de una instruction de control no compacta será ejecutada.
SIMULATION_CONFIGURATION_SYSTEM_CALLS_TAB=Llamadas al sistema
SIMULATION_CONFIGURATION_SYSTEM_CALLS_TAB_LOAD_BUNDLE=Cargar conjunto
SIMULATION_CONFIGURATION_SYSTEM_CALLS_TAB_PROPERTIES=Propiedades de la llamada
SIMULATION_CONFIGURATION_CACHES_TAB=Cachés
SIMULATION_CONFIGURATION_CACHES_TAB_PROPERTIES=Propiedades de la caché
SIMULATION_CONFIGURATION_CACHES_TAB_INFO=Información de la caché
SIMULATION_CONFIGURATION_CACHES_TAB_SIZE=Tamaño de la caché:

MIPS_ELEMENT_COMMENT=Comentario
MIPS_ELEMENT_LABEL=Etiqueta
MIPS_ELEMENT_GLOBAL_LABEL=Etiqueta global
MIPS_ELEMENT_DIRECTIVE=Directiva
MIPS_ELEMENT_DIRECTIVE_PARAMETER=Parámetro de una directiva
MIPS_ELEMENT_INSTRUCTION=Instrucción
MIPS_ELEMENT_PSEUDOINSTRUCTION=Pseudoinstrucción
MIPS_ELEMENT_INSTRUCTION_PARAMETER_REGISTER=Registro
MIPS_ELEMENT_INSTRUCTION_PARAMETER_IMMEDIATE=Inmediato
MIPS_ELEMENT_INSTRUCTION_PARAMETER_STRING=String
MIPS_ELEMENT_INSTRUCTION_PARAMETER_LABEL=Referencia a una etiqueta
MIPS_ELEMENT_INSTRUCTION_PARAMETER_GLOBAL_LABEL=Referencia a una etiqueta global
MIPS_ELEMENT_MACRO_CALL=Llamada a macro
MIPS_ELEMENT_MACRO_CALL_PARAMETER=Parámetro de una llamada a macro
MIPS_ELEMENT_ERRORS=Errores:
MIPS_ELEMENT_WARNINGS=Advertencias:

SYSCALL_RUN_EXCEPTION_HANDLER=X Ejecutar el manejador de excepciones

SYSCALL_PRINT_INTEGER=SPIM 1 Imprimir entero
SYSCALL_PRINT_INTEGER_PROPERTY_PRINT_HEX=Imprimir hexadecimal
SYSCALL_PRINT_INTEGER_PROPERTY_LINE_JUMP=Añadir salto de línea
SYSCALL_PRINT_INTEGER_PROPERTY_REGISTER=Registro

SYSCALL_PRINT_FLOAT=SPIM 2 Imprimir float
SYSCALL_PRINT_FLOAT_PROPERTY_PRINT_HEX=Imprimir hexadecimal
SYSCALL_PRINT_FLOAT_PROPERTY_LINE_JUMP=Añadir salto de línea
SYSCALL_PRINT_FLOAT_PROPERTY_REGISTER=Registro

SYSCALL_PRINT_DOUBLE=SPIM 3 Imprimir double
SYSCALL_PRINT_DOUBLE_PROPERTY_PRINT_HEX=Imprimir hexadecimal
SYSCALL_PRINT_DOUBLE_PROPERTY_LINE_JUMP=Añadir salto de línea
SYSCALL_PRINT_DOUBLE_PROPERTY_REGISTER=Registro

SYSCALL_PRINT_STRING=SPIM 4 Imprimir string
SYSCALL_PRINT_STRING_PROPERTY_LINE_JUMP=Añadir salto de línea
SYSCALL_PRINT_STRING_PROPERTY_MAX_CHARACTERS=Caracteres máximos
SYSCALL_PRINT_STRING_PROPERTY_REGISTER=Registro

SYSCALL_READ_INTEGER=SPIM 5 Leer entero
SYSCALL_READ_INTEGER_PROPERTY_LINE_JUMP=Añadir salto de línea
SYSCALL_READ_INTEGER_PROPERTY_REGISTER=Registro

SYSCALL_READ_FLOAT=SPIM 6 Leer float
SYSCALL_READ_FLOAT_PROPERTY_LINE_JUMP=Añadir salto de línea
SYSCALL_READ_FLOAT_PROPERTY_REGISTER=Registro

SYSCALL_READ_DOUBLE=SPIM 7 Leer double
SYSCALL_READ_DOUBLE_PROPERTY_LINE_JUMP=Añadir salto de línea
SYSCALL_READ_DOUBLE_PROPERTY_REGISTER=Registro

SYSCALL_READ_STRING=SPIM 8 Leer string
SYSCALL_READ_STRING_PROPERTY_LINE_JUMP=Añadir salto de línea
SYSCALL_READ_STRING_PROPERTY_ADDRESS_REGISTER=Registro de dirección
SYSCALL_READ_STRING_PROPERTY_MAX_CHARS_REGISTER=Registro de chars máx.

SYSCALL_ALLOCATE_MEMORY=SPIM 9 Reservar memoria
SYSCALL_ALLOCATE_MEMORY_PROPERTY_AMOUNT_REGISTER=Registro de tamaño
SYSCALL_ALLOCATE_MEMORY_PROPERTY_ADDRESS_REGISTER=Registro de memoria

SYSCALL_EXIT=SPIM 10 Salir

SYSCALL_PRINT_CHARACTER=SPIM 11 Imprimir caracter
SYSCALL_PRINT_CHARACTER_PROPERTY_LINE_JUMP=Añadir salto de línea
SYSCALL_PRINT_CHARACTER_PROPERTY_REGISTER=Registro

SYSCALL_READ_CHARACTER=SPIM 12 Leer caracter
SYSCALL_READ_CHARACTER_PROPERTY_LINE_JUMP=Añadir salto de línea
SYSCALL_READ_CHARACTER_PROPERTY_REGISTER=Registro

SYSCALL_OPEN_FILE=SPIM 13 Abrir archivo
SYSCALL_OPEN_FILE_PROPERTY_NAME_REGISTER=Registro de nombre
SYSCALL_OPEN_FILE_PROPERTY_FLAG_REGISTER=Registro de flag
SYSCALL_OPEN_FILE_PROPERTY_MODE_REGISTER=Registro de modo
SYSCALL_OPEN_FILE_PROPERTY_RESULT_REGISTER=Registro de resultado

SYSCALL_READ_FILE=SPIM 14 Leer de archivo
SYSCALL_READ_FILE_PROPERTY_ID_REGISTER=Registro de id
SYSCALL_READ_FILE_PROPERTY_ADDRESS_REGISTER=Registro de dirección
SYSCALL_READ_FILE_PROPERTY_MAX_BYTES_REGISTER=Registro de bytes máx.
SYSCALL_READ_FILE_PROPERTY_RESULT_REGISTER=Registro de resultado

SYSCALL_WRITE_FILE=SPIM 15 Escribir en archivo
SYSCALL_WRITE_FILE_PROPERTY_ID_REGISTER=Registro de id
SYSCALL_WRITE_FILE_PROPERTY_ADDRESS_REGISTER=Registro de dirección
SYSCALL_WRITE_FILE_PROPERTY_AMOUNT_REGISTER=Registro de cantidad
SYSCALL_WRITE_FILE_PROPERTY_RESULT_REGISTER=Registro de resultado

SYSCALL_CLOSE_FILE=SPIM 16 Cerrar archivo
SYSCALL_CLOSE_FILE_PROPERTY_ID_REGISTER=Registro de id

SYSCALL_EXIT_WITH_VALUE=SPIM 17 Salir con valor
SYSCALL_EXIT_WITH_VALUE_PROPERTY_REGISTER=Registro

SYSCALL_SYSTEM_TIME=MARS 30 Hora del sistema
SYSCALL_SYSTEM_TIME_PROPERTY_LOW_REGISTER=Registro del valor bajo
SYSCALL_SYSTEM_TIME_PROPERTY_HIGH_REGISTER=Registro del valor alto

SYSCALL_SLEEP=MARS 32 Dormir
SYSCALL_SLEEP_PROPERTY_REGISTER=Registro

SYSCALL_PRINT_HEXADECIMAL_INTEGER=MARS 34 Imprimir número hexadecimal
SYSCALL_PRINT_HEXADECIMAL_INTEGER_PROPERTY_LINE_JUMP=Añadir salto de línea
SYSCALL_PRINT_HEXADECIMAL_INTEGER_PROPERTY_REGISTER=Registro

SYSCALL_PRINT_BINARY_INTEGER=MARS 35 Imprimir número binario
SYSCALL_PRINT_BINARY_INTEGER_PROPERTY_LINE_JUMP=Añadir salto de línea
SYSCALL_PRINT_BINARY_INTEGER_PROPERTY_REGISTER=Registro

SYSCALL_PRINT_UNSIGNED_INTEGER=MARS 36 Imprimir número sin signo
SYSCALL_PRINT_UNSIGNED_INTEGER_PROPERTY_LINE_JUMP=Añadir salto de línea
SYSCALL_PRINT_UNSIGNED_INTEGER_PROPERTY_REGISTER=Registro

SYSCALL_SET_SEED=MARS 40 Asignar semilla
SYSCALL_SET_SEED_PROPERTY_GENERATOR_REGISTER=Registro del generador
SYSCALL_SET_SEED_PROPERTY_SEED_REGISTER=Registro de la semilla

SYSCALL_RANDOM_INTEGER=MARS 41 Entero aleatorio
SYSCALL_RANDOM_INTEGER_PROPERTY_GENERATOR_REGISTER=Registro del generador
SYSCALL_RANDOM_INTEGER_PROPERTY_VALUE_REGISTER=Registro del valor

SYSCALL_RANDOM_RANGED_INTEGER=MARS 42 Entero aleatorio con rango
SYSCALL_RANDOM_RANGED_INTEGER_PROPERTY_GENERATOR_REGISTER=Registro del generador
SYSCALL_RANDOM_RANGED_INTEGER_PROPERTY_RANGE_REGISTER=Registro del rango
SYSCALL_RANDOM_RANGED_INTEGER_PROPERTY_VALUE_REGISTER=Registro del valor

SYSCALL_RANDOM_FLOAT=MARS 43 Float aleatorio
SYSCALL_RANDOM_FLOAT_PROPERTY_GENERATOR_REGISTER=Registro del generador
SYSCALL_RANDOM_FLOAT_PROPERTY_VALUE_REGISTER=Registro del valor

SYSCALL_RANDOM_DOUBLE=MARS 44 Double aleatorio
SYSCALL_RANDOM_DOUBLE_PROPERTY_GENERATOR_REGISTER=Registro del generador
SYSCALL_RANDOM_DOUBLE_PROPERTY_VALUE_REGISTER=Registro del valor

CACHE_DIRECT=Correspondencia directa
CACHE_DIRECT_PROPERTY_WRITE_BACK=Modo Write-back
CACHE_DIRECT_PROPERTY_BLOCK_SIZE=Tamaño del bloque (palabras)
CACHE_DIRECT_PROPERTY_BLOCKS_AMOUNT=Bloques

CACHE_ASSOCIATIVE=Asociativa
CACHE_ASSOCIATIVE_PROPERTY_WRITE_BACK=Modo Write-back
CACHE_ASSOCIATIVE_PROPERTY_BLOCK_SIZE=Tamaño del bloque (palabras)
CACHE_ASSOCIATIVE_PROPERTY_BLOCKS_AMOUNT=Bloques
CACHE_ASSOCIATIVE_PROPERTY_REPLACEMENT_POLICY=Política de reemplazamiento

CACHE_SET_ASSOCIATIVE=Asociativa por conjuntos
CACHE_SET_ASSOCIATIVE_PROPERTY_WRITE_BACK=Modo Write-back
CACHE_SET_ASSOCIATIVE_PROPERTY_BLOCK_SIZE=Tamaño del bloque (palabras)
CACHE_SET_ASSOCIATIVE_PROPERTY_BLOCKS_AMOUNT=Bloques
CACHE_SET_ASSOCIATIVE_PROPERTY_SET_SIZE=Tamaño del conjunto
CACHE_SET_ASSOCIATIVE_PROPERTY_REPLACEMENT_POLICY=Política de reemplazamiento

SIMULATION_BUTTON_TOOLTIP_EXECUTE_ALL=Ejecutar todas las instrucciones
SIMULATION_BUTTON_TOOLTIP_STOP=Parar
SIMULATION_BUTTON_TOOLTIP_EXECUTE_ONE=Ejecutar un paso
SIMULATION_BUTTON_TOOLTIP_UNDO=Deshacer un paso
SIMULATION_BUTTON_TOOLTIP_RESET=Reiniciar

SIMULATION_INSTRUCTION_VIEWER_DISASSEMBLED=Desensamblado
SIMULATION_INSTRUCTION_VIEWER_ORIGINAL=Original
SIMULATION_INSTRUCTION_VIEWER_HEXADECIMAL=Hexadecimal

BAR_REGISTERS_NAME=Registros
BAR_MEMORY_NAME=Memoria
BAR_FLOW_NAME=Flujo
BAR_CONSOLE_NAME=Consola
BAR_LABELS_NAME=Etiquetas
BAR_LAB_NAME=Lab
BAR_CACHES_NAME=Cachés

INSTRUCTIONS_USER=Texto
INSTRUCTIONS_KERNEL=Kernel

INSTRUCTIONS_BREAKPOINT=Brk.
INSTRUCTIONS_ADDRESS=Dirección
INSTRUCTIONS_CODE=Código
INSTRUCTIONS_INSTRUCTION=Instrucción
INSTRUCTIONS_ORIGINAL=Original

REGISTERS_GENERAL=General
REGISTERS_COP0=COP0
REGISTERS_COP1=COP1
REGISTERS_ID=Id
REGISTERS_SELECTION=Sel
REGISTERS_NAME=Nombre
REGISTERS_VALUE=Valor
REGISTERS_HEX=Hex

MEMORY_ADDRESS=Dirección
MEMORY_MEMORY=Memoria
MEMORY_CACHE_TAG=Etiqueta: {TAG}
MEMORY_CACHE_BLOCK=Bloque: {BLOCK}

LABELS_ADDRESS=Dirección: {ADDRESS}
LABELS_LINE=Línea: {LINE}
LABELS_REFERENCES=Referencias

LAB_SOFTWARE_INTERRUPTS=Interrupciones de software
LAB_HARDWARE_INTERRUPTS=Interrupciones de hardware
LAB_COUNTER=Contador
LAB_COUNTER_RESET=Reiniciar
LAB_INTERRUPT=Interrumpir

CACHE_HITS=Aciertos
CACHE_MISSES=Fallos
CACHE_STATS=Estadísticas
CACHE_STATS_OPERATIONS=Operaciones:
CACHE_STATS_HITS=Aciertos:
CACHE_STATS_MISSES=Fallos:
CACHE_RESET=Reiniciar cachés
CACHE_LOG=Registro
CACHE_LOG_HIT=Operación {OPERATION}. Acierto.
CACHE_LOG_MISS=Operación {OPERATION}. Fallo.
CACHE_LOG_INDEX=Índice {INDEX} ({TAG})
CACHE_LOG_CLEAR=Borrar registro
CACHE_LOG_CLEAR_ALL=Eliminar registros

FLOW_CYCLE=Ciclo: {CYCLE}

TASK_ASSEMBLING=Ensamblando...

CONFIG=Configuración

CONFIG_ACTION=Acciones
CONFIG_ACTION_SEARCH=Buscar...
CONFIG_ACTION_BIND_TITLE=Asignar una combinación a una acción
CONFIG_ACTION_BIND_ENTER=Presiona la combinación de teclas que quieres asignar
CONFIG_ACTION_BIND_CONFIRM=Las siguientes acciones serán desasignadas de la combinación:
CONFIG_ACTION_BIND_CONFIRM_2=¿Quieres continuar?
CONFIG_ACTION_UNBIND=¿Estás seguro de que quieres desasignar esta combinación?

CONFIG_PLUGIN=Plugins
CONFIG_PLUGIN_INSTALL=Instalar
CONFIG_PLUGIN_UNINSTALL=Desinstalar
CONFIG_PLUGIN_UNINSTALL_CONFIRM=¿Estás seguro de que quieres desinstalar el plugin {PLUGIN}?

CONFIG_APPEARANCE=Apariencia
CONFIG_APPEARANCE_REGION_THEME=Tema
CONFIG_APPEARANCE_REGION_TWEAKS=Ajustes
CONFIG_APPEARANCE_THEME=Tema:
CONFIG_APPEARANCE_THEME_TOOLTIP=Los temas cambian toda la apariencia de la aplicación.
CONFIG_APPEARANCE_GENERAL_FONT=Fuente general:
CONFIG_APPEARANCE_GENERAL_FONT_TOOLTIP=Esta fuente es usada por todo JAMS salvo en los editores de texto.
CONFIG_APPEARANCE_CODE_FONT=Fuente del editor:
CONFIG_APPEARANCE_CODE_FONT_TOOLTIP=Esta fuente es usada por los editores de texto.
CONFIG_APPEARANCE_HIDE_TOP_BAR=Esconder barra superior\t(Solo para Windows, necesita un reinicio)
CONFIG_APPEARANCE_HIDE_TOP_BAR_TOOLTIP=Esta opción permite integrar la barra superior de la ventana principal en la barra de tareas.
CONFIG_APPEARANCE_ANTIALIASING=Antialiasing\t(Necesita un reinicio)
CONFIG_APPEARANCE_ANTIALIASING_TOOLTIP=Activa el antialiasing en todas las escenas.

CONFIG_EDITOR=Editor
CONFIG_EDITOR_REGION_MOUSE_CONTROL=Controles del ratón
CONFIG_EDITOR_ZOOM_USING_MOUSE_WHEEL=Hacer zoom usando la rueda del ratón mientras está pulsado Shortcut
CONFIG_EDITOR_ZOOM_USING_MOUSE_WHEEL_TOOLTIP=Si esta opción está activada podrás hacer zoom usando la rueda del ratón mientras pulsas la tecla Shortcut.
CONFIG_EDITOR_RESET_ZOOM_USING_MIDDLE_BUTTON=Deshacer el zoom usando Shortcut+Botón central del ratón
CONFIG_EDITOR_RESET_ZOOM_USING_MIDDLE_BUTTON_TOOLTIP=Si esta opción está activada podrás deshacer el zoom usando el botón central del ratón mientras pulsas la tecla Shortcut.
CONFIG_EDITOR_RESET_ZOOM_SENSIBILITY=Sensibilidad del zoom:
CONFIG_EDITOR_RESET_ZOOM_SENSIBILITY_TOOLTIP=Esta opción permite configurar la ampliación del zoom en cada desplazamiento de la rueda.\n\nRecuerda que el valor por defecto del zoom es '2' y un zoom x2 tiene un valor de '2'.

CONFIG_EDITOR_MIPS=MIPS
CONFIG_EDITOR_MIPS_REGION_TABS=Tabuladores
CONFIG_EDITOR_MIPS_REGION_SPACES=Espacios
CONFIG_EDITOR_MIPS_REGION_BLANK_LINES=Líneas vacías
CONFIG_EDITOR_MIPS_USE_TABS=Usar el caracter tabulador
CONFIG_EDITOR_MIPS_USE_TABS_TOOLTIP=Si esta opción esta activada JAMS usará tabuladores en vez de espacios en el editor de código.
CONFIG_EDITOR_MIPS_PRESERVE_TABS=Preservar los tabuladores después de la etiqueta
CONFIG_EDITOR_MIPS_PRESERVE_TABS_TOOLTIP=Esta opción permite preservar los tabuladores extras añadidos por el usuario entre la etiqueta y la instrucción / directiva cuando se formatee el código.
CONFIG_EDITOR_MIPS_PRESERVE_TABS_BEFORE_LABELS=Preservar los tabuladores antes de la etiqueta
CONFIG_EDITOR_MIPS_PRESERVE_TABS_BEFORE_LABELS_TOOLTIP=Esta opción permite preservar los tabuladores extras añadidos por el usuario antes de la etiqueta cuando se formatee el código.
CONFIG_EDITOR_MIPS_SPACE_AFTER_INSTRUCTION=Después de una instrucción:
CONFIG_EDITOR_MIPS_SPACE_AFTER_INSTRUCTION_TOOLTIP=Esta opción le indica a JAMS qué añadir después de una instrucción.
CONFIG_EDITOR_MIPS_SPACE_AFTER_INSTRUCTION_PARAMETER=Después del parámetro de una instrucción:
CONFIG_EDITOR_MIPS_SPACE_AFTER_INSTRUCTION_PARAMETER_TOOLTIP=Esta opción le indica a JAMS qué añadir después de un parámetro de una instrucción.
CONFIG_EDITOR_MIPS_SPACE_AFTER_DIRECTIVE=Después de una directiva:
CONFIG_EDITOR_MIPS_SPACE_AFTER_DIRECTIVE_TOOLTIP=Esta opción le indica a JAMS qué añadir después de una directiva.
CONFIG_EDITOR_MIPS_SPACE_AFTER_DIRECTIVE_PARAMETER=Después del parámetro de una directiva:
CONFIG_EDITOR_MIPS_SPACE_AFTER_DIRECTIVE_PARAMETER_TOOLTIP=Esta opción le indica a JAMS qué añadir después de un parámetro de una directiva.
CONFIG_EDITOR_MIPS_MAXIMUM_BLANK_LINES=Líneas en blanco máximas:
CONFIG_EDITOR_MIPS_MAXIMUM_BLANK_LINES_TOOLTIP=La cantidad de líneas en blanco máximas que JAMS va a dejar al formatear.

CONFIG_EXPLORER=Explorador
CONFIG_EXPLORER_MIPS=MIPS
CONFIG_EXPLORER_REGION_SIZE=Tamaño
CONFIG_EXPLORER_SECTION_SEPARATOR_WIDTH=Ancho por nivel de herencia para secciones:
CONFIG_EXPLORER_SECTION_SEPARATOR_WIDTH_TOOLTIP=Esta opción permite editar el ancho que una sección se moverá por cada nivel de herencia.
CONFIG_EXPLORER_ELEMENT_SEPARATOR_WIDTH=Ancho por nivel de herencia para elementos:
CONFIG_EXPLORER_ELEMENT_SEPARATOR_WIDTH_TOOLTIP=Esta opción permite editar el ancho que un elemento se moverá por cada nivel de herencia.
CONFIG_EXPLORER_MIPS_REGION_CREATION=Creación
CONFIG_EXPLORER_MIPS_ADD_CREATED_ASM_FILES_TO_ASSEMBLE=Añadir archivos asm a ensamblar automaticamente cuando son creados
CONFIG_EXPLORER_MIPS_ADD_CREATED_ASM_FILES_TO_ASSEMBLE_TOOLTIP=Si esta opción está activada, los archivos ensamblador que se creen serán automáticamente añadidos a la lista de ensamblaje.\n\nEsta opción puede ser cambiada en el menú de creación del archivo.

CONFIG_LANGUAGE=Idioma
CONFIG_LANGUAGE_REGION_LANGUAGE=Idioma
CONFIG_LANGUAGE_DEFAULT=Idioma de respaldo:
CONFIG_LANGUAGE_DEFAULT_TOOLTIP=Este idioma se usará cuando el idioma usado no tenga el mensaje requerido.\n\nEste idioma es el inglés por defecto.
CONFIG_LANGUAGE_SELECTED=Idioma principal:
CONFIG_LANGUAGE_SELECTED_TOOLTIP=Este es el idioma que JAMS usará en la interfaz.

CONFIG_SIMULATION=Simulación
CONFIG_SIMULATION_MIPS=MIPS
CONFIG_SIMULATION_REGION_ASSEMBLY=Ensamblador
CONFIG_SIMULATION_OPEN_LOG_ON_ASSEMBLE=Abrir la ventana de log al ensamblar.
CONFIG_SIMULATION_REGION_MEMORY=Memoria
CONFIG_SIMULATION_MEMORY_ROWS=Filas:
CONFIG_SIMULATION_MEMORY_ROWS_TOOLTIP=El número de filas que la memoria puede mostrar al mismo tiempo.
CONFIG_SIMULATION_MIPS_REGION_FLOW=Flujo
CONFIG_SIMULATION_MIPS_FLOW_MAX_ITEMS=Entradas máximas:
CONFIG_SIMULATION_MIPS_FLOW_MAX_ITEMS_TOOLTIP=La cantidad de entradas que el panel de flujo puede representar al mismo tiempo.
CONFIG_SIMULATION_MIPS_REGION_INSTRUCTIONS=Visualizador de instrucciones
CONFIG_SIMULATION_MIPS_INSTRUCTIONS_VIEWER_ELEMENTS_ORDER=Orden de los elementos del visualizador:
CONFIG_SIMULATION_MIPS_INSTRUCTIONS_VIEWER_ELEMENTS_ORDER_TOOLTIP=En este panel puedes cambiar el orden de los elementos dentro del visualizador de instrucciones.
CONFIG_SIMULATION_MIPS_INSTRUCTIONS_VIEWER_ELEMENTS_ORDER_USING=Usando:
CONFIG_SIMULATION_MIPS_INSTRUCTIONS_VIEWER_ELEMENTS_ORDER_NOT_USING=Sin usar:
CONFIG_SIMULATION_MIPS_INSTRUCTIONS_SHOW_LABELS=Mostrar etiquetas.
CONFIG_SIMULATION_MIPS_INSTRUCTIONS_SHOW_LABELS_TOOLTIP=Esta opción le permite a las etiquetas aparecer en el visualizador de instrucciones.
CONFIG_SIMULATION_MIPS_REGION_LAB=Lab
CONFIG_SIMULATION_MIPS_LAB_FIRST_SEGMENT_ADDRESS=Dirección del primer visualizador:
CONFIG_SIMULATION_MIPS_LAB_FIRST_SEGMENT_ADDRESS_TOOLTIP=La dirección de memoria usado por el primer visualizador del lab.
CONFIG_SIMULATION_MIPS_LAB_SECOND_SEGMENT_ADDRESS=Dirección del segundo visualizador:
CONFIG_SIMULATION_MIPS_LAB_SECOND_SEGMENT_ADDRESS_TOOLTIP=La dirección de memoria usado por el segundo visualizador del lab.
CONFIG_SIMULATION_MIPS_LAB_FIRST_HEX_KERBOARD_ADDRESS=Primera dirección del teclado hexadeximal:
CONFIG_SIMULATION_MIPS_LAB_FIRST_HEX_KERBOARD_ADDRESS_TOOLTIP=La dirección de memoria usada por los 8 números menos significativos del teclado hexadeximal.
CONFIG_SIMULATION_MIPS_LAB_SECOND_HEX_KERBOARD_ADDRESS=Segunda dirección del teclado hexadeximal:
CONFIG_SIMULATION_MIPS_LAB_SECOND_HEX_KERBOARD_ADDRESS_TOOLTIP=La dirección de memoria usada por los 8 números más significativos del teclado hexadeximal.
CONFIG_SIMULATION_MIPS_LAB_COUNTER_ADDRESS=Dirección del contador:
CONFIG_SIMULATION_MIPS_LAB_COUNTER_ADDRESS_TOOLTIP=La dirección de memoria del contador. El valor en esta dirección representa el número de ciclos que el contador va a esperar antes de lanzar una interrupción.

EDITOR_ERROR_DUPLICATE_LABEL=La etiqueta '{LABEL}' está duplicada en la línea {LINE}.
EDITOR_ERROR_DUPLICATE_GLOBAL_LABEL=La etiqueta global '{LABEL}' está duplicada en la línea {LINE} del archivo '{FILE}'.
EDITOR_ERROR_DUPLICATE_MACRO=La macro '{MACRO}' está duplicada en la línea {LINE}.
EDITOR_ERROR_DUPLICATE_GLOBAL_MACRO=La macro global '{MACRO}' está duplicada en la línea {LINE} del archivo '{FILE}'.
EDITOR_ERROR_MACRO_NOT_FOUND=No se ha podido encontrar la macro '{MACRO}'.
EDITOR_ERROR_INVALID_MACRO_PARAMETERS_AMOUNT=Número de argumentos inválido para la macro '{MACRO}'. (Se esperaban: {EXPECTED}. Se han encontrado: {FOUND})
EDITOR_ERROR_ILLEGAL_MACRO_PARAMETER=Los parámetros de las macros deben empezar por '%'.
EDITOR_MIPS_ERROR_ILLEGAL_LABEL=La etiquieta '{LABEL}' tiene un nombre no válido.
EDITOR_MIPS_ERROR_INSTRUCTION_NOT_FOUND=No se ha podido encontrar la instrucción '{INSTRUCTION}' con los parámetros dados.
EDITOR_MIPS_ERROR_LABEL_NOT_FOUND=No se ha podido encontrar la etiqueta '{LABEL}'.

EDITOR_WARNING_SHADOWED_LABEL=La etiqueta '{LABEL}' en la línea {LINE} está siendo ocultada por esta declaración. No podrás acceder a la etiqueta externa dentro de esta macro.
EDITOR_WARNING_SHADOWED_GLOBAL_LABEL=La etiqueta global '{LABEL}' de la línea {LINE} en el archivo '{FILE}' está siendo ocultada por esta declaración. No podrás acceder a la etiqueta global externa dentro de esta macro.
EDITOR_MIPS_WARNING_EQV_USE=Evita usar la directiva '.eqv'. El editor no puede manejar el uso de equivalentes correctamente.
EDITOR_MIPS_WARNING_DIRECTIVE_NOT_FOUND=No se ha podido encontrar la directiva '{DIRECTIVE}'. Esta directia será ignorada.
EDITOR_MIPS_WARNING_REGISTER_AT_USE=Evita usar el registro '$at'. Su valor puede ser cambiado insesperadamente cuando una pseudoinstrucción es ejecutada.

ACTION_REGION_GENERAL=General
ACTION_GENERAL_CREATE_PROJECT=Crear proyecto
ACTION_GENERAL_OPEN_PROJECT=Abrir proyecto
ACTION_GENERAL_OPEN_RECENT=Abrir reciente
ACTION_GENERAL_SETTINGS=Configuración
ACTION_GENERAL_ASSEMBLE=Ensamblar código

ACTION_REGION_EDITOR=Editor
ACTION_EDITOR_SAVE=Guardar archivo

ACTION_REGION_TEXT_EDITOR=Editor de texto
ACTION_TEXT_EDITOR_REFORMAT=Reestructurar código
ACTION_TEXT_EDITOR_SHOW_AUTOCOMPLETION_POPUP=Mostrar autocompletador
ACTION_TEXT_EDITOR_SHOW_DOCUMENTATION_POPUP=Mostrar documentación
ACTION_TEXT_EDITOR_PREVIOUS_FILE=Ir al anterior archivo
ACTION_TEXT_EDITOR_NEXT_FILE=Ir al siguiente archivo
ACTION_TEXT_EDITOR_REFRESH_FROM_DISK=Recargar desde el disco
ACTION_TEXT_EDITOR_COPY=Copiar
ACTION_TEXT_EDITOR_PASTE=Pegar
ACTION_TEXT_EDITOR_CUT=Cortar
ACTION_TEXT_EDITOR_UNDO=Deshacer
ACTION_TEXT_EDITOR_REDO=Rehacer
ACTION_TEXT_EDITOR_SELECT_ALL=Seleccionar todo
ACTION_TEXT_EDITOR_DUPLICATE_LINE=Duplicar línea
ACTION_TEXT_EDITOR_FIND=Buscar
ACTION_TEXT_EDITOR_REPLACE=Reemplazar

ACTION_REGION_EXPLORER_ELEMENT=Elementos del explorador
ACTION_EXPLORER_ELEMENT_CONTRACT_OR_SELECT_PARENT=Contraer carpeta / seleccionar padre
ACTION_EXPLORER_ELEMENT_EXPAND_OR_NEXT=Expandir carpeta / seleccionar siguente elemento
ACTION_EXPLORER_ELEMENT_SELECT_NEXT=Seleccionar siguiente elemento
ACTION_EXPLORER_ELEMENT_SELECT_NEXT_MULTIPLE=Seleccionar siguiente elemento (selección múltiple)
ACTION_EXPLORER_ELEMENT_SELECT_PREVIOUS=Seleccionar elemento anterior
ACTION_EXPLORER_ELEMENT_SELECT_PREVIOUS_MULTIPLE=Seleccionar elemento anterior (selección múltiple)
ACTION_EXPLORER_ELEMENT_SELECT_ALL=Seleccionar todo

ACTION_REGION_FOLDER_EXPLORER_ELEMENT=Elementos del explorador de carpetas
ACTION_FOLDER_EXPLORER_ELEMENT_COPY=Copiar
ACTION_FOLDER_EXPLORER_ELEMENT_DELETE=Eliminar
ACTION_FOLDER_EXPLORER_ELEMENT_PASTE=Pegar
ACTION_FOLDER_EXPLORER_ELEMENT_PASTE_ALREADY_EXIST=Introduce un nuevo nombre.
ACTION_FOLDER_EXPLORER_ELEMENT_RENAME=Renombrar
ACTION_FOLDER_EXPLORER_ELEMENT_SHOW_IN_FILES=Mostrar en Archivos
ACTION_FOLDER_EXPLORER_ELEMENT_NEW=Nuevo
ACTION_FOLDER_EXPLORER_ELEMENT_NEW_FILE=Archivo
ACTION_FOLDER_EXPLORER_ELEMENT_NEW_ASSEMBLY_FILE=Archivo ensamblador
ACTION_FOLDER_EXPLORER_ELEMENT_NEW_FOLDER=Carpeta
ACTION_FOLDER_EXPLORER_ELEMENT_ADD_FILE_TO_ASSEMBLER=Añadir archivo al ensamblador
ACTION_FOLDER_EXPLORER_ELEMENT_ADD_ALL_FILES_TO_ASSEMBLER=Añadir archivos compatibles al ensamblador
ACTION_FOLDER_EXPLORER_ELEMENT_REMOVE_FILE_FROM_ASSEMBLER=Quitar archivo del ensamblador
ACTION_FOLDER_EXPLORER_ELEMENT_REMOVE_ALL_FILES_FROM_ASSEMBLER=Quitar archivos del ensablador

ACTION_REGION_EDITOR_TAB=Pestaña del editor
ACTION_EDITOR_TAB_SPLIT_HORIZONTALLY=Mover horizontalmente
ACTION_EDITOR_TAB_SPLIT_VERTICALLY=Mover verticalmente

ACTION_REGION_FILES_TO_ASSEMBLE=Archivos a ensamblar
ACTION_FILES_TO_ASSEMBLE_REMOVE=Eliminar del ensamblador

ACTION_REGION_MIPS_SIMULATION=Simulación MIPS
ACTION_MIPS_SIMULATION_EXECUTE_ALL_INSTRUCTIONS=Ejecutar todas las instrucciones
ACTION_MIPS_SIMULATION_EXECUTE_ONE_STEP=Ejecutar un paso
ACTION_MIPS_SIMULATION_RESET=Reiniciar
ACTION_MIPS_SIMULATION_STOP=Parar
ACTION_MIPS_SIMULATION_UNDO_ONE_STEP=Deshace un paso
ACTION_MIPS_SIMULATION_CYCLE_DELAY=Retardo por ciclo

ACTION_REGION_MIPS_SIMULATION_LABELS_LABEL=Tabla de etiquetas (Etiqueta)
ACTION_REGION_MIPS_SIMULATION_LABELS_REFERENCE=Tabla de etiquetas (Referencia)
ACTION_MIPS_SIMULATION_LABELS_LABEL_SHOW_IN_MEMORY=Mostrar en memoria
ACTION_MIPS_SIMULATION_LABELS_LABEL_SHOW_IN_INSTRUCTION_VIEWER=Mostrar en el visualizador de instrucciones
ACTION_MIPS_SIMULATION_LABELS_REFERENCE_SHOW_IN_MEMORY=Mostrar en memoria
ACTION_MIPS_SIMULATION_LABELS_REFERENCE_SHOW_IN_INSTRUCTION_VIEWER=Mostrar en el visualizador de instrucciones


NUMBER_FORMAT_HEXADECIMAL=Hexadecimal
NUMBER_FORMAT_DECIMAL=Decimal
NUMBER_FORMAT_OCTAL=Octal
NUMBER_FORMAT_BINARY=Binario
NUMBER_FORMAT_LONG=Long
NUMBER_FORMAT_FLOAT=Coma flotante
NUMBER_FORMAT_DOUBLE=Coma flotante (doble precisión)
NUMBER_FORMAT_CHAR=Characteres
NUMBER_FORMAT_RGB=RGB
NUMBER_FORMAT_RGBA=RGBA
NUMBER_FORMAT_ENGLISH=Texto inglés
NUMBER_FORMAT_ROMAN=Romano

//INSTRUCTIONS

INSTRUCTION_ABS_D=Suma (coma flotante doble)
INSTRUCTION_ABS_S=Valor absoluto (coma flotante)
INSTRUCTION_ADD=Suma
INSTRUCTION_ADD_D=Suma (coma flotante doble)
INSTRUCTION_ADDIU=Suma con inmediato sin desbordamiento
INSTRUCTION_ADDIUPC=Suma de inmediato y PC sin desbordamiento
INSTRUCTION_ADD_S=Suma (coma flotante)
INSTRUCTION_ADDU=Suma sin desbordamiento
INSTRUCTION_ALIGN=Concatenar dos registros generales, extrayendo un subconjunto contiguo a una posición de byte
INSTRUCTION_ALUIPC=Suma alineada del inmediato con los bits superiores del PC
INSTRUCTION_AND=And
INSTRUCTION_ANDI=And con inmediato
INSTRUCTION_AUI=Suma del inmediato con los bits superiores
INSTRUCTION_AUIPC=Suma del inmediato con los bits superiores del PC
INSTRUCTION_BAL=Ramificación y enlace
INSTRUCTION_BALC=Ramificación compacta y enlace
INSTRUCTION_BC=Ramificación compacta
INSTRUCTION_BC1EQZ=Ramificación si el bit 0 del registro COP1 es cero
INSTRUCTION_BC1NEZ=Ramificación si el bit 0 del registro COP1 no es cero
INSTRUCTION_BEQ=Ramificación si es igual
INSTRUCTION_BEQC=Ramificación compacta si es igual
INSTRUCTION_BEQZALC=Ramificación compacta y enlace si es igual que cero
INSTRUCTION_BEQZC=Ramificación compacta si es igual que cero
INSTRUCTION_BGEC=Ramificación compacta si es mayor o igual
INSTRUCTION_BGEUC=Ramificación compacta si es mayor o igual sin signo
INSTRUCTION_BGEZ=Ramificación si es mayor o igual que cero
INSTRUCTION_BGEZALC=Ramificación compacta y enlace si es mayor o igual que cero
INSTRUCTION_BGEZC=Ramificación compacta si es mayor o igual que cero
INSTRUCTION_BGTZ=Ramificación si es mayor que cero
INSTRUCTION_BGTZALC=Ramificación compacta y enlace si es mayor que cero
INSTRUCTION_BGTZC=Ramificación compacta si es mayor que cero
INSTRUCTION_BITSWAP=Intercambiar bits en cada byte
INSTRUCTION_BLEZ=Ramificación si es menor o igual que cero
INSTRUCTION_BLEZALC=Ramificación compacta y enlace si es menor o igual que cero
INSTRUCTION_BLEZC=Ramificación compacta si es menor o igual que cero
INSTRUCTION_BLTC=Ramificación compacta si es menor
INSTRUCTION_BLTUC=Ramificación compacta si es menor sin signo
INSTRUCTION_BLTZ=Ramificación si es menor que cero
INSTRUCTION_BLTZALC=Ramificación compacta y enlace si es menor que cero
INSTRUCTION_BLTZC=Ramificación compacta si es menor que cero
INSTRUCTION_BNE=Ramificación si no es igual
INSTRUCTION_BNEC=Ramificación compacta si no es igual
INSTRUCTION_BNEZALC=Ramificación compacta y enlace si no es igual que cero
INSTRUCTION_BNEZC=Ramificación compacta si no es igual que cero
INSTRUCTION_BNVC=Ramificación si la suma no desborda
INSTRUCTION_BOVC=Ramificación si la suma desborda
INSTRUCTION_BREAK=Punto de ruptura
INSTRUCTION_CEIL_L_D=Función techo de coma flotante doble a doble palabra
INSTRUCTION_CEIL_L_S=Función techo de coma flotante a doble palabra
INSTRUCTION_CEIL_W_D=Función techo de coma flotante doble a palabra
INSTRUCTION_CEIL_W_S=Función techo de coma flotante a palabra
INSTRUCTION_CLO=Conteo de los primeros unos en una palabra
INSTRUCTION_CLZ=Conteo de los primeros ceros en una palabra
INSTRUCTION_CMP_D=Comparación en coma flotante doble ({TYPE})
INSTRUCTION_CMP_S=Comparación en coma flotante ({TYPE})
INSTRUCTION_CVT=Convertir número de {FROM} a {TO}
INSTRUCTION_DIV=División
INSTRUCTION_DIV_D=División (coma flotante doble)
INSTRUCTION_DIV_S=División (coma flotante)
INSTRUCTION_DIVU=División sin signo
INSTRUCTION_ERET=Retorno de la excepción
INSTRUCTION_J=Salto
INSTRUCTION_JAL=Salto y enlace
INSTRUCTION_JALR=Salto y enlace a registro
INSTRUCTION_LB=Cargar byte
INSTRUCTION_LW=Cargar palabra
INSTRUCTION_MFC0=Mover desde el coprocesador 0
INSTRUCTION_MFC1=Mover desde el coprocesador 1
INSTRUCTION_MOD=Módulo
INSTRUCTION_MODU=Módulo sin signo
INSTRUCTION_MTC0=Mover al coprocesador 0
INSTRUCTION_MTC1=Mover al coprocesador 1
INSTRUCTION_MUH=Multiplicación devolviendo la parte más significante
INSTRUCTION_MUHU=Multiplicación sin signo devolviendo la parte más significante
INSTRUCTION_MUL=Multiplicación devolviendo la parte menos significante
INSTRUCTION_MUL_D=Multiplicación (coma flotante doble)
INSTRUCTION_MUL_S=Multiplicación (coma flotante)
INSTRUCTION_MULU=Multiplicación sin signo devolviendo la parte menos significante
INSTRUCTION_OR=Or
INSTRUCTION_ORI=Or con inmediato
INSTRUCTION_SB=Guardar byte
INSTRUCTION_SLL=Desplazar a la izquierda de manera lógica
INSTRUCTION_SLLV=Desplazar a la izquierda de manera lógica dependiendo de una variable
INSTRUCTION_SLT=Asignar si menor que valor
INSTRUCTION_SLTI=Asignar si menor que inmediato
INSTRUCTION_SLTIU=Asignar si menor que inmediato sin signo
INSTRUCTION_SLTU=Asignar si menor que sin signo
INSTRUCTION_SRL=Desplazar a la derecha de manera lógica
INSTRUCTION_SRLV=Desplazar a la derecha de manera lógica dependiendo de una variable
INSTRUCTION_SUB=Resta
INSTRUCTION_SUB_D=Resta (coma flotante doble)
INSTRUCTION_SUB_S=Resta (coma flotante)
INSTRUCTION_SUBU=Resta sin desbordamiento
INSTRUCTION_SW=Guardar palabra
INSTRUCTION_SYSCALL=Llamada al sistema
INSTRUCTION_TEQ=Interrupción si es igual
INSTRUCTION_TEQI=Interrupción si es igual que inmediato
INSTRUCTION_TGE=Interrupción si es mayor o igual
INSTRUCTION_TGEI=Interrupción si es mayor o igual que inmediato
INSTRUCTION_TGEIU=Interrupción si es mayor o igual que inmediato sin signo
INSTRUCTION_TGEU=Interrupción si es mayor o igual sin signo
INSTRUCTION_TLT=Interrupción si es menor
INSTRUCTION_TLTI=Interrupción si es menor que inmediato
INSTRUCTION_TLTIU=Interrupción si es menor que inmediato sin signo
INSTRUCTION_TLTU=Interrupción si es menor sin signo
INSTRUCTION_TNE=Interrupción si no es igual
INSTRUCTION_TNEI=Interrupción si no es igual que inmediato
INSTRUCTION_XOR=Xor
INSTRUCTION_XORI=Xor con inmediato

//PSEUDO INSTRUCTIONS

INSTRUCTION_ADDI=Suma con inmediato con desbordamiento
INSTRUCTION_B=Ramificación incondicional
INSTRUCTION_JR=Saltar al valor del registro
INSTRUCTION_LA=Cargar dirección
INSTRUCTION_LI=Cargar inmediato
INSTRUCTION_LUI=Cargar inmediato en los bits más significantes
INSTRUCTION_LIF=Cargar float inmediato
INSTRUCTION_MOVE=Mover valor
INSTRUCTION_NOP=Operación nula
INSTRUCTION_SGE=Asignar si menor o igual que valor
INSTRUCTION_SGEI=Asignar si mayor o igual que inmediato
INSTRUCTION_SGEIU=Asignar si mayor o igual que inmediato sin signo
INSTRUCTION_SGEU=Asignar si mayor o igual que sin signo
INSTRUCTION_SGT=Asignar si mayor que valor
INSTRUCTION_SGTI=Asignar si mayor que inmediato
INSTRUCTION_SGTIU=Asignar si mayor que inmediato sin signo
INSTRUCTION_SGTU=Asignar si mayor que sin signo
INSTRUCTION_SLE=Asignar si menor o igual que valor
INSTRUCTION_SLEI=Asignar si menor o igual que inmediato
INSTRUCTION_SLEIU=Asignar si menor o igual que inmediato sin signo
INSTRUCTION_SLEU=Asignar si menor o igual que sin signo

//INSTRUCTIONS DOCUMENTATION

INSTRUCTION_ABS_D_DOCUMENTATION.=<u>Valor absoluto en coma flotante de precisión doble</u>

<b>Formato:</b>
abs.d fd, fs

| COP1      fmt      0      fs      fd      ABS   |
|010001    10001   00000                   000101 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
FPR[fd] <- abs(FRP[fs])

Asigna el valor absoluto de <i>fs</i> a <i>fd</i>. Tanto el operando como el resultado son valores en coma flotante de precisión doble.

<b>Restricciones:</b>
Los registros <i>fs</i> y <i>fd</i> deben ser FPRs pares. Si los registros no son válidos, el resultado es <black>IMPREDECIBLE</black>.
El operando debe ser un valor en coma flotante de precisión doble. Si no lo es, el resultado es <black>IMPREDECIBLE</black>.

<b>Operación:</b>
fmt <- double
StoreFPR(fd, fmt, AbsoluteValue(ValueFPR(fs, fmt)))

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_ABS_S_DOCUMENTATION.=<u>Valor absoluto en coma flotante</u>

<b>Formato:</b>
abs.s fd, fs

| COP1      fmt      0      fs      fd      ABS   |
|010001    10000   00000                   000101 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
FPR[fd] <- abs(FRP[fs])

Asigna el valor absoluto de <i>fs</i> a <i>fd</i>. Tanto el operando como el resultado son valores en coma flotante.

<b>Restricciones:</b>
El operando debe ser un valor en coma flotante. Si no lo es, el resultado es <black>IMPREDECIBLE</black>.

<b>Operación:</b>
fmt <- float
StoreFPR(fd, fmt, AbsoluteValue(ValueFPR(fs, fmt)))

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_ADD_DOCUMENTATION.=<u>Suma</u>

<b>Formato:</b>
add rd, rs, rt

|SPECIAL     rs      rt     rd      0       ADD   |
|000000                                    100000 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
GPR[rd] <- GPR[rs] + GPR[rt]

La palabra de 32 bits del registro <i>rt</i> es sumada a la palabra de 32 bits del registro <i>rs</i> para producir un resultado de 32 bits.
 - Si la suma resulta en un desbordamiento aritmético en complemento a 2 de 32 bits, el registro destino no es modificado y la excepción <black>Integer Overflow</black> es lanzada.
 - Si la suma no produce un desbordamiento, el resultado es insertado en el registro <i>rd</i>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
temp <- (GPR[rs]<sub>31</sub> || GPR[rs]<sub>31..0</sub>) + (GPR[rt]<sub>31</sub> || GPR[rt]<sub>31..0</sub>)
if temp<sub>32</sub> != temp<sub>31</sub> then
    SignalException(IntegerOverflow)
else
    GPR[rd] <- temp<sub>31..0</sub>
endif

<b>Excepciones:</b>
Integer Overflow

<b>Notas del programador:</b>
<black>addu</black> ejecuta la misma operación aritmética pero no lanza una excepción al desbordar.
\END

INSTRUCTION_ADD_D_DOCUMENTATION.=<u>Suma en coma flotante de precisión doble</u>

<b>Formato:</b>
add.d fd, fs, ft

| COP1      fmt      0      fs      fd      ADD   |
|010001    10001   00000                   000000 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
FPR[fd] <- FRP[fs] + FPR[ft]

El valor en el registro <i>ft</i> es añadido al valor en el registro <i>fs</i>. El resultado es calculado en precisión infinita, usando el redondeo proporcionado por <i>Java</i>, y asignado al registro <i>fd</i>.
Los operando y el resultado son valores en coma flotante de precisión doble.

<b>Restricciones:</b>
Los registros <i>fs</i>, <i>ft</i> y <i>fd</i> deben ser FPRs pares. Si los registros no son válidos, el resultado es <black>IMPREDECIBLE</black>.
El operando debe ser un valor en coma flotante de precisión doble. Si no lo es, el resultado es <black>IMPREDECIBLE</black>.

<b>Operación:</b>
fmt <- double
StoreFPR(fd, fmt, ValueFPR(fs, fmt) +<sub>fmt</sub> ValueFPR(ft, fmt))

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_ADD_S_DOCUMENTATION.=<u>Suma en coma flotante</u>

<b>Formato:</b>
add.s fd, fs, ft

| COP1      fmt      0      fs      fd      ADD   |
|010001    10000   00000                   000000 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
FPR[fd] <- FRP[fs] + FPR[ft]

El valor en el registro <i>ft</i> es añadido al valor en el registro <i>fs</i>. El resultado es calculado en precisión infinita, usando el redondeo proporcionado por <i>Java</i>, y asignado al registro <i>fd</i>.
Los operando y el resultado son valores en coma flotante.

<b>Restricciones:</b>
El operando debe ser un valor en coma flotante. Si no lo es, el resultado es <black>IMPREDECIBLE</black>.

<b>Operación:</b>
fmt <- float
StoreFPR(fd, fmt, ValueFPR(fs, fmt) +<sub>fmt</sub> ValueFPR(ft, fmt))

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_ADDIU_DOCUMENTATION.=<u>Suma con inmediato sin signo</u>

<b>Formato:</b>
addiu rt, rs, inmediato

| ADDIU      rs     rt     inmediato |
|001001                              |
|  6         5      5         16     |


<b>Descripción:</b>
GPR[rt] <- GPR[rs] + inmediato

El valor con signo de 16 bits <i>inmediato</i> es sumado al valor de 32 bits del registro <i>rs</i> y el resultado de 32 bits es asignado al registro <i>rt</i>.
Ninguna excepción de desbordamiento ocurre en ninguna de las circunstancias.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
temp <- GPR[rs] + sign_extend(inmediato)
GPR[rt] <- temp

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>
El término <i>sin signo</i> en esta instrucción es parcialmente incorrecto; esta instrucción ejecuta una operación aritmética de 32 bits que no lanza una excepción al desbordar. Esta instrucción es apropiada para aritmética sin signo, o entornos aritméticos que ignoran el desbordamiento, como puede ser la aritmética del lenguaje C.
\END

INSTRUCTION_ADDIUPC_DOCUMENTATION.=<u>Suma de inmediato y PC sin singo</u>

<b>Formato:</b>
addiupc rs, inmediato

| PCREL      rs   ADDIUPC   inmediato |
|111011              00               |
|  6         5       2         19     |


<b>Descripción:</b>
GPR[rs] <- PC + sign_extend(inmediato << 2)

Esta instrucción ejecuta el cálculo de una dirección relativa al PC. El <i>inmediato</i> de 19 bits es desplazado a la izquierda 2 bits, extendido con signo y sumado con la dirección de la instrucción.
El resultado es asignado al registro <i>rs</i>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
GPR[rs] <- PC + sign_extend(inmediato << 2)

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>
El término <i>sin signo</i> es parcialmente incorrecto. <i>Sin signo</i> aquí significa <i>ignorando desbordamientos</i>. Esta instrucción no lanza una excepción cuando la suma produce un desbordamiento. <black>addiupc</black> corresponde a la instrucción <black>addiu</black>, la cual no lanza excepciones al desbordar.
\END

INSTRUCTION_ADDU_DOCUMENTATION.=<u>Suma sin signo</u>

<b>Formato:</b>
addu rd, rs, rt

|SPECIAL     rs      rt     rd      0       ADDU  |
|000000                                    100001 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
GPR[rd] <- GPR[rs] + GPR[rt]

La palabra de 32 bits del registro <i>rt</i> es sumada a la palabra de 32 bits del registro <i>rs</i> para producir un resultado de 32 bits.
El resultado es asignado al registro <i>rd</i>.
Ninguna excepción de desbordamiento ocurre en ninguna de las circunstancias.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
temp <- GPR[rs] + GPR[rt]
GPR[rd] <- temp

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>
El término <i>sin signo</i> en esta instrucción es parcialmente incorrecto; esta instrucción ejecuta una operación aritmética de 32 bits que no lanza una excepción al desbordar. Esta instrucción es apropiada para aritmética sin signo, o entornos aritméticos que ignoran el desbordamiento, como puede ser la aritmética del lenguaje C.
\END

INSTRUCTION_ALIGN_DOCUMENTATION.=<u>Concatenar dos registros generales, extrayendo un subconjunto contiguo a una posición de byte</u>

<b>Formato:</b>
align rd, rs, rt, bp

|SPECIAL3    rs    rt    rd    ALIGN   bp   BSGFL  |
| 011111                        010         100000 |
|   6        5     5     5       3     2      6    |


<b>Descripción:</b>
GPR[rd] <- (GPR[rt] << 8 * bp) or (GPR[rs] >> 8 * (4 - bp))

El registro <i>rt</i> y el registro <i>rs</i> son concatenados, y un subconjunto del tamaño de un registro es extraido, el cual está especificado por el puntero a byte <i>bp</i>.
La instrucción <black>align</black> opera con palabras de 32 bits, y tiene una celda de 2 bits <i>bp</i> representando el puntero a byte.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
tmp_rt_hi <- unsigned_word(GPR[rt]) << 8 * bp
tmp_rs_lo <- unsigned_word(GPR[rs]) >> 8 * (4 - bp)
GPR[rd] <- tmp_rt_hi or tmp_rs_lo

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_ALUIPC_DOCUMENTATION.=<u>Suma alineada del inmediato con los bits superiores del PC</u>

<b>Formato:</b>
aluipc rs, inmediato

| PCREL     rs     ALUIPC   inmediato |
|111011            11111              |
|  6        5        5         16     |


<b>Descrpción:</b>
GPR[rs] <- not 0x0FFFF and PC + sign_extend(inmediato << 16)

Esta instrucción ejecuta el cálculo de una dirección relativa al PC. El <i>inmediato</i> de 16 bits es desplazado a la izquierda 16 bits, extendido con signo y sumado con la dirección de la instrucción.
Los 16 bits menos significantes son pustos a 0. El resultado es asignado al registro <i>rs</i>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
GPR[rs] <- not 0x0FFFF and PC + sign_extend(inmediato << 16)

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_AND_DOCUMENTATION.=<u>And</u>

<b>Formato:</b>
and rd, rs, rt

|SPECIAL     rs      rt     rd      0       AND   |
|000000                                    100100 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
GPR[rd] <- GPR[rs] and GPR[rt]

Realiza la operación lógica AND usando los valores dentro de los registros <i>rs</i> y <i>rt</i>.
El resultado es asignado al registro <i>rd</i>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
GPR[rd] <- GPR[rs] and GPR[rt]

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_ANDI_DOCUMENTATION.=<u>And con inmediato</u>

<b>Formato:</b>
andi rt, rs, inmediato

| ANDI      rs     rt     inmediato |
|001100                             |
|  6        5      5         16     |


<b>Descripción:</b>
GPR[rt] <- GPR[rs] and zero_extend(inmediato)

El <i>inmediato</i> de 16 bits es extendido a la izquierda con ceros y combinado con el valor del registro <i>rs</i> usando la operación lógica AND.
El resultado es asignado al registro <i>rt</i>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
GPR[rt] <- GPR[rs] and zero_extend(immediate)

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_AUI_DOCUMENTATION.=<u>Suma del inmediato con los bits superiores</u>

<b>Formato:</b>
aui rt, rs, inmediato

| AUI       rs     rt     inmediato |
|001111                             |
|  6        5      5         16     |


<b>Descripción:</b>
GPR[rt] <- GPR[rs] + sign_extend(inmediato << 16)


El <i>inmediato</i> de 16 bits es desplazado a la izquierda unos 16 bits, extendido con signo y sumado al registro <i>rs</i>
El resultado es insertado en el registro <i>rt</i>
En MIPS32r6, <black>lui</black> es un alias de <black>aui</black> con <i>rs</i> = 0.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
GPR[rt] <- GPR[rs] + sign_extend(inmediato << 16)

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>
<black>aui</black> puede ser usado para sintetizar grandes constantes en situaciones donde no es conveniente cargar una constante de memoria.
\END

INSTRUCTION_AUIPC_DOCUMENTATION.=<u>Suma del inmediato con los bits superiores del PC</u>

<b>Formato:</b>
auipc rs, inmediato

| PCREL    rs    AUIPC    inmediato |
|111011          11110              |
|  6       5       5         16     |


<b>Descripción:</b>
GPR[rs] <- PC + (inmediato << 16)


Esta instrucción ejecuta el cálculo de una dirección relativa al PC. El <i>inmediato</i> de 16 bits es desplazado a la izquierda 16 bits y sumado con la dirección de la instrucción.
El resultado es asignado al registro <i>rs</i>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
GPR[rs] <- PC + (inmediato << 16)

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_BAL_DOCUMENTATION.=<u>Ramificación y enlace</u>

<b>Formato:</b>
b desplazamiento

|REGIMM      0      BAL    desplazamiento  |
|000001    00000   10001                   |
|  6         5       5           16        |


<b>Descripción:</b>
Inserta la dirección de retorno en el registro <i>31</i>. Ésta es la dirección de la instrucción donde la ejecución debe continuar después de una llamada a un procedimiento.
Un desplazamiento de 18 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción para formar una dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

<b>Operación:</b>
<black>I:</black>
desp <- sign_extend(desplazamiento || 00)
GPR[31] <- PC + 4

<black>I+1:</black>
PC <- PC + desp

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>
<black>bal</black> sin un retorno correspondiente no debe ser usado para leer el PC. Hacerlo puede causar una pérdida de rendimiento en procesadores con un predictor de dirección de retorno.
\END

INSTRUCTION_BALC_DOCUMENTATION.=<u>Ramificación compacta y enlace</u>

<b>Formato:</b>
balc desplazamiento

| BALC     desplazamiento  |
|111010                    |
|  6             26        |


<b>Descripción:</b>
Inserta la dirección de retorno en el registro <i>31</i>. Ésta es la dirección de la instrucción donde la ejecución debe continuar después de una llamada a un procedimiento.
Un desplazamiento de 28 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción para formar una dirección efectiva.
Esta instrución ejecuta una ramificación compacta. Las ramificaciones compactas no tienen huecos de retardo.

<b>Restricciones:</b>
Esta instrucción es una ramificación incondicional que siempre es tomada. No tiene ni huecos prohibidos ni huecos de retardo.

<b>Operación:</b>
target_offset <- sign_extend(desplazamiento || 00)
GPR[31] <- PC + 4
PC <- PC + 4 + target_offset

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_BC_DOCUMENTATION.=<u>Ramificación compacta</u>

<b>Formato:</b>
balc desplazamiento

|  BC      desplazamiento  |
|110010                    |
|  6             26        |


<b>Descripción:</b>
Un desplazamiento de 28 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción para formar una dirección efectiva.
Esta instrución ejecuta una ramificación compacta. Las ramificaciones compactas no tienen huecos de retardo.

<b>Restricciones:</b>
Esta instrucción es una ramificación incondicional que siempre es tomada. No tiene ni huecos prohibidos ni huecos de retardo.

<b>Operación:</b>
target_offset <- sign_extend(desplazamiento || 00)
PC <- PC + 4 + target_offset

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_BC1EQZ_DOCUMENTATION.=<u>Ramificación si el bit 0 del registro COP1 es cero</u>

<b>Formato:</b>
bc1eqz ft, desplazamiento

| COP1      BC1EQZ     ft   desplazamiento  |
|010001     01001                           |
|  6          5        5          16        |


<b>Descripción:</b>
Ramificación si FPR[ft] & 1 = 0

La condición es verdadera si y solo si el bit 0 del registro <i>ft</i> es cero.
Si la condición es falsa, la ramificación no es tomada y la ejecución continua con la siguiente instrucción.

If the condition is false, the branch is not taken and execution continues with the next instruction.
Un desplazamiento de 18 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción para formar una dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

<b>Operación:</b>
temp = ValueFPR(ft, UNINTERPRETED_WORD)
cond = temp & 1 = 0
if cond then
    <black>I:</black>
    target_PC <- PC + 4 + sign_extend(desplazamiento << 2)
    <black>I+1:</black>
    PC <- target_PC
endif

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_BC1NEZ_DOCUMENTATION.=<u>Ramificación si el bit 0 del registro COP1 no es cero</u>

<b>Formato:</b>
bc1nez ft, desplazamiento

| COP1      BC1NEZ     ft   desplazamiento  |
|010001     01101                           |
|  6          5        5          16        |


<b>Descripción:</b>
Ramificación si FPR[ft] & 1 != 0

La condición es verdadera si y solo si el bit 0 del registro <i>ft</i> no es cero.
Si la condición es falsa, la ramificación no es tomada y la ejecución continua con la siguiente instrucción.

If the condition is false, the branch is not taken and execution continues with the next instruction.
Un desplazamiento de 18 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción para formar una dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

<b>Operación:</b>
temp = ValueFPR(ft, UNINTERPRETED_WORD)
cond = temp & 1 != 0
if cond then
    <black>I:</black>
    target_PC <- PC + 4 + sign_extend(desplazamiento << 2)
    <black>I+1:</black>
    PC <- target_PC
endif

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_BEQ_DOCUMENTATION.=<u>Ramificación si es igual</u>

<b>Formato:</b>
beq rs, rt, desplazamiento

| BEQ       rs     rt     desplazamiento  |
|000100                                   |
|  6        5      5            16        |


<b>Descripción:</b>
Ramificación si GPR[rs] = GPR[rt]

Un desplazamiento de 18 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción para formar una dirección efectiva.
Si el contenido de los registros <i>rt</i> y <i>rs</i> son iguales, la instrucción ejecuta la ramificación a la dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

<b>Operación:</b>
<black>I:</black>
target_offset <- sign_extend(desplazamiento || 00)
condition <- GPR[rs] = GPR[rt]
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>
Con el desplazamiento de 18 bits, el rango de la ramificación es de  ±128KBytes. Usa el salto (<black>j</black>) o el salto a registro (<black>jr</black>) para ramificar a direcciones fuera de este rango.
<black>beq $zero, $zero, desplazamiento</black>, expresado como <black>b desplazamiento</black>, es el equivalente en ensablador para denotar un salto incondicional.
\END

INSTRUCTION_BGEZ_DOCUMENTATION.=<u>Ramificación si es mayor o igual que cero</u>

<b>Formato:</b>
bgez rs, offset

|REGIMM     rs    BGEZ    desplazamiento  |
|000001          00001                    |
|  6        5      5            16        |


<b>Descripción:</b>
Ramificación compacta si GPR[rs] >= 0.

Un desplazamiento de 18 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción para formar una dirección efectiva.
Si el contenido del registro <i>rs</i> es mayor o igual que cero, la instrucción ejecuta la ramificación a la dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

<b>Operación:</b>
<black>I:</black>
target_offset <- sign_extend(desplazamiento || 00)
condition <- GPR[rs] >= 0
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>
Con el desplazamiento de 18 bits, el rango de la ramificación es de  ±128KBytes. Usa el salto (<black>j</black>) o el salto a registro (<black>jr</black>) para ramificar a direcciones fuera de este rango.
\END


INSTRUCTION_BLEZALC_DOCUMENTATION.=<u>Ramificación compacta y enlace si es menor o igual que cero</u>

<b>Formato:</b>
blezalc rt, desplazamiento

| POP06     0    rt != 0   desplazamiento  |
|000110   00000                            |
|  6        5       5            16        |


<b>Descripción:</b>
Enlace y ramificación compacta si GPR[rt] <= 0.
Inserta la dirección de retorno en el registro <i>31</i>. Ésta es la dirección de la instrucción donde la ejecución debe continuar después de una llamada a un procedimiento.
Un desplazamiento de 18 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción para formar una dirección efectiva.
Si el contenido del registro <i>rt</i> es menor o igual que cero, la instrucción ejecuta la ramificación a la dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>
El registro <i>31</i> no debe ser usado por el registro <i>rs</i>, ya que las instrucciones no tendrán el mismo efecto al volver a ser ejecutatas. El resultado de ejecutar dicha instrucción es <black>IMPREDECIBLE</black>. Esta restricción permite al gestor de excepciones returnar la ejecución volviendo a ejecutar la ramificación cuando una excepción es lanzada en el hueco de retardo.

<b>Operación:</b>
<black>I:</black>
GPR[31] <- PC + 4
target_offset <- sign_extend(desplazamiento || 00)
condition <- GPR[rt] <= 0
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>
Con el desplazamiento de 18 bits, el rango de la ramificación es de  ±128KBytes. Usa el salto (<black>j</black>) o el salto a registro (<black>jr</black>) para ramificar a direcciones fuera de este rango.
\END

INSTRUCTION_BGEZALC_DOCUMENTATION.=<u>Ramificación compacta y enlace si es mayor o igual que cero</u>

<b>Formato:</b>
bgezalc rt, desplazamiento

| POP06     rs      rt     desplazamiento  |
|000110    rs = rt != 0                    |
|  6        5       5            16        |


<b>Descripción:</b>
Enlace y ramificación compacta si GPR[rt] >= 0.
Inserta la dirección de retorno en el registro <i>31</i>. Ésta es la dirección de la instrucción donde la ejecución debe continuar después de una llamada a un procedimiento.
Un desplazamiento de 18 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción para formar una dirección efectiva.
Si el contenido del registro <i>rt</i> es mayor o igual que cero, la instrucción ejecuta la ramificación a la dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>
El registro <i>31</i> no debe ser usado por el registro <i>rs</i>, ya que las instrucciones no tendrán el mismo efecto al volver a ser ejecutatas. El resultado de ejecutar dicha instrucción es <black>IMPREDECIBLE</black>. Esta restricción permite al gestor de excepciones returnar la ejecución volviendo a ejecutar la ramificación cuando una excepción es lanzada en el hueco de retardo.

<b>Operación:</b>
<black>I:</black>
GPR[31] <- PC + 4
target_offset <- sign_extend(desplazamiento || 00)
condition <- GPR[rt] >= 0
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>
Con el desplazamiento de 18 bits, el rango de la ramificación es de  ±128KBytes. Usa el salto (<black>j</black>) o el salto a registro (<black>jr</black>) para ramificar a direcciones fuera de este rango.
\END

INSTRUCTION_BGTZALC_DOCUMENTATION.=<u>Ramificación compacta y enlace si es mayor que cero</u>

<b>Formato:</b>
bgtzalc rt, desplazamiento

| POP07     0    rt != 0   desplazamiento  |
|000111   00000                            |
|  6        5       5            16        |


<b>Descripción:</b>
Enlace y ramificación compacta si GPR[rt] > 0.
Inserta la dirección de retorno en el registro <i>31</i>. Ésta es la dirección de la instrucción donde la ejecución debe continuar después de una llamada a un procedimiento.
Un desplazamiento de 18 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción para formar una dirección efectiva.
Si el contenido del registro <i>rt</i> es mayor que cero, la instrucción ejecuta la ramificación a la dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>
El registro <i>31</i> no debe ser usado por el registro <i>rs</i>, ya que las instrucciones no tendrán el mismo efecto al volver a ser ejecutatas. El resultado de ejecutar dicha instrucción es <black>IMPREDECIBLE</black>. Esta restricción permite al gestor de excepciones returnar la ejecución volviendo a ejecutar la ramificación cuando una excepción es lanzada en el hueco de retardo.

<b>Operación:</b>
<black>I:</black>
GPR[31] <- PC + 4
target_offset <- sign_extend(desplazamiento || 00)
condition <- GPR[rt] > 0
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>
Con el desplazamiento de 18 bits, el rango de la ramificación es de  ±128KBytes. Usa el salto (<black>j</black>) o el salto a registro (<black>jr</black>) para ramificar a direcciones fuera de este rango.
\END

INSTRUCTION_BLTZALC_DOCUMENTATION.=<u>Ramificación compacta y enlace si es menor que cero</u>

<b>Formato:</b>
bltzalc rt, desplazamiento

| POP07     rs      rt     desplazamiento  |
|000111    rs = rt != 0                    |
|  6        5       5            16        |


<b>Descripción:</b>
Enlace y ramificación compacta si GPR[rt] < 0.
Inserta la dirección de retorno en el registro <i>31</i>. Ésta es la dirección de la instrucción donde la ejecución debe continuar después de una llamada a un procedimiento.
Un desplazamiento de 18 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción para formar una dirección efectiva.
Si el contenido del registro <i>rt</i> es menor que cero, la instrucción ejecuta la ramificación a la dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>
El registro <i>31</i> no debe ser usado por el registro <i>rs</i>, ya que las instrucciones no tendrán el mismo efecto al volver a ser ejecutatas. El resultado de ejecutar dicha instrucción es <black>IMPREDECIBLE</black>. Esta restricción permite al gestor de excepciones returnar la ejecución volviendo a ejecutar la ramificación cuando una excepción es lanzada en el hueco de retardo.

<b>Operación:</b>
<black>I:</black>
GPR[31] <- PC + 4
target_offset <- sign_extend(desplazamiento || 00)
condition <- GPR[rt] < 0
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>
Con el desplazamiento de 18 bits, el rango de la ramificación es de  ±128KBytes. Usa el salto (<black>j</black>) o el salto a registro (<black>jr</black>) para ramificar a direcciones fuera de este rango.
\END

INSTRUCTION_BEQZALC_DOCUMENTATION.=<u>Ramificación compacta y enlace si es igual que cero</u>

<b>Formato:</b>
beqzalc rt, desplazamiento

| POP10     rs     rt != 0   desplazamiento  |
|001000       rs < rt                        |
|  6        5         5            16        |


<b>Descripción:</b>
Enlace y ramificación compacta si GPR[rt] = 0.
Inserta la dirección de retorno en el registro <i>31</i>. Ésta es la dirección de la instrucción donde la ejecución debe continuar después de una llamada a un procedimiento.
Un desplazamiento de 18 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción para formar una dirección efectiva.
Si el contenido del registro <i>rt</i> es igual que cero, la instrucción ejecuta la ramificación a la dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>
El registro <i>31</i> no debe ser usado por el registro <i>rs</i>, ya que las instrucciones no tendrán el mismo efecto al volver a ser ejecutatas. El resultado de ejecutar dicha instrucción es <black>IMPREDECIBLE</black>. Esta restricción permite al gestor de excepciones returnar la ejecución volviendo a ejecutar la ramificación cuando una excepción es lanzada en el hueco de retardo.

<b>Operación:</b>
<black>I:</black>
GPR[31] <- PC + 4
target_offset <- sign_extend(desplazamiento || 00)
condition <- GPR[rt] = 0
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>
Con el desplazamiento de 18 bits, el rango de la ramificación es de  ±128KBytes. Usa el salto (<black>j</black>) o el salto a registro (<black>jr</black>) para ramificar a direcciones fuera de este rango.
\END

INSTRUCTION_BNEZALC_DOCUMENTATION.=<u>Ramificación compacta y enlace si no es igual que cero</u>


<b>Formato:</b>
bnezalc rt, desplazamiento

| POP30     rs     rt != 0   desplazamiento  |
|011000       rs < rt                        |
|  6        5         5            16        |


<b>Descripción:</b>
Enlace y ramificación compacta si GPR[rt] != 0.
Inserta la dirección de retorno en el registro <i>31</i>. Ésta es la dirección de la instrucción donde la ejecución debe continuar después de una llamada a un procedimiento.
Un desplazamiento de 18 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción para formar una dirección efectiva.
Si el contenido del registro <i>rt</i> no es igual que cero, la instrucción ejecuta la ramificación a la dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>
El registro <i>31</i> no debe ser usado por el registro <i>rs</i>, ya que las instrucciones no tendrán el mismo efecto al volver a ser ejecutatas. El resultado de ejecutar dicha instrucción es <black>IMPREDECIBLE</black>. Esta restricción permite al gestor de excepciones returnar la ejecución volviendo a ejecutar la ramificación cuando una excepción es lanzada en el hueco de retardo.

<b>Operación:</b>
<black>I:</black>
GPR[31] <- PC + 4
target_offset <- sign_extend(desplazamiento || 00)
condition <- GPR[rt] != 0
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>
Con el desplazamiento de 18 bits, el rango de la ramificación es de  ±128KBytes. Usa el salto (<black>j</black>) o el salto a registro (<black>jr</black>) para ramificar a direcciones fuera de este rango.
\END

INSTRUCTION_BLEZC_DOCUMENTATION.=<u>Ramificación compacta si es menor o igual que cero</u>

<b>Formato:</b>
blezc rt, offset

| POP26     0      rt != 0    desplazamiento  |
|010110   00000                               |
|  6        5         5             16        |


<b>Descripción:</b>
Enlace compacto si GPR[rt] <= 0.

Un desplazamiento de 18 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción para formar una dirección efectiva.
Si el contenido del registro <i>rt</i> es menor o igual que cero, la instrucción ejecuta la ramificación a la dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

<b>Operación:</b>
target_offset <- sign_extend(desplazamiento || 00)
condition <- GPR[rt] <= 0
if condition then
    PC <- PC + target_offset
endif

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_BGEZC_DOCUMENTATION.=<u>Ramificación compacta si es mayor o igual que cero</u>

<b>Formato:</b>
bgezc rt, offset

| POP26  rs != 0   rt != 0    desplazamiento  |
|010110       rs = rt                         |
|  6        5         5             16        |


<b>Descripción:</b>
Ramificación compacta si GPR[rt] >= 0.

Un desplazamiento de 18 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción para formar una dirección efectiva.
Si el contenido del registro <i>rt</i> es mayor o igual que cero, la instrucción ejecuta la ramificación a la dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

<b>Operación:</b>
target_offset <- sign_extend(desplazamiento || 00)
condition <- GPR[rt] >= 0
if condition then
    PC <- PC + target_offset
endif

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_BGTZC_DOCUMENTATION.=<u>Ramificación compacta si es mayor que cero</u>

<b>Formato:</b>
bgtzc rt, offset

| POP27     0      rt != 0    desplazamiento  |
|010111   00000                               |
|  6        5         5             16        |


<b>Descripción:</b>
Ramificación compacta si GPR[rt] > 0.

Un desplazamiento de 18 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción para formar una dirección efectiva.
Si el contenido del registro <i>rt</i> es mayor que cero, la instrucción ejecuta la ramificación a la dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

<b>Operación:</b>
target_offset <- sign_extend(desplazamiento || 00)
condition <- GPR[rt] > 0
if condition then
    PC <- PC + target_offset
endif

<b>Excepciones:</b>
Ninguna
\END


INSTRUCTION_BLTZC_DOCUMENTATION.=<u>Ramificación compacta si es menor que cero</u>

<b>Formato:</b>
bltzc rt, offset

| POP27  rs != 0   rt != 0    desplazamiento  |
|010111       rs = rt                         |
|  6        5         5             16        |


<b>Descripción:</b>
Ramificación compacta si GPR[rt] < 0.

Un desplazamiento de 18 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción para formar una dirección efectiva.
Si el contenido del registro <i>rt</i> es menor que cero, la instrucción ejecuta la ramificación a la dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

<b>Operación:</b>
target_offset <- sign_extend(desplazamiento || 00)
condition <- GPR[rt] < 0
if condition then
    PC <- PC + target_offset
endif

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_BGEC_DOCUMENTATION.=<u>Ramificación compacta si es mayor o igual</u>

<b>Formato:</b>
bgec rs, rt, offset

| POP26  rs != 0   rt != 0    desplazamiento  |
|010110       rs != rt                        |
|  6        5         5             16        |


<b>Descripción:</b>
Ramificación compacta si GPR[rs] >= GPR[rt].

Un desplazamiento de 18 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción para formar una dirección efectiva.
Si el contenido del registro <i>rs</i> es mayor o igual que el contenido del registro <i>rt</i>, la instrucción ejecuta la ramificación a la dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

<b>Operación:</b>
target_offset <- sign_extend(desplazamiento || 00)
condition <- GPR[rs] >= GPR[rt]
if condition then
    PC <- PC + target_offset
endif

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_BLTC_DOCUMENTATION.=<u>Ramificación compacta si es menor</u>

<b>Formato:</b>
bltc rs, rt, offset

| POP27  rs != 0   rt != 0    desplazamiento  |
|010111       rs != rt                        |
|  6        5         5             16        |


<b>Descripción:</b>
Ramificación compacta si GPR[rs] < GPR[rt].

Un desplazamiento de 18 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción para formar una dirección efectiva.
Si el contenido del registro <i>rs</i> es menor que el contenido del registro <i>rt</i>, la instrucción ejecuta la ramificación a la dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

<b>Operación:</b>
target_offset <- sign_extend(desplazamiento || 00)
condition <- GPR[rt] < GPR[rt]
if condition then
    PC <- PC + target_offset
endif

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_BGEUC_DOCUMENTATION.=<u>Ramificación compacta si es mayor o igual sin signo</u>

<b>Formato:</b>
bgeuc rs, rt, offset

| POP06  rs != 0   rt != 0    desplazamiento  |
|000110       rs != rt                        |
|  6        5         5             16        |


<b>Descripción:</b>
Ramificación compacta si GPR[rs] >= GPR[rt].

Un desplazamiento de 18 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción para formar una dirección efectiva.
Si el contenido del registro <i>rs</i> es mayor o igual que el contenido del registro <i>rt</i>, la instrucción ejecuta la ramificación a la dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

<b>Operación:</b>
target_offset <- sign_extend(desplazamiento || 00)
condition <- unsigned_word(GPR[rt]) >= unsigned_word(GPR[rt])
if condition then
    PC <- PC + target_offset
endif

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_BLTUC_DOCUMENTATION.=<u>Ramificación compacta si es menor sin signo</u>

<b>Formato:</b>
bltuc rs, rt, offset

| POP07  rs != 0   rt != 0    desplazamiento  |
|000111       rs != rt                        |
|  6        5         5             16        |


<b>Descripción:</b>
Ramificación compacta si GPR[rs] < GPR[rt].

Un desplazamiento de 18 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción para formar una dirección efectiva.
Si el contenido del registro <i>rs</i> es menor que el contenido del registro <i>rt</i>, la instrucción ejecuta la ramificación a la dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

<b>Operación:</b>
target_offset <- sign_extend(desplazamiento || 00)
condition <- unsigned_word(GPR[rt]) < unsigned_word(GPR[rt])
if condition then
    PC <- PC + target_offset
endif

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_BEQC_DOCUMENTATION.=<u>Ramificación compacta si es igual</u>

<b>Formato:</b>
beqc rs, rt, offset

| POP10  rs != 0   rt != 0    desplazamiento  |
|001000       rs < rt                         |
|  6        5         5             16        |


<b>Descripción:</b>
Ramificación compacta si GPR[rs] = GPR[rt].

Un desplazamiento de 18 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción para formar una dirección efectiva.
Si el contenido del registro <i>rs</i> es igual que el contenido del registro <i>rt</i>, la instrucción ejecuta la ramificación a la dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

<b>Operación:</b>
target_offset <- sign_extend(desplazamiento || 00)
condition <- GPR[rt] = GPR[rt]
if condition then
    PC <- PC + target_offset
endif

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_BNEC_DOCUMENTATION.=<u>Ramificación compacta si no es igual</u>

<b>Formato:</b>
bnec rs, rt, offset

| POP30  rs != 0   rt != 0    desplazamiento  |
|011000       rs < rt                         |
|  6        5         5             16        |


<b>Descripción:</b>
Ramificación compacta si GPR[rs] != GPR[rt].

Un desplazamiento de 18 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción para formar una dirección efectiva.
Si el contenido del registro <i>rs</i> no es igual que el contenido del registro <i>rt</i>, la instrucción ejecuta la ramificación a la dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

<b>Operación:</b>
target_offset <- sign_extend(desplazamiento || 00)
condition <- GPR[rt] != GPR[rt]
if condition then
    PC <- PC + target_offset
endif

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_BEQZC_DOCUMENTATION.=<u>Ramificación compacta si es igual a cero</u>

<b>Formato:</b>
beqzc rs, offset

| POP66   BEQZC    desplazamiento  |
|110110  rs != 0                   |
|  6        5            16        |


<b>Descripción:</b>
Ramificación compacta si GPR[rs] == 0.

Un desplazamiento de 23 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción para formar una dirección efectiva.
Si el contenido del registro <i>rs</i> es igual que cero, la instrucción ejecuta la ramificación a la dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

<b>Operación:</b>
target_offset <- sign_extend(desplazamiento || 00)
condition <- GPR[rt] == 0
if condition then
    PC <- PC + target_offset
endif

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_BNEZC_DOCUMENTATION.=<u>Ramificación compacta si no es igual a cero</u>

<b>Formato:</b>
bnezc rs, offset

| POP76   BEQZC    desplazamiento  |
|111110  rs != 0                   |
|  6        5            16        |


<b>Descripción:</b>
Ramificación compacta si GPR[rs] != 0.

Un desplazamiento de 23 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción para formar una dirección efectiva.
Si el contenido del registro <i>rs</i> no es igual que cero, la instrucción ejecuta la ramificación a la dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

<b>Operación:</b>
target_offset <- sign_extend(desplazamiento || 00)
condition <- GPR[rt] != 0
if condition then
    PC <- PC + target_offset
endif

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_BGTZ_DOCUMENTATION.=<u>Ramificación si es mayor que cero</u>

<b>Formato:</b>
bgtz rs, offset

| BGTZ      rs     0      desplazamiento  |
|000111          00000                    |
|  6        5      5            16        |


<b>Descripción:</b>
Ramificación compacta si GPR[rs] > 0.

Un desplazamiento de 18 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción para formar una dirección efectiva.
Si el contenido del registro <i>rs</i> es mayor que cero, la instrucción ejecuta la ramificación a la dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

<b>Operación:</b>
<black>I:</black>
target_offset <- sign_extend(desplazamiento || 00)
condition <- GPR[rs] > 0
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>
Con el desplazamiento de 18 bits, el rango de la ramificación es de  ±128KBytes. Usa el salto (<black>j</black>) o el salto a registro (<black>jr</black>) para ramificar a direcciones fuera de este rango.
\END

INSTRUCTION_BITSWAP_DOCUMENTATION.=<u>Intercambiar bits en cada byte</u>

<b>Formato:</b>
bitswap rd, rt

|SPECIAL3    0    rt    rd    BITSWAP   BSGFL  |
| 011111   00000               00000    100000 |
|   6        5     5     5       5        6    |


<b>Descripción:</b>
GPR[rd].byte[i] <- reverse_bits(GPR[rt].byte[i]), para todos los bytes i

Se intercambian los bits de cada byte del registro <i>rt</i> y se guarda el resultado en la misma posición del byte en el registro <i>rd</i>.
Esta instrucción es opera en los 4 bytes de una palabra de 32 bits.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
Bit
function reverse_bits (in)
    out<sub>7</sub> <- in<sub>0</sub>
    out<sub>6</sub> <- in<sub>1</sub>
    out<sub>5</sub> <- in<sub>2</sub>
    out<sub>4</sub> <- in<sub>3</sub>
    out<sub>3</sub> <- in<sub>4</sub>
    out<sub>2</sub> <- in<sub>5</sub>
    out<sub>1</sub> <- in<sub>6</sub>
    out<sub>0</sub> <- in<sub>7</sub>
    return out
end function

for i in 0 to 3 do
    GPR[rd].byte[i] <- reverse_bits(GPR[rt].byte[i])
endfor

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_BLEZ_DOCUMENTATION.=<u>Ramificación si es menor o igual que cero</u>

<b>Formato:</b>
bgtz rs, offset

| BLEZ      rs     0      desplazamiento  |
|000110          00000                    |
|  6        5      5            16        |


<b>Descripción:</b>
Ramificación compacta si GPR[rs] <= 0.

Un desplazamiento de 18 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción para formar una dirección efectiva.
Si el contenido del registro <i>rs</i> es menor o igual que cero, la instrucción ejecuta la ramificación a la dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

<b>Operación:</b>
<black>I:</black>
target_offset <- sign_extend(desplazamiento || 00)
condition <- GPR[rs] <= 0
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>
Con el desplazamiento de 18 bits, el rango de la ramificación es de  ±128KBytes. Usa el salto (<black>j</black>) o el salto a registro (<black>jr</black>) para ramificar a direcciones fuera de este rango.
\END

INSTRUCTION_BLTZ_DOCUMENTATION.=<u>Ramificación si es menor que cero</u>

<b>Formato:</b>
bltz rs, offset

|REGIMM     rs    BLTZ    desplazamiento  |
|000001          00000                    |
|  6        5      5            16        |


<b>Descripción:</b>
Ramificación compacta si GPR[rs] < 0.

Un desplazamiento de 18 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción para formar una dirección efectiva.
Si el contenido del registro <i>rs</i> es menor cero, la instrucción ejecuta la ramificación a la dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

<b>Operación:</b>
<black>I:</black>
target_offset <- sign_extend(desplazamiento || 00)
condition <- GPR[rs] < 0
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>
Con el desplazamiento de 18 bits, el rango de la ramificación es de  ±128KBytes. Usa el salto (<black>j</black>) o el salto a registro (<black>jr</black>) para ramificar a direcciones fuera de este rango.
\END

INSTRUCTION_BNE_DOCUMENTATION.=<u>Ramificación si no es igual</u>

<b>Formato:</b>
bne rs, rt, desplazamiento

| BNE       rs     rt     desplazamiento  |
|000101                                   |
|  6        5      5            16        |


<b>Descripción:</b>
Ramificación si GPR[rs] != GPR[rt]

Un desplazamiento de 18 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción para formar una dirección efectiva.
Si el contenido de los registros <i>rt</i> y <i>rs</i> no son iguales, la instrucción ejecuta la ramificación a la dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

<b>Operación:</b>
<black>I:</black>
target_offset <- sign_extend(desplazamiento || 00)
condition <- GPR[rs] != GPR[rt]
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>
Con el desplazamiento de 18 bits, el rango de la ramificación es de  ±128KBytes. Usa el salto (<black>j</black>) o el salto a registro (<black>jr</black>) para ramificar a direcciones fuera de este rango.
\END

INSTRUCTION_BOVC_DOCUMENTATION.=<u>Ramificación si la suma desborda</u>

<b>Formato:</b>
bovc rs, rt, offset

| POP10     rs        rt      desplazamiento  |
|001000       rs >= rt                        |
|  6        5         5             16        |


<b>Descripción:</b>
Ramificación compacta si GPR[rs] + GPR[rt] desborda

Un desplazamiento de 18 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción para formar una dirección efectiva.
Si el contenido del registro <i>rt</i> mas el contenido del registro <i>rs</i> desborda, la instrucción ejecuta la ramificación a la dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

<b>Operación:</b>
target_offset <- sign_extend(desplazamiento || 00)
temp_d = GPR[rs] + GPR[rt]
condition <- temp_d<sub>32</sub> != temp_d<sub>31</sub>

if condition then
    PC <- PC + target_offset
endif

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_BNVC_DOCUMENTATION.=<u>Ramificación si la suma no desborda</u>

<b>Formato:</b>
bnvc rs, rt, offset

| POP30     rs        rt      desplazamiento  |
|011000       rs >= rt                        |
|  6        5         5             16        |


<b>Descripción:</b>
Ramificación compacta si GPR[rs] + GPR[rt] no desborda

Un desplazamiento de 18 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción para formar una dirección efectiva.
Si el contenido del registro <i>rt</i> mas el contenido del registro <i>rs</i> no desborda, la instrucción ejecuta la ramificación a la dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

<b>Operación:</b>
target_offset <- sign_extend(desplazamiento || 00)
temp_d = GPR[rs] + GPR[rt]
condition <- temp_d<sub>32</sub> = temp_d<sub>31</sub>

if condition then
    PC <- PC + target_offset
endif

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_BREAK_DOCUMENTATION.=<u>Punto de ruptura</u>

<b>Formato:</b>
break

|SPECIAL    0       BREAK  |
|000000                    |
|  6        20     001101  |


<b>Descripción:</b>
Punto de ruptura

Una excepción Breakpoint es lanzada, transfiriendo el control al manejador de excepciones de manera inmediata e incondicional.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
SignalException(Breakpoint)

<b>Excepciones:</b>
Breakpoint
\END

INSTRUCTION_CEIL_L_D_DOCUMENTATION.=<u>Función techo de coma flotante doble a doble palabra</u>

<b>Formato:</b>
ceil.l.d fd, fs

| COP1      fmt      0      fs      fd     CEIL.L |
|010001    10001   00000                   001010 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
FPR[fd] <- convert_and_round(FPR[fs])

El valor en coma flotante de precisión doble guardado en <i>fs</i> es transformado en una palabra de 64 bits, redondeando hacia arriba.
El resultado es asignado a <i>fd</i>.

Cuando el valor en <i>fs</i> es <black>Infinito</black>, <black>NaN</black> o está fuera del rango de una palabra de 64 bits, el resultado no puede ser representado correctamente. Estos casos son tratados por la máquina virtual de Java.

<b>Restricciones:</b>
Los registros <i>fs</i> y <i>fd</i> deben ser FPRs pares. Si los registros no son válidos, el resultado es <black>IMPREDECIBLE</black>.
El operando debe ser un valor en coma flotante de precisión doble. Si no lo es, el resultado es <black>IMPREDECIBLE</black>.

<b>Operación:</b>
fmt <- double
StoreFPR(fd, L, ConvertFmt(ValueFPR(fs, fmt), fmt, L))

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_CEIL_W_D_DOCUMENTATION.=<u>CFunción techo de coma flotante doble a palabra</u>

<b>Formato:</b>
ceil.w.d fd, fs

| COP1      fmt      0      fs      fd     CEIL.W |
|010001    10001   00000                   001110 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
FPR[fd] <- convert_and_round(FPR[fs])

El valor en coma flotante de precisión doble guardado en <i>fs</i> es transformado en una palabra de 32 bits, redondeando hacia arriba.
El resultado es asignado a <i>fd</i>.

Cuando el valor en <i>fs</i> es <black>Infinito</black>, <black>NaN</black> o está fuera del rango de una palabra de 32 bits, el resultado no puede ser representado correctamente. Estos casos son tratados por la máquina virtual de Java.

<b>Restricciones:</b>
El registro <i>fs</i> debe ser un FPR par. El registro no es válido, el resultado es <black>IMPREDECIBLE</black>.
El operando debe ser un valor en coma flotante de precisión doble. Si no lo es, el resultado es <black>IMPREDECIBLE</black>.

<b>Operación:</b>
fmt <- double
StoreFPR(fd, W, ConvertFmt(ValueFPR(fs, fmt), fmt, W))

<b>Excepciones:</b>
Ninguna
\END


INSTRUCTION_CEIL_L_S_DOCUMENTATION.=<u>Función techo de coma flotante a doble palabra</u>

<b>Formato:</b>
ceil.l.s fd, fs

| COP1      fmt      0      fs      fd     CEIL.L |
|010001    10000   00000                   001010 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
FPR[fd] <- convert_and_round(FPR[fs])

El valor en coma flotante guardado en <i>fs</i> es transformado en una palabra de 64 bits, redondeando hacia arriba.
El resultado es asignado a <i>fd</i>.

Cuando el valor en <i>fs</i> es <black>Infinito</black>, <black>NaN</black> o está fuera del rango de una palabra de 64 bits, el resultado no puede ser representado correctamente. Estos casos son tratados por la máquina virtual de Java.

<b>Restricciones:</b>
El registro <i>fd</i> debe ser un FPR par. El registro no es válido, el resultado es <black>IMPREDECIBLE</black>.
El operando debe ser un valor en coma flotante. Si no lo es, el resultado es <black>IMPREDECIBLE</black>.

<b>Operación:</b>
fmt <- float
StoreFPR(fd, L, ConvertFmt(ValueFPR(fs, fmt), fmt, L))

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_CEIL_W_S_DOCUMENTATION.=<u>Función techo de coma flotante a palabra</u>

<b>Formato:</b>
ceil.w.s fd, fs

| COP1      fmt      0      fs      fd     CEIL.W |
|010001    10000   00000                   001110 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
FPR[fd] <- convert_and_round(FPR[fs])

El valor en coma flotante guardado en <i>fs</i> es transformado en una palabra de 32, redondeando hacia arriba.
El resultado es asignado a <i>fd</i>.

Cuando el valor en <i>fs</i> es <black>Infinito</black>, <black>NaN</black> o está fuera del rango de una palabra de 32 bits, el resultado no puede ser representado correctamente. Estos casos son tratados por la máquina virtual de Java.

<b>Restricciones:</b>
El operando debe ser un valor en coma flotante. Si no lo es, el resultado es <black>IMPREDECIBLE</black>.

<b>Operación:</b>
fmt <- float
StoreFPR(fd, W, ConvertFmt(ValueFPR(fs, fmt), fmt, W))

<b>Excepciones:</b>
Ninguna
\END


INSTRUCTION_CLO_DOCUMENTATION.=<u>Conteo de los primeros unos en una palabra</u>

<b>Formato:</b>
clo rd, rs

|SPECIAL     rs      0      rd      1       CLO   |
|000000            00000          00001    010001 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
GPR[rd] <- count_leading_ones(GPR[rs])

Los bits guardados en el registro <i>rs</i> son escaneados desde el más significante al menos significante. El conteo de los primeros unos en la palabra es guardado en el registro <i>rd</i>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>

temp <- 32
for i in 31 to 0
    if GPR[rs]<sub>i</sub> = 0 then
        temp <- 31 - i
        break
    endif
endfor
GPR[rd] <- temp

<b>Excepciones:</b>
Ninguna
\END


INSTRUCTION_CLZ_DOCUMENTATION.=<u>Conteo de los primeros ceros en una palabra</u>

<b>Formato:</b>
clz rd, rs

|SPECIAL     rs      0      rd      1       CLZ   |
|000000            00000          00001    010000 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
GPR[rd] <- count_leading_zeros(GPR[rs])

Los bits guardados en el registro <i>rs</i> son escaneados desde el más significante al menos significante. El conteo de los primeros ceros en la palabra es guardado en el registro <i>rd</i>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>

temp <- 32
for i in 31 to 0
    if GPR[rs]<sub>i</sub> = 1 then
        temp <- 31 - i
        break
    endif
endfor
GPR[rd] <- temp

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_CMP_D_DOCUMENTATION.=<u>Comparación en coma flotante doble ({TYPE})</u>

<b>Formato:</b>
cmp.{MNEMONIC}.d fd, fs, ft

| COP1    CMP.c.D   ft   fs   fd   0   {MNEMONIC}\t|
|000001    10101                   0   {CODE}\t|
|  6         5      5    5    5    1     5     \t|


<b>Descripción:</b>
FPR[fd] <- FPR[fs] compare_cond FPR[ft] donde compare_cond = {TYPE}.

El valor guardado en el registro <i>fs</i> es comparado con el valor en el registro <i>it</i>.
El registro <i>fd</i> es rellenado con unos o con zeros, dependiendo de si el resultado es verdadero o falso.

Los bits del 2 al 0 en la condición representan cada uno una condición. Si uno de estos bits está activado la condición correspondiente será evaluada.
El resultado es verdadero cuando alguna de estas condiciones de verdadero.

Las condiciones vinculadas a cada bit son las siguientes:
- Bit 0: desordenado.
- Bit 1: igualdad.
- Bit 2: menor que.

Si el bit 4 está activado el resultado es negado.
Si el bit 3 está activado y alguno de los operandos es <black>NaN</black>, una excepción Floating Point Exception será lanzada.

<b>Restricciones:</b>
Los registros <i>fs</i>, <i>ft</i> y <i>fd</i> deben ser FPRs pares. Si los registros no son válidos, el resultado es <black>IMPREDECIBLE</black>.
Los operandos deben ser valores en coma flotante de precisión doble. Si no los son, el resultado es <black>IMPREDECIBLE</black>.

<b>Operación:</b>
fmt <- double
fsv <- ValueFPR(fs, fmt)
ftv <- ValueFPR(ft, fmt)

if is_NaN(fsv) or is_NaN(ftv) then
    less <- false
    equal <- false
    unordered <- true
    if cond<sub>3</sub> then
        SignalException(FloatingPointException)
    endif
else
    less <- fsv <<sub>fmt</sub> ftv
    less <- fsv =<sub>fmt</sub> ftv
    unordered <- false
endif

condition <- cond<sub>4</sub> xor ((cond<sub>2</sub> and less) or (cond<sub>1</sub> and equal) or (cond<sub>0</sub> and unordered))
StoreFPR(fd, fmt, extend_bit.fmt(condition))

<b>Excepciones:</b>
Floating Point Exception
\END

INSTRUCTION_CMP_S_DOCUMENTATION.=<u>Comparación en coma flotante ({TYPE})</u>

<b>Formato:</b>
cmp.{MNEMONIC}.s fd, fs, ft

| COP1    CMP.c.S   ft   fs   fd   0   {MNEMONIC}\t|
|000001    10100                   0   {CODE}\t|
|  6         5      5    5    5    1     5     \t|


<b>Descripción:</b>
FPR[fd] <- FPR[fs] compare_cond FPR[ft] donde compare_cond = {TYPE}.

El valor guardado en el registro <i>fs</i> es comparado con el valor en el registro <i>it</i>.
El registro <i>fd</i> es rellenado con unos o con zeros, dependiendo de si el resultado es verdadero o falso.

Los bits del 2 al 0 en la condición representan cada uno una condición. Si uno de estos bits está activado la condición correspondiente será evaluada.
El resultado es verdadero cuando alguna de estas condiciones de verdadero.

Las condiciones vinculadas a cada bit son las siguientes:
- Bit 0: desordenado.
- Bit 1: igualdad.
- Bit 2: menor que.

Si el bit 4 está activado el resultado es negado.
Si el bit 3 está activado y alguno de los operandos es <black>NaN</black>, una excepción Floating Point Exception será lanzada.

<b>Restricciones:</b>
Los operandos deben ser valores en coma flotante de precisión doble. Si no los son, el resultado es <black>IMPREDECIBLE</black>.

<b>Operación:</b>
fmt <- float
fsv <- ValueFPR(fs, fmt)
ftv <- ValueFPR(ft, fmt)

if is_NaN(fsv) or is_NaN(ftv) then
    less <- false
    equal <- false
    unordered <- true
    if cond<sub>3</sub> then
        SignalException(FloatingPointException)
    endif
else
    less <- fsv <<sub>fmt</sub> ftv
    less <- fsv =<sub>fmt</sub> ftv
    unordered <- false
endif

condition <- cond<sub>4</sub> xor ((cond<sub>2</sub> and less) or (cond<sub>1</sub> and equal) or (cond<sub>0</sub> and unordered))
StoreFPR(fd, fmt, extend_bit.fmt(condition))

<b>Excepciones:</b>
Floating Point Exception
\END

INSTRUCTION_CVT_DOCUMENTATION.=<u>Convertir número de {FROM} a {TO}</u>

<b>Formato:</b>
cvt.{TO_MNEMONIC}.{FROM_MNEMONIC} fd, fs

| COP1      fmt      0      fs      fd      CVT.{TO_MNEMONIC}  |
|010001    {FROM_FMT}   00000                   {TO_CVT}  |
|  6         5       5      5       5        6     |


<b>Descripción:</b>
FPR[fd] <- convert_and_round(FPR[fs])

El valor en el registro <i>fs</i> en el formato {FROM} es convertido a un valor en el formato {TO}.
El resultado es asignado al registro <i>fd</i>.

<b>Restricciones:</b>
Aquellos valores cuyo formato depende de dos registros deben ser colocados en un registro par. Si esto no se cumple, el resultado es <black>IMPREDECIBLE</black>.
El operando debe estár en su formado correspondiente. Si esto no se cumple, el resultado es <black>IMPREDECIBLE</black>.

<b>Operación:</b>
from <- {FROM_MNEMONIC}
to <- {TO_MNEMONIC}
StoreFPR(fd, to, ConvertFmt(ValueFPR(fs, from), from, to))

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_DIV_DOCUMENTATION.=<u>División</u>

<b>Formato:</b>
div rd, rs, rt

|SPECIAL     rs      rt     rd     DIV      SOP32 |
|000000                           00010    011010 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
GPR[rd] <- GPR[rs] / GPR[rt]

El valor del registro <i>rs</i> es dividido entre el valor del registro <i>rt</i> para producir un cociente de 32 bits.
El cociente es asignado al registro <i>rd</i>.

<b>Restricciones:</b>
Si el divisor en el registro <i>rt</i> es cero, el resultado es <black>IMPREDECIBLE</black>.

<b>Operación:</b>

GPR[rd] <- GPR[rs] / GPR[rt]

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>
Ya que las instrucciones de división y módulo están definidas para no producir excepciones al dividir entre zero, el seguro crear código que comprueba divisiones entre zero después de la instrucción de módulo o división.
\END

INSTRUCTION_MOD_DOCUMENTATION.=<u>Módulo</u>

<b>Formato:</b>
mod rd, rs, rt

|SPECIAL     rs      rt     rd     MOD      SOP32 |
|000000                           00011    011010 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
GPR[rd] <- GPR[rs] % GPR[rt]

El valor del registro <i>rs</i> es dividido entre el valor del registro <i>rt</i> para producir un resto de 32 bits.
El resto es asignado al registro <i>rd</i>.

<b>Restricciones:</b>
Si el divisor en el registro <i>rt</i> es cero, el resultado es <black>IMPREDECIBLE</black>.

<b>Operación:</b>

GPR[rd] <- GPR[rs] % GPR[rt]

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>
Ya que las instrucciones de división y módulo están definidas para no producir excepciones al dividir entre zero, el seguro crear código que comprueba divisiones entre zero después de la instrucción de módulo o división.
\END

INSTRUCTION_DIVU_DOCUMENTATION.=<u>División sin signo</u>

<b>Formato:</b>
divu rd, rs, rt

|SPECIAL     rs      rt     rd     DIVU     SOP33 |
|000000                           00010    011011 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
GPR[rd] <- GPR[rs] / GPR[rt]

El valor del registro <i>rs</i> es dividido entre el valor del registro <i>rt</i> para producir un cociente de 32 bits.
El cociente es asignado al registro <i>rd</i>.

<b>Restricciones:</b>
Si el divisor en el registro <i>rt</i> es cero, el resultado es <black>IMPREDECIBLE</black>.

<b>Operación:</b>

GPR[rd] <- unsigned_word(GPR[rs]) / unsigned_word(GPR[rt])

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>
Ya que las instrucciones de división y módulo están definidas para no producir excepciones al dividir entre zero, el seguro crear código que comprueba divisiones entre zero después de la instrucción de módulo o división.
\END

INSTRUCTION_MODU_DOCUMENTATION.=<u>Módulo sin signo</u>

<b>Formato:</b>
modu rd, rs, rt

|SPECIAL     rs      rt     rd     MODU     SOP33 |
|000000                           00011    011011 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
GPR[rd] <- GPR[rs] % GPR[rt]

El valor del registro <i>rs</i> es dividido entre el valor del registro <i>rt</i> para producir un resto de 32 bits.
El resto es asignado al registro <i>rd</i>.

<b>Restricciones:</b>
Si el divisor en el registro <i>rt</i> es cero, el resultado es <black>IMPREDECIBLE</black>.

<b>Operación:</b>

GPR[rd] <- unsigned_word(GPR[rs]) % unsigned_word(GPR[rt])

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>
Ya que las instrucciones de división y módulo están definidas para no producir excepciones al dividir entre zero, el seguro crear código que comprueba divisiones entre zero después de la instrucción de módulo o división.
\END

INSTRUCTION_DIV_D_DOCUMENTATION.=<u>División en coma flotante de precisión doble</u>

<b>Formato:</b>
div.d fd, fs, ft

| COP1      fmt      0      fs      fd      DIV   |
|010001    10001   00000                   000011 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
FPR[fd] <- FRP[fs] / FPR[ft]

El valor en el registro <i>ft</i> es dividido entre el valor en el registro <i>fs</i>. El resultado es calculado en precisión infinita, usando el redondeo proporcionado por <i>Java</i>, y asignado al registro <i>fd</i>.
Los operando y el resultado son valores en coma flotante de precisión doble.

<b>Restricciones:</b>
Los registros <i>fs</i>, <i>ft</i> y <i>fd</i> deben ser FPRs pares. Si los registros no son válidos, el resultado es <black>IMPREDECIBLE</black>.
Los operandos deben ser valores en coma flotante de precisión doble. Si no los son, el resultado es <black>IMPREDECIBLE</black>.

<b>Operación:</b>
fmt <- double
StoreFPR(fd, fmt, ValueFPR(fs, fmt) /<sub>fmt</sub> ValueFPR(ft, fmt))

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_DIV_S_DOCUMENTATION.=<u>División en coma flotante</u>

<b>Formato:</b>
div.s fd, fs, ft

| COP1      fmt      0      fs      fd      DIV   |
|010001    10000   00000                   000011 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
FPR[fd] <- FRP[fs] / FPR[ft]

El valor en el registro <i>ft</i> es dividido entre el valor en el registro <i>fs</i>. El resultado es calculado en precisión infinita, usando el redondeo proporcionado por <i>Java</i>, y asignado al registro <i>fd</i>.
Los operando y el resultado son valores en coma flotante.

<b>Restricciones:</b>
Los operandos deben ser valores en coma flotante. Si no los son, el resultado es <black>IMPREDECIBLE</black>.

<b>Operación:</b>
fmt <- float
StoreFPR(fd, fmt, ValueFPR(fs, fmt) /<sub>fmt</sub> ValueFPR(ft, fmt))

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_ERET_DOCUMENTATION.=<u>Retorno de la excepción</u>

<b>Formato:</b>
eret

| COP0     CO    0     ERET   |
|010000    1           011000 |
|  6       1     19      6    |


<b>Descipción:</b>
Esta instrucción borra la ejecución y todos los riesgos de instrucciones y retorna a la instrucción interrumpida por una interrupción, excepción o error de procesamiento.
<black>eret</black> no ejecuta la siguiente ejecución y no tiene ningún hueco de retardo.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

<b>Operación:</b>

if Status<sub>ERL</sub> = 1 then
    temp <- ErrorEPC
    Status<sub>ERL</sub> <- 0
else
    temp <- EPC
    Status<sub>EXL</sub> <- 0
endif

PC <- temp

ClearHazards()

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_J_DOCUMENTATION.=<u>Salto</u>

<b>Formato:</b>
j target

|  J      index |
|000010         |
|  6       26   |


<b>Descripción:</b>
Esta es una ramificación relativa a la región del PC (no al PC en sí); el rango es una región alineada de 256MB.
Los 28 bits menos significativos de la dirección efectiva están compuestos por la celda <i>index</i> desplazada dos posiciones a la izquierda. Los bits restantes corresponden a los bits de la dirección de la instruccion en el hueco de retardo (o la instrucción que le sigue si los huecos de retardo están deshabilitados).
La instruccción salta a la dirección efectiva. Si los huecos de retardo están habilitados, esta instrucción también ejecuta la instrucción que le sigue antes de realizar el salto.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

<b>Operación:</b>

<black>I:</black>
<black>I+1:</black>
PC <- PC<sub>31..28</sub> || index || 00

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>
El formar la dirección efectiva concatenando el PC y los bits de la celda <i>index</i> en vez de añadir in desplazamiento al PC es una ventaja si todo el código del programa entra en una región de 256MB alineada en un entorno de 256MB. Permite realizar una ramificación de y a cualquier instrucción de la región, acto que no es posible con un desplazamiento.
Esta definición crea el siguiente caso límite: cuando la instrucción de salto está en la última palabra de la región de 256, ésta solo puede realizar un salto a los 256MB de la región que contiene el hueco de retardo.
La instrucción de salto ha sido marcada como obsoleta en la Release 6. Use <black>bc</black> en su lugar.
\END

INSTRUCTION_JAL_DOCUMENTATION.=<u>Salto y enlace</u>

<b>Formato:</b>
jal target

| JAL     index |
|000011         |
|  6       26   |


<b>Descripción:</b>
Esta es una ramificación relativa a la región del PC (no al PC en sí); el rango es una región alineada de 256MB.

Inserta la dirección de retorno en el registro <i>31</i>. Ésta es la dirección de la instrucción donde la ejecución debe continuar después de una llamada a un procedimiento.
Los 28 bits menos significativos de la dirección efectiva están compuestos por la celda <i>index</i> desplazada dos posiciones a la izquierda. Los bits restantes corresponden a los bits de la dirección de la instruccion en el hueco de retardo (o la instrucción que le sigue si los huecos de retardo están deshabilitados).
La instruccción salta a la dirección efectiva. Si los huecos de retardo están habilitados, esta instrucción también ejecuta la instrucción que le sigue antes de realizar el salto.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

<b>Operación:</b>

<black>I:</black>
GPR[31] <- PC + 4
<black>I+1:</black>
PC <- PC<sub>31..28</sub> || index || 00

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>
El formar la dirección efectiva concatenando el PC y los bits de la celda <i>index</i> en vez de añadir in desplazamiento al PC es una ventaja si todo el código del programa entra en una región de 256MB alineada en un entorno de 256MB. Permite realizar una ramificación de y a cualquier instrucción de la región, acto que no es posible con un desplazamiento.
Esta definición crea el siguiente caso límite: cuando la instrucción de salto está en la última palabra de la región de 256, ésta solo puede realizar un salto a los 256MB de la región que contiene el hueco de retardo.
La instrucción de salto y enlace ha sido marcada como obsoleta en la Release 6. Use <black>balc</black> en su lugar.
\END

INSTRUCTION_JALR_DOCUMENTATION.=<u>Salto y enlace a registro</u>

<b>Formato:</b>
jalr rs (rd = 31 implícito)
jalr rd, rs

|SPECIAL     rs      rt     rd      0       JALR  |
|000000                                    001001 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
GPR[rd] <- return_addr, PC <- GPR[rs]

Inserta la dirección de retorno en el registro <i>rd</i>. Ésta es la dirección de la instrucción donde la ejecución debe continuar después de una llamada a un procedimiento.

Salta a la dirección efectiva guardada en el registro <i>rs</i>. Si la dirección efectiva no está alineada a 4 bytes, una excepción Address Error es lanzada cuando los datos de la instrucción son recogidos.
Si los huecos de retardo están habilitados, esta instrucción también ejecuta la instrucción que le sigue antes de realizar el salto.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

Los registros <i>rs</i> y <i>rd</i> no deben ser los mismos, ya que una instrucción como ésta no tendría el mismo efecto cuando se volviera a ejecutar. El resultado de la ejecución de dicha instrucción es <black>IMPREDECIBLE</black>. Esta restricción permite al manejador de excepciones retomar la ejecución volviendo a ejecutar la ramificación cuando una excepción ocurre en el hueco de retardo.

<b>Operación:</b>
<black>I:</black>
temp <- GPR[rs]
GPR[31] <- PC + 4l
<black>I+1:</black>
PC <- temp

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>
Esta instrucción de salto y enlace a registro permite seleccionar el registro donde se guarda la dirección de retorno; otras instrucciones de enlace usan el registro 31.
El registro por defecto para <i>rd</i>, si se omite en la instrucción en ensamblador, es el 31.
\END

INSTRUCTION_LB_DOCUMENTATION.=<u>Cargar byte</u>

<b>Formato:</b>
lb rt desplazamiento(base)

|  LB      base     rt    desplazamiento |
|100000                                  |
|  6        5       5           16       |


<b>Descripción:</b>
GPR[rt] <- memory[GPR[base] + desplazamiento]

El contenido de la palabra de 8 bits guardada en la dirección de memoria efectiva es cargado, extendido con signo e insertado en el registro <i>rt</i>.
El contenido de la celda <i>desplazamiento</i> es sumado al contenido del registro <i>base</i> para formar la dirección efectiva.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
v_addr <- sign_extend(desplazamiento) + GPR[base]
(p_addr, cca) <- AddressTranslation(v_addr, DATA, LOAD)
mem_byte <- LoadMemory(CCA, BYTE, p_addr, v_addr, DATA)
GPR[rt] <- sign_extend(mem_byte)

<b>Excepciones:</b>
Address Error
\END

INSTRUCTION_LW_DOCUMENTATION.=<u>Cargar palabra</u>

<b>Formato:</b>
lw rt desplazamiento(base)

|  LB      base     rt    desplazamiento |
|100000                                  |
|  6        5       5           16       |


<b>Descripción:</b>
GPR[rt] <- memory[GPR[base] + desplazamiento]

El contenido de la palabra de 32 bits guardada en la dirección de memoria efectiva es cargado, extendido con signo e insertado en el registro <i>rt</i>.
El contenido de la celda <i>desplazamiento</i> es sumado al contenido del registro <i>base</i> para formar la dirección efectiva.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
v_addr <- sign_extend(desplazamiento) + GPR[base]
(p_addr, cca) <- AddressTranslation(v_addr, DATA, LOAD)
mem_byte <- LoadMemory(CCA, WORD, p_addr, v_addr, DATA)
GPR[rt] <- sign_extend(mem_byte)

<b>Excepciones:</b>
Address Error
\END

INSTRUCTION_MFC0_DOCUMENTATION.=<u>Mover desde el coprocesador 0</u>

<b>Formato:</b>
mfc0 rt, rd (sel = 0 implícito)
mfc0 rt, rd, sel

| COP0     MF     rt    rd    0    sel |
|010000  00000                         |
|  6       5      5     5     8     0  |


<b>Descripción:</b>
GPR[rt] <- CPR[0, rd, sel]

El contenido del registro del coprocesador 0 espeficiado por la combinación de <i>rd</i> y <i>sel</i> es cargado en el registro de propósito general <i>rt</i>.

<b>Restricciones:</b>
Leer un registro reservado o un registro que no está implementado en la configuración actual devuelve 0.

<b>Operación:</b>
if IsCoprocessorRegisterImplemented(0, rd, sel) then
    GPR[rt] <- CPR[0, rd, sel]
else
    GPR[rt] <- 0
endif

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_MFC1_DOCUMENTATION.=<u>Mover desde el coprocesador 1</u>

<b>Formato:</b>
mfc1 rt, rd

| COP1     MF     rt    fs     0 |
|010001  00000                   |
|  6       5      5     5     11 |


<b>Descripción:</b>
GPR[rt] <- FPR[fs]

El contenido del registro del coprocesador 1 <i>fs</i> es cargado en el registro de propósito general <i>rt</i>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
GPR[rt] <- ValueFPR(fs, UNINTERPRETED_WORD)

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_MTC0_DOCUMENTATION.=<u>Mover al coprocesador 0</u>

<b>Formato:</b>
mtc0 rt, rd (sel = 0 implícito)
mtc0 rt, rd, sel

| COP0     MT     rt    rd    0    sel |
|010000  00100                         |
|  6       5      5     5     8     0  |


<b>Descripción:</b>
CPR[0, rd, sel] <- GPR[rt]

El contenido del registro de propósito general <i>rt</i> es cargado en el registro del coprocesador 0 espeficiado por la combinación de <i>rd</i> y <i>sel</i>.

<b>Restricciones:</b>
Las escrituras a un registro reservado o a un registro que no está implementado en la configuración actual son ignoradas.

<b>Operación:</b>
if IsCoprocessorRegisterImplemented(0, rd, sel) then
    CPR[0, rd, sel] <- GPR[rt]
endif

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_MTC1_DOCUMENTATION.=<u>Mover al coprocesador 1</u>

<b>Formato:</b>
mtc1 rt, rd

| COP1     MT     rt    fs     0 |
|010001  00100                   |
|  6       5      5     5     11 |


<b>Descripción:</b>
FPR[fs] <- GPR[rt]

El contenido del registro de propósito general <i>rt</i> es cargado en el registro del coprocesador 1 <i>fs</i>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
StoreFPR(fs, UNINTERPRETED_WORD, GPR[rt])

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_MUL_DOCUMENTATION.=<u>Multiplicación devolviendo la parte menos significante</u>

<b>Formato:</b>
mul rd, rs, rt

|SPECIAL     rs      rt     rd     MUL      SOP30 |
|000000                           00010    011000 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
GPR[rd] <- lo_word(GPR[rs] * GPR[rt])

El valor del registro <i>rs</i> es multiplicado por el valor del registro <i>rt</i> para producir una palabra de 32 bits que contiene los 32 bits menos significantes del resultado.
Dicha palabra es asignada al registro <i>rd</i>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>

GPR[rd] <- lo_word(GPR[rs] * GPR[rt])

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>

La parte menos significante de la multiplicación de enteros es idéntica en números con o sin signo. Sin embargo, existen diferentes instrucciones para la multiplicación de enteros con y sin signo que producen la parte menos significado del resultado.
Las implementaciones pueden optimizar los casos donde una multiplicación que produce la parte menos significante le siga una multiplicación que produce la parte más significante. Es recomendado que los programadores usen los pares de instrucciones correspondientes.
\END

INSTRUCTION_MUH_DOCUMENTATION.=<u>Multiplicación devolviendo la parte más significante</u>

<b>Formato:</b>
muh rd, rs, rt

|SPECIAL     rs      rt     rd     MUH      SOP30 |
|000000                           00011    011000 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
GPR[rd] <- hi_word(GPR[rs] * GPR[rt])

El valor del registro <i>rs</i> es multiplicado por el valor del registro <i>rt</i> para producir una palabra de 32 bits que contiene los 32 bits más significantes del resultado.
Dicha palabra es asignada al registro <i>rd</i>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>

GPR[rd] <- hi_word(GPR[rs] * GPR[rt])

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>

La parte menos significante de la multiplicación de enteros es idéntica en números con o sin signo. Sin embargo, existen diferentes instrucciones para la multiplicación de enteros con y sin signo que producen la parte menos significado del resultado.
Las implementaciones pueden optimizar los casos donde una multiplicación que produce la parte menos significante le siga una multiplicación que produce la parte más significante. Es recomendado que los programadores usen los pares de instrucciones correspondientes.
\END

INSTRUCTION_MULU_DOCUMENTATION.=<u>Multiplicación sin signo devolviendo la parte menos significante</u>

<b>Formato:</b>
mulu rd, rs, rt

|SPECIAL     rs      rt     rd     MULU     SOP31 |
|000000                           00010    011001 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
GPR[rd] <- lo_word(GPR[rs] * GPR[rt])

El valor del registro <i>rs</i> es multiplicado por el valor del registro <i>rt</i> para producir una palabra de 32 bits que contiene los 32 bits menos significantes del resultado.
Dicha palabra es asignada al registro <i>rd</i>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>

GPR[rd] <- lo_word(unsigned_word(GPR[rs]) * unsigned_word(GPR[rt]))

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>

La parte menos significante de la multiplicación de enteros es idéntica en números con o sin signo. Sin embargo, existen diferentes instrucciones para la multiplicación de enteros con y sin signo que producen la parte menos significado del resultado.
Las implementaciones pueden optimizar los casos donde una multiplicación que produce la parte menos significante le siga una multiplicación que produce la parte más significante. Es recomendado que los programadores usen los pares de instrucciones correspondientes.
\END

INSTRUCTION_MUHU_DOCUMENTATION.=<u>Multiplicación sin signo devolviendo la parte más significante</u>

<b>Formato:</b>
muhu rd, rs, rt

|SPECIAL     rs      rt     rd     MUHU     SOP31 |
|000000                           00011    011001 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
GPR[rd] <- hi_word(GPR[rs] * GPR[rt])

El valor del registro <i>rs</i> es multiplicado por el valor del registro <i>rt</i> para producir una palabra de 32 bits que contiene los 32 bits más significantes del resultado.
Dicha palabra es asignada al registro <i>rd</i>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>

GPR[rd] <- hi_word(unsigned_word(GPR[rs]) * unsigned_word(GPR[rt]))

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>

La parte menos significante de la multiplicación de enteros es idéntica en números con o sin signo. Sin embargo, existen diferentes instrucciones para la multiplicación de enteros con y sin signo que producen la parte menos significado del resultado.
Las implementaciones pueden optimizar los casos donde una multiplicación que produce la parte menos significante le siga una multiplicación que produce la parte más significante. Es recomendado que los programadores usen los pares de instrucciones correspondientes.
\END

INSTRUCTION_MUL_D_DOCUMENTATION.=<u>Multiplicación en coma flotante de precisión doble</u>

<b>Formato:</b>
mul.d fd, fs, ft

| COP1      fmt      0      fs      fd      MUL   |
|010001    10001   00000                   000010 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
FPR[fd] <- FRP[fs] * FPR[ft]

El valor en el registro <i>ft</i> es multiplicado por el valor en el registro <i>fs</i>. El resultado es calculado en precisión infinita, usando el redondeo proporcionado por <i>Java</i>, y asignado al registro <i>fd</i>.
Los operando y el resultado son valores en coma flotante de precisión doble.

<b>Restricciones:</b>
Los registros <i>fs</i>, <i>ft</i> y <i>fd</i> deben ser FPRs pares. Si los registros no son válidos, el resultado es <black>IMPREDECIBLE</black>.
Los operandos deben ser valores en coma flotante de precisión doble. Si no los son, el resultado es <black>IMPREDECIBLE</black>.

<b>Operación:</b>
fmt <- double
StoreFPR(fd, fmt, ValueFPR(fs, fmt) *<sub>fmt</sub> ValueFPR(ft, fmt))

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_DIV_S_DOCUMENTATION.=<u>Multiplicación en coma flotante</u>

<b>Formato:</b>
div.s fd, fs, ft

| COP1      fmt      0      fs      fd      MUL   |
|010001    10000   00000                   000010 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
FPR[fd] <- FRP[fs] * FPR[ft]

El valor en el registro <i>ft</i> es multiplicado por el valor en el registro <i>fs</i>. El resultado es calculado en precisión infinita, usando el redondeo proporcionado por <i>Java</i>, y asignado al registro <i>fd</i>.
Los operando y el resultado son valores en coma flotante.

<b>Restricciones:</b>
Los operandos deben ser valores en coma flotante. Si no los son, el resultado es <black>IMPREDECIBLE</black>.

<b>Operación:</b>
fmt <- float
StoreFPR(fd, fmt, ValueFPR(fs, fmt) *<sub>fmt</sub> ValueFPR(ft, fmt))

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_OR_DOCUMENTATION.=<u>Or</u>

<b>Formato:</b>
or rd, rs, rt

|SPECIAL     rs      rt     rd      0        OR   |
|000000                                    100101 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
GPR[rd] <- GPR[rs] or GPR[rt]

Realiza la operación lógica OR usando los valores dentro de los registros <i>rs</i> y <i>rt</i>.
El resultado es asignado al registro <i>rd</i>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
GPR[rd] <- GPR[rs] or GPR[rt]

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_ORI_DOCUMENTATION.=<u>Or con inmediato</u>

<b>Formato:</b>
ori rt, rs, inmediato

| ORI       rs     rt     inmediato |
|001101                             |
|  6        5      5         16     |


<b>Descripción:</b>
GPR[rt] <- GPR[rs] or zero_extend(inmediato)

El <i>inmediato</i> de 16 bits es extendido a la izquierda con ceros y combinado con el valor del registro <i>rs</i> usando la operación lógica OR.
El resultado es asignado al registro <i>rt</i>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
GPR[rt] <- GPR[rs] or zero_extend(immediate)

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_SB_DOCUMENTATION.=<u>Guardar byte</u>

<b>Formato:</b>
sb rt desplazamiento(base)

|  SB      base     rt    desplazamiento |
|101000                                  |
|  6        5       5           16       |


<b>Descripción:</b>
memory[GPR[base] + desplazamiento] <- GPR[rt]

Los 8 bits menos significantes del registro <i>rt</i> son guardados en la dirección de memoria efectiva.
El contenido de la celda <i>desplazamiento</i> es sumado al contenido del registro <i>base</i> para formar la dirección efectiva.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
v_addr <- sign_extend(desplazamiento) + GPR[base]
(p_addr, cca) <- AddressTranslation(v_addr, DATA, LOAD)

byte_sel <- v_addr<sub>1..0</sub> xor BigEndianCPU<sub>2</sub>
data_byte <- GPR[rt]<sub>31 - 8 * byte_sel .. 0</sub> || 0<sub>8 * bytesel</sub>
StoreMemory (CCA, BYTE, data_byte, p_addr, v_addr, DATA)

<b>Excepciones:</b>
Address Error
\END

INSTRUCTION_SLL_DOCUMENTATION.=<u>Desplazar a la izquierda de manera lógica</u>

<b>Formato:</b>
sll rd, rt, sa

|SPECIAL     0      rt     rd      sa      SLL   |
|000000                                   000000 |
|  6         5      5      5       5        6    |


<b>Descripción:</b>
GPR[rd] <- GPR[rt] << sa

El contenido del registro <i>rt</i> es desplazado a la izquierda, rellenando con ceros los bits vacíos. El resultado es asignado al registro <i>rd</i>. El número de bits desplazado viene especificado por <i>sa</i>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
GPR[rd] <- GPR[rt]<sub>31-sa..0</sub> || 0<sub>sa</sub>

<b>Excepciones:</b>
Ninguna

<b>Programming Notes:</b>
<black>sll $zero, $zero, 0</black>, expresado como <black>NOP</black>, es el alias usado para expresar una operación nula.
\END

INSTRUCTION_SLLV_DOCUMENTATION.=<u>Desplazar a la izquierda de manera lógica dependiendo de una variable</u>

<b>Formato:</b>
sllv rd, rt, rs

|SPECIAL     rs     rt     rd     0      SLLV  |
|000000                                 000100 |
|  6         5      5      5      5       6    |


<b>Descripción:</b>
GPR[rd] <- GPR[rt] << GPR[rs]

El contenido del registro <i>rt</i> es desplazado a la izquierda, rellenando con ceros los bits vacíos. El resultado es asignado al registro <i>rd</i>. El número de bits desplazado viene especificado por los 5 bits menos significantes del registro <i>sa</i>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
sa <- GPR[rs]<sub>4..0</sub>
GPR[rd] <- GPR[rt]<sub>31-sa..0</sub> || 0<sub>sa</sub>

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_SLT_DOCUMENTATION.=<u>Asignar si menor que valor</u>

<b>Formato:</b>
slt rd, rt, rs

|SPECIAL     rs     rt     rd     0      SLT   |
|000000                                 101010 |
|  6         5      5      5      5       6    |


<b>Descripción:</b>
GPR[rd] <- (GPR[rs] < GPR[rt])

Compara el contenido de los registros <i>rs</i> y <i>rt</i> como enteros con signo; guarda el resultado booleano de la comparación en el registro <i>rd</i>.
Si el contenido de <i>rs</i> es menor que el contenido de <i>rt</i>, el resultado es 1 (true); si no, el resultado es 0 (false).

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
if GPR[rs] < GPR[rt] then
    GPR[rd] <- 0<sub>31..0</sub> || 1
else
    GPR[rd] <- 0
endif

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_SLTI_DOCUMENTATION.=<u>Asignar si menor que inmediato</u>

<b>Formato:</b>
slti rt, rs, inmediato

| SLTI       rs     rt     inmediato |
|001010                              |
|  6         5      5         16     |


<b>Descripción:</b>
GPR[rd] <- (GPR[rs] < sign_extend(inmediato))

Compara el contenido del registro <i>rs</i> y la celda <i>inmediato</i> como enteros con signo; guarda el resultado booleano de la comparación en el registro <i>rd</i>.
Si el contenido de <i>rs</i> es menor que el contenido de <i>inmediato</i>, el resultado es 1 (true); si no, el resultado es 0 (false).

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
if GPR[rs] < sign_extend(immediate) then
    GPR[rd] <- 0<sub>31..0</sub> || 1
else
    GPR[rd] <- 0
endif

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_SLTIU_DOCUMENTATION.=<u>Asignar si menor que inmediato sin signo</u>

<b>Formato:</b>
sltiu rt, rs, inmediato

| SLTIU      rs     rt     inmediato |
|001011                              |
|  6         5      5         16     |


<b>Descripción:</b>
GPR[rd] <- (GPR[rs] < sign_extend(inmediato))

Compara el contenido del registro <i>rs</i> y la celda <i>inmediato</i> como enteros sin signo; guarda el resultado booleano de la comparación en el registro <i>rd</i>.
Si el contenido de <i>rs</i> es menor que el contenido de <i>inmediato</i>, el resultado es 1 (true); si no, el resultado es 0 (false).

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
if (0 || GPR[rs]) < (0 || sign_extend(inmediato)) then
    GPR[rd] <- 0<sub>31..0</sub> || 1
else
    GPR[rd] <- 0
endif

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_SLTU_DOCUMENTATION.=<u>Asignar si menor que valor sin signo</u>

<b>Formato:</b>
sltu rd, rt, rs

|SPECIAL     rs     rt     rd     0      SLTU  |
|000000                                 101011 |
|  6         5      5      5      5       6    |


<b>Descripción:</b>
GPR[rd] <- (GPR[rs] < GPR[rt])

Compara el contenido de los registros <i>rs</i> y <i>rt</i> como enteros sin signo; guarda el resultado booleano de la comparación en el registro <i>rd</i>.
Si el contenido de <i>rs</i> es menor que el contenido de <i>rt</i>, el resultado es 1 (true); si no, el resultado es 0 (false).

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
if (0 || GPR[rs]) < (0 || GPR[rt]) then
    GPR[rd] <- 0<sub>31..0</sub> || 1
else
    GPR[rd] <- 0
endif

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_SRL_DOCUMENTATION.=<u>Desplazar a la derecha de manera lógica</u>

<b>Formato:</b>
srl rd, rt, sa

|SPECIAL    0    R    rt    rd     sa     SLL   |
|000000          0                       000000 |
|  6        4    1    5     5      5       6    |


<b>Descripción:</b>
GPR[rd] <- GPR[rt] << sa

El contenido del registro <i>rt</i> es desplazado a la derecha, rellenando con ceros los bits vacíos. El resultado es asignado al registro <i>rd</i>. El número de bits desplazado viene especificado por <i>sa</i>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
GPR[rd] <- 0<sub>sa</sub> || GPR[rt]<sub>31..sa</sub>

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_SRLV_DOCUMENTATION.=<u>Desplazar a la derecha de manera lógica dependiendo de una variable</u>

<b>Formato:</b>
srlv rd, rt, rs

|SPECIAL     rs     rt     rd     0      SRLV  |
|000000                                 000110 |
|  6         5      5      5      5       6    |


<b>Descripción:</b>
GPR[rd] <- GPR[rt] >> GPR[rs]

El contenido del registro <i>rt</i> es desplazado a la derecha, rellenando con ceros los bits vacíos. El resultado es asignado al registro <i>rd</i>. El número de bits desplazado viene especificado por los 5 bits menos significantes del registro <i>sa</i>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
sa <- GPR[rs]<sub>4..0</sub>
GPR[rd] <- 0<sub>sa</sub> || GPR[rt]<sub>31..sa</sub>

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_SUB_DOCUMENTATION.=<u>Resta</u>

<b>Formato:</b>
sub rd, rs, rt

|SPECIAL     rs      rt     rd      0       SUB   |
|000000                                    100010 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
GPR[rd] <- GPR[rs] - GPR[rt]

La palabra de 32 bits del registro <i>rt</i> es restada a la palabra de 32 bits del registro <i>rs</i> para producir un resultado de 32 bits.
 - Si la resta resulta en un desbordamiento aritmético en complemento a 2 de 32 bits, el registro destino no es modificado y la excepción <black>Integer Overflow</black> es lanzada.
 - Si la resta no produce un desbordamiento, el resultado es insertado en el registro GPR <i>rd</i>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
temp <- (GPR[rs]<sub>31</sub> || GPR[rs]<sub>31..0</sub>) - (GPR[rt]<sub>31</sub> || GPR[rt]<sub>31..0</sub>)
if temp<sub>32</sub> != temp<sub>31</sub> then
    SignalException(IntegerOverflow)
else
    GPR[rd] <- temp<sub>31..0</sub>
endif

<b>Excepciones:</b>
Integer Overflow

<b>Notas del programador:</b>
<black>subu</black> ejecuta la misma operación aritmética pero no lanza una excepción al desbordar.
\END

INSTRUCTION_SUB_D_DOCUMENTATION.=<u>Resta en coma flotante de precisión doble</u>

<b>Formato:</b>
sub.d fd, fs, ft

| COP1      fmt      0      fs      fd      SUB   |
|010001    10001   00000                   000001 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
FPR[fd] <- FRP[fs] - FPR[ft]

El valor en el registro <i>ft</i> es restado al valor en el registro <i>fs</i>. El resultado es calculado en precisión infinita, usando el redondeo proporcionado por <i>Java</i>, y asignado al registro <i>fd</i>.
Los operando y el resultado son valores en coma flotante de precisión doble.

<b>Restricciones:</b>
Los registros <i>fs</i>, <i>ft</i> y <i>fd</i> deben ser FPRs pares. Si los registros no son válidos, el resultado es <black>IMPREDECIBLE</black>.
El operando debe ser un valor en coma flotante de precisión doble. Si no lo es, el resultado es <black>IMPREDECIBLE</black>.

<b>Operación:</b>
fmt <- double
StoreFPR(fd, fmt, ValueFPR(fs, fmt) -<sub>fmt</sub> ValueFPR(ft, fmt))

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_SUB_S_DOCUMENTATION.=<u>Resta en coma flotante</u>

<b>Formato:</b>
sub.s fd, fs, ft

| COP1      fmt      0      fs      fd      SUB   |
|010001    10000   00000                   000001 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
FPR[fd] <- FRP[fs] - FPR[ft]

El valor en el registro <i>ft</i> es restado al valor en el registro <i>fs</i>. El resultado es calculado en precisión infinita, usando el redondeo proporcionado por <i>Java</i>, y asignado al registro <i>fd</i>.
Los operando y el resultado son valores en coma flotante.

<b>Restricciones:</b>
El operando debe ser un valor en coma flotante. Si no lo es, el resultado es <black>IMPREDECIBLE</black>.

<b>Operación:</b>
fmt <- float
StoreFPR(fd, fmt, ValueFPR(fs, fmt) -<sub>fmt</sub> ValueFPR(ft, fmt))

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_SUBU_DOCUMENTATION.=<u>Resta sin signo</u>

<b>Formato:</b>
subu rd, rs, rt

|SPECIAL     rs      rt     rd      0       SUBU  |
|000000                                    100011 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
GPR[rd] <- GPR[rs] - GPR[rt]

La palabra de 32 bits del registro <i>rt</i> es restada a la palabra de 32 bits del registro <i>rs</i> para producir un resultado de 32 bits.
El resultado es asignado al registro <i>rd</i>.
Ninguna excepción de desbordamiento ocurre en ninguna de las circunstancias.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
temp <- GPR[rs] - GPR[rt]
GPR[rd] <- temp

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>
El término <i>sin signo</i> en esta instrucción es parcialmente incorrecto; esta instrucción ejecuta una operación aritmética de 32 bits que no lanza una excepción al desbordar. Esta instrucción es apropiada para aritmética sin signo, o entornos aritméticos que ignoran el desbordamiento, como puede ser la aritmética del lenguaje C.
\END

INSTRUCTION_SW_DOCUMENTATION.=<u>Guardar palabra</u>

<b>Formato:</b>
sw rt desplazamiento(base)

|  SW      base     rt    desplazamiento |
|101011                                  |
|  6        5       5           16       |


<b>Descripción:</b>
memory[GPR[base] + desplazamiento] <- GPR[rt]

La palabra del registro <i>rt</i> es guardada en la dirección de memoria efectiva.
El contenido de la celda <i>desplazamiento</i> es sumado al contenido del registro <i>base</i> para formar la dirección efectiva.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
v_addr <- sign_extend(desplazamiento) + GPR[base]
(p_addr, cca) <- AddressTranslation(v_addr, DATA, LOAD)

word <- GPR[rt]
StoreMemory (CCA, WORD, word, p_addr, v_addr, DATA)

<b>Excepciones:</b>
Address Error
\END

INSTRUCTION_SYSCALL_DOCUMENTATION.=<u>Llamada al sistema</u>

<b>Formato:</b>
syscall

|SPECIAL     0     SYSCALL |
| 00000            001100  |
|   6        20      6     |


<b>Descripción:</b>
<b>Descripción:</b>
Llamada al sistema

Una excepción System Call es lanzada, transfiriendo el control al manejador de excepciones de manera inmediata e incondicional.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
SignalException(SystemCall)

<b>Excepciones:</b>
System Call
\END

INSTRUCTION_TEQ_DOCUMENTATION.=<u>Interrupción si es igual</u>

<b>Formato:</b>
teq rs, rt

|SPECIAL     rs      rt      0         TEQ   |
|000000                               110100 |
|  6         5       5       10         6    |


<b>Descripción:</b>
if GPR[rs] = GPR[rt] then Trap

Compara el contenido de los registros <i>rs</i> y <i>rt</i> como enteros con signo. Si ambos valores son iguales, lanza una excepción <black>Trap</black>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
if GPR[rs] = GPR[rt] then
    SignalException(Trap)
endif

<b>Excepciones:</b>
Trap
\END

INSTRUCTION_TEQI_DOCUMENTATION.=<u>Interrupción si es igual a inmediato</u>

<b>Formato:</b>
teqi rs, inmediato

|REGIMM      rs     TEQI     inmediato |
|000001            01100               |
|  6         5       5          16     |


<b>Descripción:</b>
if GPR[rs] = immediate then Trap

Compara el contenido del registro <i>rs</i> e <i>inmediato</i> como enteros con signo. Si ambos valores son iguales, lanza una excepción <black>Trap</black>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
if GPR[rs] = immediate then
    SignalException(Trap)
endif

<b>Excepciones:</b>
Trap
\END

INSTRUCTION_TGE_DOCUMENTATION.=<u>Interrupción si es mayor o igual</u>

<b>Formato:</b>
tge rs, rt

|SPECIAL     rs      rt      0         TGE   |
|000000                               110000 |
|  6         5       5       10         6    |


<b>Descripción:</b>
if GPR[rs] >= GPR[rt] then Trap

Compara el contenido de los registros <i>rs</i> y <i>rt</i> como enteros con signo.
Si el primer valor es mayor o igual que el segundo valor, lanza una excepción <black>Trap</black>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
if GPR[rs] >= GPR[rt] then
    SignalException(Trap)
endif

<b>Excepciones:</b>
Trap
\END

INSTRUCTION_TGEI_DOCUMENTATION.=<u>Interrupción si es mayor o igual que inmediato</u>

<b>Formato:</b>
tgei rs, inmediato

|REGIMM      rs     TGEI     inmediato |
|000001            01000               |
|  6         5       5          16     |


<b>Descripción:</b>
if GPR[rs] >= inmediato then Trap

Compara el contenido del registro <i>rs</i> e <i>inmediato</i> como enteros con signo.
Si el primer valor es mayor o igual que el segundo valor, lanza una excepción <black>Trap</black>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
if GPR[rs] >= inmediato then
    SignalException(Trap)
endif

<b>Excepciones:</b>
Trap
\END

INSTRUCTION_TGEIU_DOCUMENTATION.=<u>Interrupción si es mayor o igual que inmediato sin signo</u>

<b>Formato:</b>
tgeiu rs, inmediato

|REGIMM     rs     TGEIU     inmediato |
|000001            01001               |
|  6         5       5          16     |


<b>Descripción:</b>
if GPR[rs] >= inmediato then Trap

Compara el contenido del registro <i>rs</i> e <i>inmediato</i> como enteros sin signo.
Si el primer valor es mayor o igual que el segundo valor, lanza una excepción <black>Trap</black>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
if unsigned_word(GPR[rs]) >= unsigned_word(inmediato) then
    SignalException(Trap)
endif

<b>Excepciones:</b>
Trap
\END

INSTRUCTION_TGEU_DOCUMENTATION.=<u>Interrupción si es mayor o igual sin signo</u>

<b>Formato:</b>
tgeu rs, rt

|SPECIAL     rs      rt      0         TGEU  |
|000000                               110001 |
|  6         5       5       10         6    |


<b>Descripción:</b>
if GPR[rs] >= GPR[rt] then Trap

Compara el contenido de los registros <i>rs</i> y <i>rt</i> como enteros sin signo.
Si el primer valor es mayor o igual que el segundo valor, lanza una excepción <black>Trap</black>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
if unsigned_word(GPR[rs]) >= unsigned_word(GPR[rt]) then
    SignalException(Trap)
endif

<b>Excepciones:</b>
Trap
\END

INSTRUCTION_TLT_DOCUMENTATION.=<u>Interrupción si es menor</u>

<b>Formato:</b>
tlt rs, rt

|SPECIAL     rs      rt      0         TLT   |
|000000                               110010 |
|  6         5       5       10         6    |


<b>Descripción:</b>
if GPR[rs] < GPR[rt] then Trap

Compara el contenido de los registros <i>rs</i> y <i>rt</i> como enteros con signo.
Si el primer valor es menor que el segundo valor, lanza una excepción <black>Trap</black>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
if GPR[rs] < GPR[rt] then
    SignalException(Trap)
endif

<b>Excepciones:</b>
Trap
\END

INSTRUCTION_TLTI_DOCUMENTATION.=<u>Interrupción si es menor que inmediato</u>

<b>Formato:</b>
tlti rs, inmediato

|REGIMM      rs     TLTI     inmediato |
|000001            01010               |
|  6         5       5          16     |


<b>Descripción:</b>
if GPR[rs] < inmediato then Trap

Compara el contenido del registro <i>rs</i> e <i>inmediato</i> como enteros con signo.
Si el primer valor es menor que el segundo valor, lanza una excepción <black>Trap</black>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
if GPR[rs] < inmediato then
    SignalException(Trap)
endif

<b>Excepciones:</b>
Trap
\END

INSTRUCTION_TLTIU_DOCUMENTATION.=<u>Interrupción si es menor que inmediato sin signo</u>

<b>Formato:</b>
tltiu rs, inmediato

|REGIMM     rs     TLTIU     inmediato |
|000001            01011               |
|  6         5       5          16     |


<b>Descripción:</b>
if GPR[rs] < inmediato then Trap

Compara el contenido del registro <i>rs</i> e <i>inmediato</i> como enteros sin signo.
Si el primer valor es menor que el segundo valor, lanza una excepción <black>Trap</black>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
if unsigned_word(GPR[rs]) < unsigned_word(inmediato) then
    SignalException(Trap)
endif

<b>Excepciones:</b>
Trap
\END

INSTRUCTION_TLTU_DOCUMENTATION.=<u>Interrupción si es menor sin signo</u>

<b>Formato:</b>
tltu rs, rt

|SPECIAL     rs      rt      0         TLTU  |
|000000                               110011 |
|  6         5       5       10         6    |


<b>Descripción:</b>
if GPR[rs] < GPR[rt] then Trap

Compara el contenido de los registros <i>rs</i> y <i>rt</i> como enteros sin signo.
Si el primer valor es menor que el segundo valor, lanza una excepción <black>Trap</black>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
if unsigned_word(GPR[rs]) < unsigned_word(GPR[rt]) then
    SignalException(Trap)
endif

<b>Excepciones:</b>
Trap
\END

INSTRUCTION_TNE_DOCUMENTATION.=<u>Interrupción si no es igual</u>

<b>Formato:</b>
tne rs, rt

|SPECIAL     rs      rt      0         TNE   |
|000000                               110110 |
|  6         5       5       10         6    |


<b>Descripción:</b>
if GPR[rs] != GPR[rt] then Trap

Compara el contenido de los registros <i>rs</i> y <i>rt</i> como enteros con signo. Si ambos valores no son iguales, lanza una excepción <black>Trap</black>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
if GPR[rs] != GPR[rt] then
    SignalException(Trap)
endif

<b>Excepciones:</b>
Trap
\END

INSTRUCTION_TNEI_DOCUMENTATION.=<u>Interrupción si no es igual a inmediato</u>

<b>Formato:</b>
tnei rs, inmediato

|REGIMM      rs     TNEI     immediate |
|000001            01110               |
|  6         5       5          16     |


<b>Descripción:</b>
if GPR[rs] != immediate then Trap

Compara el contenido del registro <i>rs</i> e <i>inmediato</i> como enteros con signo. Si ambos valores no son iguales, lanza una excepción <black>Trap</black>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
if GPR[rs] != immediate then
    SignalException(Trap)
endif

<b>Excepciones:</b>
Trap
\END

INSTRUCTION_XOR_DOCUMENTATION.=<u>Xor</u>

<b>Formato:</b>
xor rd, rs, rt

|SPECIAL     rs      rt     rd      0       XOR   |
|000000                                    100110 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
GPR[rd] <- GPR[rs] xor GPR[rt]

Realiza la operación lógica XOR usando los valores dentro de los registros <i>rs</i> y <i>rt</i>.
El resultado es asignado al registro <i>rd</i>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
GPR[rd] <- GPR[rs] xor GPR[rt]

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_XORI_DOCUMENTATION.=<u>Xor con inmediato</u>

<b>Formato:</b>
xori rt, rs, inmediato

| XORI      rs     rt     inmediato |
|001110                             |
|  6        5      5         16     |


<b>Descripción:</b>
GPR[rt] <- GPR[rs] or zero_extend(inmediato)

El <i>inmediato</i> de 16 bits es extendido a la izquierda con ceros y combinado con el valor del registro <i>rs</i> usando la operación lógica XOR.
El resultado es asignado al registro <i>rt</i>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
GPR[rt] <- GPR[rs] xor zero_extend(immediate)

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_ADDI_DOCUMENTATION.=<u>Suma con inmediato con desbordamiento</u>

<b>Formato:</b>
addi rt, rs, inmediato

<b>Conversión:</b>
addiu $at, $zero, inmediato
add rt, $at, rs

<b>Descripción:</b>
GPR[rt] <- GPR[rs] + inmediato
La palabra de 32 bits del <i>inmediato</i> es sumada a la palabra de 32 bits del registro <i>rs</i> para producir un resultado de 32 bits.
 - Si la suma resulta en un desbordamiento aritmético en complemento a 2 de 32 bits, el registro destino no es modificado y la excepción <black>Integer Overflow</black> es lanzada.
 - Si la suma no produce un desbordamiento, el resultado es insertado en el registro <i>rt</i>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
temp <- (GPR[rs]<sub>31</sub> || GPR[rs]<sub>31..0</sub>) + (inmediato<sub>31</sub> || inmediato<sub>31..0</sub>)
if temp<sub>32</sub> != temp<sub>31</sub> then
    SignalException(IntegerOverflow)
else
    GPR[rt] <- temp<sub>31..0</sub>
endif

<b>Excepciones:</b>
Integer Overflow

<b>Notas del programador:</b>
<black>addiu</black> ejecuta la misma operación aritmética pero no lanza una excepción al desbordar.
\END

INSTRUCTION_B_DOCUMENTATION.=<u>Ramificación incondicional</u>

<b>Formato:</b>
b desplazamiento

<b>Conversión:</b>
beq $zero, $zero, desplazamiento

<b>Descripción:</b>
Un desplazamiento de 18 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción para formar una dirección efectiva.
La instrucción ejecuta la ramificación a la dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>
Con el desplazamiento de 18 bits, el rango de la ramificación es de  ±128KBytes. Usa el salto (<black>j</black>) o el salto a registro (<black>jr</black>) para ramificar a direcciones fuera de este rango.
<black>beq $zero, $zero, desplazamiento</black>, expresado como <black>b desplazamiento</black>, es el equivalente en ensablador para denotar un salto incondicional.
\END

INSTRUCTION_JR_DOCUMENTATION.=<u>Salto a registro</u>

<b>Formato:</b>
jr rs

<b>Conversión:</b>
jr $zero, rs

<b>Descripción:</b>
Salta a la dirección efectiva guardada en el registro <i>rs</i>. Si la dirección efectiva no está alineada a 4 bytes, una excepción Address Error es lanzada cuando los datos de la instrucción son recogidos.
Si los huecos de retardo están habilitados, esta instrucción también ejecuta la instrucción que le sigue antes de realizar el salto.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_LA_DOCUMENTATION.=<u>Cargar dirección</u>

<b>Formato:</b>
la rs, etiqueta

<b>Conversión:</b>
address <- get_address(etiqueta)
aui $at, $zero, address<sub>31..16</sub>
ori rs, $at, address<sub>15..0</sub>

<b>Descripción:</b>
Carga la dirección de la <i>etiqueta</i> en el registro <i>rs</i>.

<b>Restricciones:</b>
Ninguna

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_LI_DOCUMENTATION.=<u>Cargar inmediato</u>

<b>Formato:</b>
li rs, número

<b>Conversión:</b>
if número<sub>31..16</sub> = 0
    addiu rs, $zero, número<sub>15..0</sub>
else
    aui $at, $zero, número<sub>31..16</sub>
    ori rs, $at, número<sub>15..0</sub>
endif

<b>Descripción:</b>
Carga el <i>número</i> en el registro <i>rs</i>.

<b>Restricciones:</b>
Ninguna

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_LUI_DOCUMENTATION.=<u>Cargar inmediato en los bits más significantes</u>

<b>Formato:</b>
lui rs, número

<b>Conversión:</b>
aui rs, $zero, número<sub>15..0</sub>

<b>Descripción:</b>
Carga el <i>número</i> en los 16 bits más significantes del registro <i>rs</i>.

<b>Restricciones:</b>
Ninguna

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_LIF_DOCUMENTATION.=<u>Cargar inmediato en coma flotante</u>

<b>Formato:</b>
lif fd, float

<b>Conversión:</b>
aui $at, $zero, float<sub>31..16</sub>
ori $at, $at, float<sub>15..0</sub>
mtc1 $at, fd

<b>Descripción:</b>
Carga el <i>float</i> en el registro de coma flotante <i>fd</i>.

<b>Restricciones:</b>
Ninguna

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_MOVE_DOCUMENTATION.=<u>Mover valor</u>

<b>Formato:</b>
move rd, rs

<b>Conversión:</b>
add rd, $zero, rs

<b>Descripción:</b>
GPR[rd] <- GPR[rs]

Mueve el contenido del registro <i>rs</i> al registro <i>rd</i>.

<b>Restricciones:</b>
Ninguna

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_NOP_DOCUMENTATION.=<u>Operación nula</u>

<b>Formato:</b>
nop

<b>Conversión:</b>
sll $zero, $zero, $zero

<b>Descripción:</b>
Operación nula. No hace nada.

<b>Restricciones:</b>
Ninguna

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_SGE_DOCUMENTATION.=<u>Asignar si mayor o igual que valor</u>

<b>Formato:</b>
sge rd, rt, rs

<b>Conversión:</b>
slt rd, rt, rs
ori $at, $zero, 1
subu rd, $at, rd

<b>Descripción:</b>
GPR[rd] <- (GPR[rs] >= GPR[rt])

Compara el contenido de los registros <i>rs</i> y <i>rt</i> como enteros con signo; guarda el resultado booleano de la comparación en el registro <i>rd</i>.
Si el contenido de <i>rs</i> es mayor o igual que el contenido de <i>rt</i>, el resultado es 1 (true); si no, el resultado es 0 (false).

<b>Restricciones:</b>
Ninguna

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_SGEI_DOCUMENTATION.=<u>Asignar si mayor o igual que inmediato</u>

<b>Formato:</b>
sgei rt, rs, immediate

<b>Conversión:</b>
slti rt, rs, immediate
ori $at, $zero, 1
subu rd, $at, rd

<b>Descripción:</b>
GPR[rd] <- (GPR[rs] >= sign_extend(immediate))

Compara el contenido del registro <i>rs</i> y la celda <i>inmediato</i> como enteros con signo; guarda el resultado booleano de la comparación en el registro <i>rd</i>.
Si el contenido de <i>rs</i> es mayor o igual que el contenido de <i>inmediato</i>, el resultado es 1 (true); si no, el resultado es 0 (false).

<b>Restricciones:</b>
Ninguna

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_SGEIU_DOCUMENTATION.=<u>Asignar si mayor o igual que inmediato sin signo</u>

<b>Formato:</b>
sgeiu rt, rs, immediate

<b>Conversión:</b>
sltiu rt, rs, immediate
ori $at, $zero, 1
subu rd, $at, rd

<b>Descripción:</b>
GPR[rd] <- (GPR[rs] >= sign_extend(immediate))

Compara el contenido del registro <i>rs</i> y la celda <i>inmediato</i> como enteros sin signo; guarda el resultado booleano de la comparación en el registro <i>rd</i>.
Si el contenido de <i>rs</i> es mayor o igual que el contenido de <i>inmediato</i>, el resultado es 1 (true); si no, el resultado es 0 (false).

<b>Restricciones:</b>
Ninguna

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_SGEU_DOCUMENTATION.=<u>Asignar si mayor o igual que valor sin signo</u>

<b>Formato:</b>
sgeu rd, rt, rs

<b>Conversión:</b>
sltu rd, rt, rs
ori $at, $zero, 1
subu rd, $at, rd

<b>Descripción:</b>
GPR[rd] <- (GPR[rs] >= GPR[rt])

Compara el contenido de los registros <i>rs</i> y <i>rt</i> como enteros sin signo; guarda el resultado booleano de la comparación en el registro <i>rd</i>.
Si el contenido de <i>rs</i> es mayor o igual que el contenido de <i>rt</i>, el resultado es 1 (true); si no, el resultado es 0 (false).

<b>Restricciones:</b>
Ninguna

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_SGT_DOCUMENTATION.=<u>Asignar si mayor que valor</u>

<b>Formato:</b>
sgt rd, rt, rs

<b>Conversión:</b>
slt rd, rs, rt

<b>Descripción:</b>
GPR[rd] <- (GPR[rs] > GPR[rt])

Compara el contenido de los registros <i>rs</i> y <i>rt</i> como enteros con signo; guarda el resultado booleano de la comparación en el registro <i>rd</i>.
Si el contenido de <i>rs</i> es mayor que el contenido de <i>rt</i>, el resultado es 1 (true); si no, el resultado es 0 (false).

<b>Restricciones:</b>
Ninguna

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_SGTI_DOCUMENTATION.=<u>Asignar si mayor que inmediato</u>

<b>Formato:</b>
sgti rt, rs, immediate

<b>Conversión:</b>
addiu $at, $zero, immediate
slt rd, $at, rs

<b>Descripción:</b>
GPR[rd] <- (GPR[rs] > sign_extend(immediate))

Compara el contenido del registro <i>rs</i> y la celda <i>inmediato</i> como enteros con signo; guarda el resultado booleano de la comparación en el registro <i>rd</i>.
Si el contenido de <i>rs</i> es mayor que el contenido de <i>inmediato</i>, el resultado es 1 (true); si no, el resultado es 0 (false).

<b>Restricciones:</b>
Ninguna

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_SGTIU_DOCUMENTATION.=<u>Asignar si mayor que inmediato sin signo</u>

<b>Formato:</b>
sgtiu rt, rs, immediate

<b>Conversión:</b>
addiu $at, $zero, immediate
sltu rd, $at, rs

<b>Descripción:</b>
GPR[rd] <- (GPR[rs] > sign_extend(immediate))

Compara el contenido del registro <i>rs</i> y la celda <i>inmediato</i> como enteros sin signo; guarda el resultado booleano de la comparación en el registro <i>rd</i>.
Si el contenido de <i>rs</i> es mayor que el contenido de <i>inmediato</i>, el resultado es 1 (true); si no, el resultado es 0 (false).

<b>Restricciones:</b>
Ninguna

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_SGTU_DOCUMENTATION.=<u>Asignar si mayor que valor sin signo</u>

<b>Formato:</b>
sgtu rd, rt, rs

<b>Conversión:</b>
sltu rd, rs, rt

<b>Descripción:</b>
GPR[rd] <- (GPR[rs] > GPR[rt])

Compara el contenido de los registros <i>rs</i> y <i>rt</i> como enteros sin signo; guarda el resultado booleano de la comparación en el registro <i>rd</i>.
Si el contenido de <i>rs</i> es mayor que el contenido de <i>rt</i>, el resultado es 1 (true); si no, el resultado es 0 (false).

<b>Restricciones:</b>
Ninguna

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_SLE_DOCUMENTATION.=<u>Asignar si menor o igual que valor</u>

<b>Formato:</b>
sle rd, rt, rs

<b>Conversión:</b>
slt rd, rs, rt
ori $at, $zero, 1
subu rd, $at, rd

<b>Descripción:</b>
GPR[rd] <- (GPR[rs] <= GPR[rt])

Compara el contenido de los registros <i>rs</i> y <i>rt</i> como enteros con signo; guarda el resultado booleano de la comparación en el registro <i>rd</i>.
Si el contenido de <i>rs</i> es menor o igual que el contenido de <i>rt</i>, el resultado es 1 (true); si no, el resultado es 0 (false).

<b>Restricciones:</b>
Ninguna

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_SLEI_DOCUMENTATION.=<u>Asignar si menor o igual que inmediato</u>

<b>Formato:</b>
slei rt, rs, immediate

<b>Conversión:</b>
addiu $at, $zero, immediate
slt rd, $at, rs
ori $at, $zero, 1
subu rd, $at, rd

<b>Descripción:</b>
GPR[rd] <- (GPR[rs] <= sign_extend(immediate))

Compara el contenido del registro <i>rs</i> y la celda <i>inmediato</i> como enteros con signo; guarda el resultado booleano de la comparación en el registro <i>rd</i>.
Si el contenido de <i>rs</i> es mayor o igual que el contenido de <i>inmediato</i>, el resultado es 1 (true); si no, el resultado es 0 (false).

<b>Restricciones:</b>
Ninguna

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_SLEIU_DOCUMENTATION.=<u>Asignar si menor o igual que inmediato sin signo</u>

<b>Formato:</b>
sleiu rt, rs, immediate

<b>Conversión:</b>
addiu $at, $zero, immediate
sltu rd, $at, rs
ori $at, $zero, 1
subu rd, $at, rd

<b>Descripción:</b>
GPR[rd] <- (GPR[rs] <= sign_extend(immediate))

Compara el contenido del registro <i>rs</i> y la celda <i>inmediato</i> como enteros sin signo; guarda el resultado booleano de la comparación en el registro <i>rd</i>.
Si el contenido de <i>rs</i> es menor o igual que el contenido de <i>inmediato</i>, el resultado es 1 (true); si no, el resultado es 0 (false).

<b>Restricciones:</b>
Ninguna

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_SLEU_DOCUMENTATION.=<u>Asignar si menor o igual que valor sin signo</u>

<b>Formato:</b>
sleu rd, rt, rs

<b>Conversión:</b>
sltu rd, rs, rt
ori $at, $zero, 1
subu rd, $at, rd

<b>Descripción:</b>
GPR[rd] <- (GPR[rs] <= GPR[rt])

Compara el contenido de los registros <i>rs</i> y <i>rt</i> como enteros sin signo; guarda el resultado booleano de la comparación en el registro <i>rd</i>.
Si el contenido de <i>rs</i> es menor o igual que el contenido de <i>rt</i>, el resultado es 1 (true); si no, el resultado es 0 (false).

<b>Restricciones:</b>
Ninguna

<b>Excepciones:</b>
Ninguna
\END

DIRECTIVE_ALIGN_DOCUMENTATION.=<u>Alinear</u>

<b>Formato:</b>
.align <0-3>

<b>Descripción:</b>
Alinea la siguiente inserción de memoria a una dirección múltiplo de 2^n.

\END

DIRECTIVE_ASCII_DOCUMENTATION.=<u>Insertar cadenas de caracteres ASCII</u>

<b>Formato:</b>
.ascii {"Texto"}

<b>Descripción:</b>
Inserta en la memoria las cadenas de caracteres en formato ASCII dados.

\END

DIRECTIVE_ASCIIZ_DOCUMENTATION.=<u>Insertar cadenas de caracteres ASCII, terminando con el caracter nulo</u>

<b>Formato:</b>
.asciiz {"Texto"}

<b>Descripción:</b>
Inserta en la memoria las cadenas de caracteres en formato ASCII dados, terminando cada una de ellas con el caracter nulo (\0).

\END

DIRECTIVE_BYTE_DOCUMENTATION.=<u>Insertar byte</u>

<b>Formato:</b>
.byte {byte | 'caracter'}

<b>Descripción:</b>
Inserta en la memoria los bytes dados.

\END

DIRECTIVE_DATA_DOCUMENTATION.=<u>Cambiar a la sección de datos</u>

<b>Formato:</b>
.data [dirección]

<b>Descripción:</b>
Hace que las siguientes inserciones de memoria sean colocadas en la sección de datos.
Si una dirección es dada, las siguientes inserciones de memoria serán colocadas empezando por dicha dirección.

\END

DIRECTIVE_DOUBLE_DOCUMENTATION.=<u>Insertar doubles</u>

<b>Formato:</b>
.byte {double}

<b>Descripción:</b>
Inserta en la memoria los doubles dados.

\END

DIRECTIVE_DWORD_DOCUMENTATION.=<u>Insertar palabras dobles / longs</u>

<b>Formato:</b>
.dword {dword}

<b>Descripción:</b>
Inserta en la memoria las palabras dobles dadas.

\END

DIRECTIVE_ENDMACRO_DOCUMENTATION.=<u>Terminar macro</u>

<b>Formato:</b>
.endmacro

<b>Descripción:</b>
Termina la definición del macro actual.
Si no hay ningún macro siendo definido esta directiva será ignorada.

\END

DIRECTIVE_EQV_DOCUMENTATION.=<u>Equivalente</u>

<b>Formato:</b>
.eqv <clave> <valor>

<b>Descripción:</b>
Reemplaza la clave en todas las siguientes líneas del archivo por el valor.

<b>Notas del programador:</b>
Evita usar esta directiva para reemplazar textos complejos.
Esta directiva solo debe ser usada para reemplazar registros e inmediatos.

\END

DIRECTIVE_ERR_DOCUMENTATION.=<u>Error</u>

<b>Formato:</b>
.err

<b>Descripción:</b>
Produce un error de ensamblado.

\END

DIRECTIVE_EXTERN_DOCUMENTATION.=<u>Asignar memoria externa</u>

<b>Format:</b>
.extern <etiqueta> <tamaño>

<b>Description:</b>
Reserva el número dado de bytes en la sección externa de la memoria.
La etiqueta creada será considerada una etiqueta global.

\END

DIRECTIVE_FLOAT_DOCUMENTATION.=<u>Insertar comas flotantes</u>

<b>Formato:</b>
.float {float}

<b>Descripción:</b>
Inserta en la memoria los números en coma flotante dados.

\END

DIRECTIVE_GLOBL_DOCUMENTATION.=<u>Marcar como etiqueta global</u>

<b>Formato:</b>
.globl <label>

<b>Descripción:</b>
Marca la etiqueta dada como global.

\END

DIRECTIVE_HALF_DOCUMENTATION.=<u>Insertar medias palabras</u>

<b>Formato:</b>
.half {media palabra}

<b>Descripción:</b>
Inserta en la memoria las medias palabras dadas.

\END

DIRECTIVE_INCLUDE_DOCUMENTATION.=<u>Incluir archivo</u>

<b>Formato:</b>
.include <archivo>

<b>Description:</b>


Reemplaza esta directive por los contenidos del archivo dado.

<b>Programming Notes:</b>
Evita usar esta directiva: puede causar bucles infinitos y hace que el inspector no funcione correctamente.

\END

DIRECTIVE_KDATA_DOCUMENTATION.=<u>Cambiar a la sección de datos del kernel</u>

<b>Formato:</b>
.kdata [dirección]

<b>Descripción:</b>
Hace que las siguientes inserciones de memoria sean colocadas en la sección de datos del kernel.
Si una dirección es dada, las siguientes inserciones de memoria serán colocadas empezando por dicha dirección.

\END

DIRECTIVE_KTEXT_DOCUMENTATION.=<u>Cambiar a la sección de texto del kernel</u>

<b>Formato:</b>
.ktext [dirección]

<b>Descripción:</b>
Hace que las siguientes inserciones de memoria sean colocadas en la sección de texto del kernel.
Si una dirección es dada, las siguientes inserciones de memoria serán colocadas empezando por dicha dirección.

\END

DIRECTIVE_LAB_DOCUMENTATION.=<u>Crear etiqueta</u>

<b>Formato:</b>
.lab <etiqueta>

<b>Descripción:</b>
Crea la etiqueta data.

\END

DIRECTIVE_MACRO_DOCUMENTATION.=<u>Macro</u>

<b>Formato:</b>
.macro <nombre>
.macro <nombre> ()
.macro <nombre> ({%parámetro})

<b>Descripción:</b>
Empieza la definición de un macro.
Un macro puede ser usado para definir un conjunto de instrucciones que se usarán constantemente.
Los macros pueden tener parámetros. Todos los parámetros deben empezar por "%" y serán reemplazados
cuando una llamada al macro es ejecutada.

Una llamada a macro debe terner este formato: nombre (param1, param2). El espacio entre el nombre y el primer paréntesis puede ser reemplazado por una coma o una tabulación.

<b>Ejemplo:</b>

El siguiente código crea una macro que imprime una cadena de caracteres:

	.macro print (%string)
	.data
text:	.asciiz %string
	.text
	la $a0, text
	li $v0, 4
	syscall
	.endmacro
	.text
	print ("Hi!\n")
	print ("I'm using macros!\n")


Salida:

Hi!
I'm using macros!

\END

DIRECTIVE_SPACE_DOCUMENTATION.=<u>Reservar memoria</u>

<b>Formato:</b>
.space <tamaño>

<b>Descripción:</b>
Reserva la cantidad de bytes dada en la memoria.

\END

DIRECTIVE_TEXT_DOCUMENTATION.=<u>Cambiar a la sección de texto</u>

<b>Formato:</b>
.text [dirección]

<b>Descripción:</b>
Hace que las siguientes inserciones de memoria sean colocadas en la sección de texto.
Si una dirección es dada, las siguientes inserciones de memoria serán colocadas empezando por dicha dirección.

\END

DIRECTIVE_WORD_DOCUMENTATION.=<u>Insertar palabras</u>

<b>Formato:</b>
.word {palabra | etiqueta}

<b>Descripción:</b>
Inserta en la memoria las siguientes palabras.
Si una etiqueta es dada, su dirección será insertada.

\END


FLOAT_CONDITION_AF=Siempre falso
FLOAT_CONDITION_UN=Sin orden
FLOAT_CONDITION_EQ=Igual
FLOAT_CONDITION_UEQ=Sin orden o igual
FLOAT_CONDITION_LT=Menor que ordenado
FLOAT_CONDITION_ULT=Desordenado o menor que
FLOAT_CONDITION_LE=Menor o igual ordenado
FLOAT_CONDITION_ULE=Desordenado o menor o igual que
FLOAT_CONDITION_SAF=Siempre falso con señal
FLOAT_CONDITION_SUN=Desordenado con señal
FLOAT_CONDITION_SEQ=Igual ordenado con señal
FLOAT_CONDITION_SUEQ=Desordenado o igual con señal
FLOAT_CONDITION_SLT=Menor que ordenado con señal
FLOAT_CONDITION_SULT=Desordenado o menor que con señal
FLOAT_CONDITION_SLE=Menor o igual ordenado con señal
FLOAT_CONDITION_SULE=Desordenado o menor que o igual con señal
FLOAT_CONDITION_OR=Ordenado
FLOAT_CONDITION_UNE=No igual
FLOAT_CONDITION_NE=No igual ordenado
FLOAT_CONDITION_SOR=Ordenado con señal
FLOAT_CONDITION_SUNE=Desordenado o no igual con señal
FLOAT_CONDITION_SNE=No igual ordenado con señal

FMT_SINGLE=coma flotante
FMT_DOUBLE=coma flotante doble
FMT_WORD=palabra
FMT_LONG=doble palabra

ABOUT=JAMS\nVersión {VERSION}\n\nCopyright 2020-2021\nCreado por Gael Rial Costas