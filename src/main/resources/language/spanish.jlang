Spanish

GENERAL_CONFIRM=Aceptar
GENERAL_OK=Ok
GENERAL_FINISH=Terminar
GENERAL_CANCEL=Cancelar
GENERAL_CONFIRMATION=Confirmación
GENERAL_ADD=Añadir
GENERAL_REMOVE=Eliminar
GENERAL_COPY=Copiar
GENERAL_PASTE=Pegar
GENERAL_SORT=Ordenar

START_TITLE=JAMS
START_SUBTITLE=Versión {VERSION}

MAIN_MENU_FILE=Archivo
MAIN_MENU_EDIT=Editar
MAIN_MENU_MIPS=MIPS
MAIN_MENU_HELP=Ayuda

MAIN_MENU_FILE_EXIT=Salir
MAIN_MENU_FILE_SETTINGS=Configuración
MAIN_MENU_FILE_OPEN_PROJECT=Abrir proyecto
MAIN_MENU_FILE_CREATE_PROJECT=Crear projecto
MAIN_MENU_FILE_CREATE_PROJECT_TITLE=Crear projecto
MAIN_MENU_FILE_CREATE_PROJECT_NAME=Nombre:
MAIN_MENU_FILE_CREATE_PROJECT_PATH=Dirección:

MAIN_MENU_HELP_ABOUT=Acerca de

PROJECT_TAB_STRUCTURE=Estructura del projecto
PROJECT_TAB_SIMULATION=Simulación

BAR_EXPLORER_NAME=Explorador
BAR_FILES_TO_ASSEMBLE_NAME=Archivos a ensamblar
BAR_LOG_NAME=Log

SIMULATION_CONFIGURATION_CONFIGURATIONS=Configuraciones:
SIMULATION_CONFIGURATION_INFO=Ajustes de las configuraciones
SIMULATION_CONFIGURATION_GENERAL=General
SIMULATION_CONFIGURATION_GENERAL_REGION=Datos generales
SIMULATION_CONFIGURATION_NAME=Nombre:
SIMULATION_CONFIGURATION_ARCHITECTURE=Arquitectura:
SIMULATION_CONFIGURATION_ARCHITECTURE_TOOLTIP=La arquitectura que el simulador usará.\n\nAlgunas opciones solo están disponibles en arquitecturas específicas.
SIMULATION_CONFIGURATION_MEMORY=Memoria:
SIMULATION_CONFIGURATION_MEMORY_TOOLTIP=La memoria que el simulador usará.
SIMULATION_CONFIGURATION_CALL_EVENTS=Llamar a eventos de registros, memoria e instrucciones
SIMULATION_CONFIGURATION_CALL_EVENTS_TOOLTIP=Permite al simulador notificar cambios en la memoria, registros e instrucciones.\n\nSi esta opción está deshabilitada, el simulador funcionará más rápido, pero algunas opciones del depurador o de los plugins no funcionarán. Los eventos si funcionarán cuando el simulador esté parado.
SIMULATION_CONFIGURATION_ENABLE_UNDO=Permitir deshacer pasos
SIMULATION_CONFIGURATION_ENABLE_UNDO_TOOLTIP=Permite al usuario deshacer pasos del simulador.\n\nSi esta opción está desactivada, el simulador irá más rápido y consumira menos memoria, pero serás incapaz de deshacer pasos.\n\nEsta opción requiere que los eventos estén activados.
SIMULATION_CONFIGURATION_ENABLE_FORWARDING=Activar adelantamientos
SIMULATION_CONFIGURATION_ENABLE_FORWARDING_TOOLTIP=Permite a las instrucciones adelantar datos en una arquitectura segmentada.
SIMULATION_CONFIGURATION_SOLVE_BRANCH_ON_DECODE=Resolver saltos en la fase de decodificación
SIMULATION_CONFIGURATION_SOLVE_BRANCH_ON_DECODE_TOOLTIP=Permite resolver saltos en la fase de decodificación. Esta opción solo funciona en arquitecturas con varias etapas.
SIMULATION_CONFIGURATION_ENABLE_DELAY_SLOTS=Habilitar salto retardado.
SIMULATION_CONFIGURATION_ENABLE_DELAY_SLOTS_TOOLTIP=Habilita el relleno de ranura.\n\nSi esta opción está habilitada, toda instrucción situada después de una instruction de control no compacta será ejecutada.
SIMULATION_CONFIGURATION_SYSTEM_CALLS_TAB=Llamadas al sistema
SIMULATION_CONFIGURATION_SYSTEM_CALLS_TAB_LOAD_BUNDLE=Cargar conjunto
SIMULATION_CONFIGURATION_SYSTEM_CALLS_TAB_PROPERTIES=Propiedades de la llamada
SIMULATION_CONFIGURATION_CACHES_TAB=Cachés
SIMULATION_CONFIGURATION_CACHES_TAB_PROPERTIES=Propiedades de la caché
SIMULATION_CONFIGURATION_CACHES_TAB_INFO=Información de la caché
SIMULATION_CONFIGURATION_CACHES_TAB_SIZE=Tamaño de la caché:


SYSCALL_RUN_EXCEPTION_HANDLER=X Ejecutar el manejador de excepciones

SYSCALL_PRINT_INTEGER=SPIM 1 Imprimir entero
SYSCALL_PRINT_INTEGER_PROPERTY_PRINT_HEX=Imprimir hexadecimal
SYSCALL_PRINT_INTEGER_PROPERTY_LINE_JUMP=Añadir salto de línea
SYSCALL_PRINT_INTEGER_PROPERTY_REGISTER=Registro

SYSCALL_PRINT_FLOAT=SPIM 2 Imprimir float
SYSCALL_PRINT_FLOAT_PROPERTY_PRINT_HEX=Imprimir hexadecimal
SYSCALL_PRINT_FLOAT_PROPERTY_LINE_JUMP=Añadir salto de línea
SYSCALL_PRINT_FLOAT_PROPERTY_REGISTER=Registro

SYSCALL_PRINT_DOUBLE=SPIM 3 Imprimir double
SYSCALL_PRINT_DOUBLE_PROPERTY_PRINT_HEX=Imprimir hexadecimal
SYSCALL_PRINT_DOUBLE_PROPERTY_LINE_JUMP=Añadir salto de línea
SYSCALL_PRINT_DOUBLE_PROPERTY_REGISTER=Registro

SYSCALL_PRINT_STRING=SPIM 4 Imprimir string
SYSCALL_PRINT_STRING_PROPERTY_LINE_JUMP=Añadir salto de línea
SYSCALL_PRINT_STRING_PROPERTY_MAX_CHARACTERS=Caracteres máximos
SYSCALL_PRINT_STRING_PROPERTY_REGISTER=Registro

SYSCALL_READ_INTEGER=SPIM 5 Leer entero
SYSCALL_READ_INTEGER_PROPERTY_LINE_JUMP=Añadir salto de línea
SYSCALL_READ_INTEGER_PROPERTY_REGISTER=Registro

SYSCALL_READ_FLOAT=SPIM 6 Leer float
SYSCALL_READ_FLOAT_PROPERTY_LINE_JUMP=Añadir salto de línea
SYSCALL_READ_FLOAT_PROPERTY_REGISTER=Registro

SYSCALL_READ_DOUBLE=SPIM 7 Leer double
SYSCALL_READ_DOUBLE_PROPERTY_LINE_JUMP=Añadir salto de línea
SYSCALL_READ_DOUBLE_PROPERTY_REGISTER=Registro

SYSCALL_READ_STRING=SPIM 8 Leer string
SYSCALL_READ_STRING_PROPERTY_LINE_JUMP=Añadir salto de línea
SYSCALL_READ_STRING_PROPERTY_ADDRESS_REGISTER=Registro de dirección
SYSCALL_READ_STRING_PROPERTY_MAX_CHARS_REGISTER=Registro de chars máx.

SYSCALL_ALLOCATE_MEMORY=SPIM 9 Reservar memoria
SYSCALL_ALLOCATE_MEMORY_PROPERTY_AMOUNT_REGISTER=Registro de tamaño
SYSCALL_ALLOCATE_MEMORY_PROPERTY_ADDRESS_REGISTER=Registro de memoria

SYSCALL_EXIT=SPIM 10 Salir

SYSCALL_PRINT_CHARACTER=SPIM 11 Imprimir caracter
SYSCALL_PRINT_CHARACTER_PROPERTY_LINE_JUMP=Añadir salto de línea
SYSCALL_PRINT_CHARACTER_PROPERTY_REGISTER=Registro

SYSCALL_READ_CHARACTER=SPIM 12 Leer caracter
SYSCALL_READ_CHARACTER_PROPERTY_LINE_JUMP=Añadir salto de línea
SYSCALL_READ_CHARACTER_PROPERTY_REGISTER=Registro

SYSCALL_OPEN_FILE=SPIM 13 Abrir archivo
SYSCALL_OPEN_FILE_PROPERTY_NAME_REGISTER=Registro de nombre
SYSCALL_OPEN_FILE_PROPERTY_FLAG_REGISTER=Registro de flag
SYSCALL_OPEN_FILE_PROPERTY_MODE_REGISTER=Registro de modo
SYSCALL_OPEN_FILE_PROPERTY_RESULT_REGISTER=Registro de resultado

SYSCALL_READ_FILE=SPIM 14 Leer de archivo
SYSCALL_READ_FILE_PROPERTY_ID_REGISTER=Registro de id
SYSCALL_READ_FILE_PROPERTY_ADDRESS_REGISTER=Registro de dirección
SYSCALL_READ_FILE_PROPERTY_MAX_BYTES_REGISTER=Registro de bytes máx.
SYSCALL_READ_FILE_PROPERTY_RESULT_REGISTER=Registro de resultado

SYSCALL_WRITE_FILE=SPIM 15 Escribir en archivo
SYSCALL_WRITE_FILE_PROPERTY_ID_REGISTER=Registro de id
SYSCALL_WRITE_FILE_PROPERTY_ADDRESS_REGISTER=Registro de dirección
SYSCALL_WRITE_FILE_PROPERTY_AMOUNT_REGISTER=Registro de cantidad
SYSCALL_WRITE_FILE_PROPERTY_RESULT_REGISTER=Registro de resultado

SYSCALL_CLOSE_FILE=SPIM 16 Cerrar archivo
SYSCALL_CLOSE_FILE_PROPERTY_ID_REGISTER=Registro de id

SYSCALL_EXIT_WITH_VALUE=SPIM 17 Salir con valor
SYSCALL_EXIT_WITH_VALUE_PROPERTY_REGISTER=Registro

SYSCALL_SYSTEM_TIME=MARS 30 Hora del sistema
SYSCALL_SYSTEM_TIME_PROPERTY_LOW_REGISTER=Registro del valor bajo
SYSCALL_SYSTEM_TIME_PROPERTY_HIGH_REGISTER=Registro del valor alto

SYSCALL_SLEEP=MARS 32 Dormir
SYSCALL_SLEEP_PROPERTY_REGISTER=Registro

SYSCALL_PRINT_HEXADECIMAL_INTEGER=MARS 34 Imprimir número hexadecimal
SYSCALL_PRINT_HEXADECIMAL_INTEGER_PROPERTY_LINE_JUMP=Añadir salto de línea
SYSCALL_PRINT_HEXADECIMAL_INTEGER_PROPERTY_REGISTER=Registro

SYSCALL_PRINT_BINARY_INTEGER=MARS 35 Imprimir número binario
SYSCALL_PRINT_BINARY_INTEGER_PROPERTY_LINE_JUMP=Añadir salto de línea
SYSCALL_PRINT_BINARY_INTEGER_PROPERTY_REGISTER=Registro

SYSCALL_PRINT_UNSIGNED_INTEGER=MARS 36 Imprimir número sin signo
SYSCALL_PRINT_UNSIGNED_INTEGER_PROPERTY_LINE_JUMP=Añadir salto de línea
SYSCALL_PRINT_UNSIGNED_INTEGER_PROPERTY_REGISTER=Registro

SYSCALL_SET_SEED=MARS 40 Asignar semilla
SYSCALL_SET_SEED_PROPERTY_GENERATOR_REGISTER=Registro del generador
SYSCALL_SET_SEED_PROPERTY_SEED_REGISTER=Registro de la semilla

SYSCALL_RANDOM_INTEGER=MARS 41 Entero aleatorio
SYSCALL_RANDOM_INTEGER_PROPERTY_GENERATOR_REGISTER=Registro del generador
SYSCALL_RANDOM_INTEGER_PROPERTY_VALUE_REGISTER=Registro del valor

SYSCALL_RANDOM_RANGED_INTEGER=MARS 42 Entero aleatorio con rango
SYSCALL_RANDOM_RANGED_INTEGER_PROPERTY_GENERATOR_REGISTER=Registro del generador
SYSCALL_RANDOM_RANGED_INTEGER_PROPERTY_RANGE_REGISTER=Registro del rango
SYSCALL_RANDOM_RANGED_INTEGER_PROPERTY_VALUE_REGISTER=Registro del valor

SYSCALL_RANDOM_FLOAT=MARS 43 Float aleatorio
SYSCALL_RANDOM_FLOAT_PROPERTY_GENERATOR_REGISTER=Registro del generador
SYSCALL_RANDOM_FLOAT_PROPERTY_VALUE_REGISTER=Registro del valor

SYSCALL_RANDOM_DOUBLE=MARS 44 Double aleatorio
SYSCALL_RANDOM_DOUBLE_PROPERTY_GENERATOR_REGISTER=Registro del generador
SYSCALL_RANDOM_DOUBLE_PROPERTY_VALUE_REGISTER=Registro del valor

CACHE_DIRECT=Correspondencia directa
CACHE_DIRECT_PROPERTY_WRITE_BACK=Modo Write-back
CACHE_DIRECT_PROPERTY_BLOCK_SIZE=Tamaño del bloque (palabras)
CACHE_DIRECT_PROPERTY_BLOCKS_AMOUNT=Bloques

CACHE_ASSOCIATIVE=Asociativa
CACHE_ASSOCIATIVE_PROPERTY_WRITE_BACK=Modo Write-back
CACHE_ASSOCIATIVE_PROPERTY_BLOCK_SIZE=Tamaño del bloque (palabras)
CACHE_ASSOCIATIVE_PROPERTY_BLOCKS_AMOUNT=Bloques
CACHE_ASSOCIATIVE_PROPERTY_REPLACEMENT_POLICY=Política de reemplazamiento

CACHE_SET_ASSOCIATIVE=Asociativa por conjuntos
CACHE_SET_ASSOCIATIVE_PROPERTY_WRITE_BACK=Modo Write-back
CACHE_SET_ASSOCIATIVE_PROPERTY_BLOCK_SIZE=Tamaño del bloque (palabras)
CACHE_SET_ASSOCIATIVE_PROPERTY_BLOCKS_AMOUNT=Bloques
CACHE_SET_ASSOCIATIVE_PROPERTY_SET_SIZE=Tamaño del conjunto
CACHE_SET_ASSOCIATIVE_PROPERTY_REPLACEMENT_POLICY=Política de reemplazamiento

SIMULATION_BUTTON_TOOLTIP_EXECUTE_ALL=Ejecutar todas las instrucciones
SIMULATION_BUTTON_TOOLTIP_STOP=Parar
SIMULATION_BUTTON_TOOLTIP_EXECUTE_ONE=Ejecutar un paso
SIMULATION_BUTTON_TOOLTIP_UNDO=Deshacer un paso
SIMULATION_BUTTON_TOOLTIP_RESET=Reiniciar

BAR_REGISTERS_NAME=Registros
BAR_MEMORY_NAME=Memoria
BAR_FLOW_NAME=Flujo
BAR_CONSOLE_NAME=Consola
BAR_LABELS_NAME=Etiquetas
BAR_CACHES_NAME=Cachés

INSTRUCTIONS_USER=Texto
INSTRUCTIONS_KERNEL=Kernel

INSTRUCTIONS_BREAKPOINT=Brk.
INSTRUCTIONS_ADDRESS=Dirección
INSTRUCTIONS_CODE=Código
INSTRUCTIONS_INSTRUCTION=Instrucción
INSTRUCTIONS_ORIGINAL=Original

REGISTERS_GENERAL=General
REGISTERS_COP0=COP0
REGISTERS_COP1=COP1
REGISTERS_ID=Id
REGISTERS_SELECTION=Sel
REGISTERS_NAME=Nombre
REGISTERS_VALUE=Valor
REGISTERS_HEX=Hex

MEMORY_ADDRESS=Dirección

LABELS_NAME=Nombre
LABELS_ADDRESS=Dirección
LABELS_CONTEXT_SHOW_IN_MEMORY=Mostrar en memoria
LABELS_CONTEXT_SHOW_IN_INSTRUCTION=Mostrar en la tabla de instrucciones

CACHE_HITS=Aciertos
CACHE_MISSES=Fallos
CACHE_STATS=Estadísticas
CACHE_STATS_OPERATIONS=Operaciones:
CACHE_STATS_HITS=Aciertos:
CACHE_STATS_MISSES=Fallos:
CACHE_RESET=Reiniciar cachés
CACHE_LOG=Registro
CACHE_LOG_HIT=Operación {OPERATION}. Acierto.
CACHE_LOG_MISS=Operación {OPERATION}. Fallo.
CACHE_LOG_INDEX=Índice {INDEX} ({TAG})
CACHE_LOG_CLEAR=Borrar registro
CACHE_LOG_CLEAR_ALL=Eliminar registros

CONFIG=Configuración

CONFIG_ACTION=Acciones
CONFIG_ACTION_SEARCH=Buscar...
CONFIG_ACTION_BIND_TITLE=Asignar una combinación a una acción
CONFIG_ACTION_BIND_ENTER=Presiona la combinación de teclas que quieres asignar
CONFIG_ACTION_BIND_CONFIRM=Las siguientes acciones serán desasignadas de la combinación:
CONFIG_ACTION_BIND_CONFIRM_2=¿Quieres continuar?
CONFIG_ACTION_UNBIND=¿Estás seguro de que quieres desasignar esta combinación?

CONFIG_APPEARANCE=Apariencia
CONFIG_APPEARANCE_REGION_THEME=Tema
CONFIG_APPEARANCE_REGION_TWEAKS=Ajustes
CONFIG_APPEARANCE_THEME=Tema:
CONFIG_APPEARANCE_THEME_TOOLTIP=Los temas cambian toda la apariencia de la aplicación.
CONFIG_APPEARANCE_GENERAL_FONT=Fuente general:
CONFIG_APPEARANCE_GENERAL_FONT_TOOLTIP=Esta fuente es usada por todo JAMS salvo en los editores de texto.
CONFIG_APPEARANCE_CODE_FONT=Fuente del editor:
CONFIG_APPEARANCE_CODE_FONT_TOOLTIP=Esta fuente es usada por los editores de texto.
CONFIG_APPEARANCE_HIDE_TOP_BAR=Esconder barra superior\t(Solo para Windows, necesita un reinicio)
CONFIG_APPEARANCE_HIDE_TOP_BAR_TOOLTIP=Esta opción permite integrar la barra superior de la ventana principal en la barra de tareas.
CONFIG_APPEARANCE_ANTIALIASING=Antialiasing\t(Necesita un reinicio)
CONFIG_APPEARANCE_ANTIALIASING_TOOLTIP=Activa el antialiasing en todas las escenas.

CONFIG_EDITOR=Editor
CONFIG_EDITOR_REGION_MOUSE_CONTROL=Controles del ratón
CONFIG_EDITOR_ZOOM_USING_MOUSE_WHEEL=Hacer zoom usando la rueda del ratón mientras está pulsado Shortcut
CONFIG_EDITOR_ZOOM_USING_MOUSE_WHEEL_TOOLTIP=Si esta opción está activada podrás hacer zoom usando la rueda del ratón mientras pulsas la tecla Shortcut.
CONFIG_EDITOR_RESET_ZOOM_USING_MIDDLE_BUTTON=Deshacer el zoom usando Shortcut+Botón central del ratón
CONFIG_EDITOR_RESET_ZOOM_USING_MIDDLE_BUTTON_TOOLTIP=Si esta opción está activada podrás deshacer el zoom usando el botón central del ratón mientras pulsas la tecla Shortcut.

CONFIG_EDITOR_MIPS=MIPS
CONFIG_EDITOR_MIPS_REGION_TABS=Tabuladores
CONFIG_EDITOR_MIPS_REGION_SPACES=Espacios
CONFIG_EDITOR_MIPS_REGION_BLANK_LINES=Líneas vacías
CONFIG_EDITOR_MIPS_USE_TABS=Usar el caracter tabulador
CONFIG_EDITOR_MIPS_USE_TABS_TOOLTIP=Si esta opción esta activada JAMS usará tabuladores en vez de espacios en el editor de código.
CONFIG_EDITOR_MIPS_PRESERVE_TABS=Preservar los tabuladores después de la etiqueta
CONFIG_EDITOR_MIPS_PRESERVE_TABS_TOOLTIP=Esta opción permite preservar los tabuladores extras añadidos por el usuario entre la etiqueta y la instrucción / directiva cuando se formatee el código.
CONFIG_EDITOR_MIPS_PRESERVE_TABS_BEFORE_LABELS=Preservar los tabuladores antes de la etiqueta
CONFIG_EDITOR_MIPS_PRESERVE_TABS_BEFORE_LABELS_TOOLTIP=Esta opción permite preservar los tabuladores extras añadidos por el usuario antes de la etiqueta cuando se formatee el código.
CONFIG_EDITOR_MIPS_SPACE_AFTER_INSTRUCTION=Después de una instrucción:
CONFIG_EDITOR_MIPS_SPACE_AFTER_INSTRUCTION_TOOLTIP=Esta opción le indica a JAMS qué añadir después de una instrucción.
CONFIG_EDITOR_MIPS_SPACE_AFTER_INSTRUCTION_PARAMETER=Después del parámetro de una instrucción:
CONFIG_EDITOR_MIPS_SPACE_AFTER_INSTRUCTION_PARAMETER_TOOLTIP=Esta opción le indica a JAMS qué añadir después de un parámetro de una instrucción.
CONFIG_EDITOR_MIPS_SPACE_AFTER_DIRECTIVE=Después de una directiva:
CONFIG_EDITOR_MIPS_SPACE_AFTER_DIRECTIVE_TOOLTIP=Esta opción le indica a JAMS qué añadir después de una directiva.
CONFIG_EDITOR_MIPS_SPACE_AFTER_DIRECTIVE_PARAMETER=Después del parámetro de una directiva:
CONFIG_EDITOR_MIPS_SPACE_AFTER_DIRECTIVE_PARAMETER_TOOLTIP=Esta opción le indica a JAMS qué añadir después de un parámetro de una directiva.
CONFIG_EDITOR_MIPS_MAXIMUM_BLANK_LINES=Líneas en blanco máximas:
CONFIG_EDITOR_MIPS_MAXIMUM_BLANK_LINES_TOOLTIP=La cantidad de líneas en blanco máximas que JAMS va a dejar al formatear.

CONFIG_EXPLORER=Explorador
CONFIG_EXPLORER_MIPS=MIPS
CONFIG_EXPLORER_REGION_SIZE=Tamaño
CONFIG_EXPLORER_SECTION_SEPARATOR_WIDTH=Ancho por nivel de herencia para secciones
CONFIG_EXPLORER_SECTION_SEPARATOR_WIDTH_TOOLTIP=Esta opción permite editar el ancho que una sección se moverá por cada nivel de herencia.
CONFIG_EXPLORER_ELEMENT_SEPARATOR_WIDTH=Ancho por nivel de herencia para elementos
CONFIG_EXPLORER_ELEMENT_SEPARATOR_WIDTH_TOOLTIP=Esta opción permite editar el ancho que un elemento se moverá por cada nivel de herencia.
CONFIG_EXPLORER_MIPS_REGION_CREATION=Creación
CONFIG_EXPLORER_MIPS_ADD_CREATED_ASM_FILES_TO_ASSEMBLE=Añadir archivos asm a ensamblar automaticamente cuando son creados
CONFIG_EXPLORER_MIPS_ADD_CREATED_ASM_FILES_TO_ASSEMBLE_TOOLTIP=Si esta opción está activada, los archivos ensamblador que se creen serán automáticamente añadidos a la lista de ensamblaje.\n\nEsta opción puede ser cambiada en el menú de creación del archivo.

CONFIG_LANGUAGE=Idioma
CONFIG_LANGUAGE_REGION_LANGUAGE=Idioma
CONFIG_LANGUAGE_DEFAULT=Idioma de respaldo:
CONFIG_LANGUAGE_DEFAULT_TOOLTIP=Este idioma se usará cuando el idioma a usar no tenga el mensaje requerido.\n\nEste idioma es el inglés por defecto.
CONFIG_LANGUAGE_SELECTED=Idioma a usar:
CONFIG_LANGUAGE_SELECTED_TOOLTIP=Este es el idioma que JAMS usará en la interfaz.

CONFIG_SIMULATION=Simulación
CONFIG_SIMULATION_MIPS=MIPS
CONFIG_SIMULATION_REGION_ASSEMBLY=Ensamblador
CONFIG_SIMULATION_OPEN_LOG_ON_ASSEMBLE=Abrir la ventana de log al ensamblar.
CONFIG_SIMULATION_REGION_MEMORY=Memoria
CONFIG_SIMULATION_MEMORY_ROWS=Filas:
CONFIG_SIMULATION_MEMORY_ROWS_TOOLTIP=El número de filas que la memoria puede mostrar al mismo tiempo.
CONFIG_SIMULATION_MIPS_REGION_FLOW=Flujo
CONFIG_SIMULATION_MIPS_FLOW_MAX_ITEMS=Entradas máximas:
CONFIG_SIMULATION_MIPS_FLOW_MAX_ITEMS_TOOLTIP=La cantidad de entradas que el panel de flujo puede representar al mismo tiempo.

EDITOR_MIPS_ERROR_ILLEGAL_LABEL=El nombre de la etiqueta '{TEXT}' es inválido.
EDITOR_MIPS_ERROR_LABEL_NOT_FOUND=No se ha podido encontrar la etiqueta '{TEXT}'.
EDITOR_MIPS_ERROR_DUPLICATE_LABEL=La etiqueta '{TEXT}' está duplicada.
EDITOR_MIPS_ERROR_DUPLICATE_GLOBAL_LABEL=La etiqueta '{TEXT}' está duplicada en el archivo '{FILE}'.
EDITOR_MIPS_ERROR_DIRECTIVE_NOT_FOUND=No se ha podido encontrar la directiva '{TEXT}'.
EDITOR_MIPS_ERROR_INVALID_DIRECTIVE_PARAMETER=El parámetro '{TEXT} tiene un formato incorrecto.
EDITOR_MIPS_ERROR_INSTRUCTION_NOT_FOUND=No se ha podido encontrar la instrucción '{TEXT}' con los parámetros indicados.
EDITOR_MIPS_ERROR_INVALID_INSTRUCTION_PARAMETER=El parámetro '{TEXT} tiene un formato incorrecto.

ACTION_REGION_GENERAL=General
ACTION_GENERAL_CREATE_PROJECT=Crear proyecto
ACTION_GENERAL_OPEN_PROJECT=Abrir proyecto
ACTION_GENERAL_SETTINGS=Configuración
ACTION_GENERAL_ASSEMBLE=Ensamblar código

ACTION_REGION_TEXT_EDITOR=Editor de texto
ACTION_TEXT_EDITOR_REFORMAT=Reestructurar código
ACTION_TEXT_EDITOR_SAVE=Guardar archivo
ACTION_TEXT_EDITOR_SHOW_AUTOCOMPLETION_POPUP=Mostrar autocompletador
ACTION_TEXT_EDITOR_SHOW_DOCUMENTATION_POPUP=Mostrar documentación
ACTION_TEXT_EDITOR_PREVIOUS_FILE=Ir al anterior archivo
ACTION_TEXT_EDITOR_NEXT_FILE=Ir al siguiente archivo
ACTION_TEXT_EDITOR_REFRESH_FROM_DISK=Recargar desde el disco
ACTION_TEXT_EDITOR_COPY=Copiar
ACTION_TEXT_EDITOR_PASTE=Pegar
ACTION_TEXT_EDITOR_CUT=Cortar
ACTION_TEXT_EDITOR_UNDO=Deshacer
ACTION_TEXT_EDITOR_REDO=Rehacer
ACTION_TEXT_EDITOR_SELECT_ALL=Seleccionar todo
ACTION_TEXT_EDITOR_DUPLICATE_LINE=Duplicar línea

ACTION_REGION_EXPLORER_ELEMENT=Elementos del explorador
ACTION_EXPLORER_ELEMENT_CONTRACT_OR_SELECT_PARENT=Contraer carpeta / seleccionar padre
ACTION_EXPLORER_ELEMENT_EXPAND_OR_NEXT=Expandir carpeta / seleccionar siguente elemento
ACTION_EXPLORER_ELEMENT_SELECT_NEXT=Seleccionar siguiente elemento
ACTION_EXPLORER_ELEMENT_SELECT_NEXT_MULTIPLE=Seleccionar siguiente elemento (selección múltiple)
ACTION_EXPLORER_ELEMENT_SELECT_PREVIOUS=Seleccionar elemento anterior
ACTION_EXPLORER_ELEMENT_SELECT_PREVIOUS_MULTIPLE=Seleccionar elemento anterior (selección múltiple)
ACTION_EXPLORER_ELEMENT_SELECT_ALL=Seleccionar todo

ACTION_REGION_FOLDER_EXPLORER_ELEMENT=Elementos del explorador de carpetas
ACTION_FOLDER_EXPLORER_ELEMENT_COPY=Copiar
ACTION_FOLDER_EXPLORER_ELEMENT_DELETE=Eliminar
ACTION_FOLDER_EXPLORER_ELEMENT_PASTE=Pegar
ACTION_FOLDER_EXPLORER_ELEMENT_SHOW_IN_FILES=Mostrar en Archivos
ACTION_FOLDER_EXPLORER_ELEMENT_NEW=Nuevo
ACTION_FOLDER_EXPLORER_ELEMENT_NEW_FILE=Archivo
ACTION_FOLDER_EXPLORER_ELEMENT_NEW_ASSEMBLY_FILE=Archivo ensamblador
ACTION_FOLDER_EXPLORER_ELEMENT_NEW_FOLDER=Carpeta
ACTION_FOLDER_EXPLORER_ELEMENT_ADD_FILE_TO_ASSEMBLER=Añadir archivo al ensamblador
ACTION_FOLDER_EXPLORER_ELEMENT_REMOVE_FILE_FROM_ASSEMBLER=Quitar archivo del ensamblador

ACTION_REGION_EDITOR_TAB=Pestaña del editor
ACTION_EDITOR_TAB_SPLIT_HORIZONTALLY=Mover horizontalmente
ACTION_EDITOR_TAB_SPLIT_VERTICALLY=Mover verticalmente

ACTION_REGION_MIPS_FILE_TO_ASSEMBLE=Archivos a ensamblar
ACTION_MIPS_FILES_TO_ASSEMBLE_REMOVE=Eliminar del ensamblador

ACTION_REGION_MIPS_SIMULATION=Simulación MIPS
ACTION_MIPS_SIMULATION_EXECUTE_ALL_INSTRUCTIONS=Ejecutar todas las instrucciones
ACTION_MIPS_SIMULATION_EXECUTE_ONE_STEP=Ejecutar un paso
ACTION_MIPS_SIMULATION_RESET=Reiniciar
ACTION_MIPS_SIMULATION_STOP=Parar
ACTION_MIPS_SIMULATION_UNDO_ONE_STEP=Deshace un paso

NUMBER_FORMAT_HEXADECIMAL=Hexadecimal
NUMBER_FORMAT_DECIMAL=Decimal
NUMBER_FORMAT_OCTAL=Octal
NUMBER_FORMAT_BINARY=Binario
NUMBER_FORMAT_LONG=Long
NUMBER_FORMAT_FLOAT=Coma flotante
NUMBER_FORMAT_DOUBLE=Coma flotante (doble precisión)
NUMBER_FORMAT_CHAR=Characteres
NUMBER_FORMAT_RGB=RGB
NUMBER_FORMAT_RGBA=RGBA
NUMBER_FORMAT_ENGLISH=Texto inglés
NUMBER_FORMAT_ROMAN=Romano

//INSTRUCTIONS

INSTRUCTION_ABS_D=Suma (coma flotante doble)
INSTRUCTION_ABS_S=Valor absoluto (coma flotante)
INSTRUCTION_ADD=Suma
INSTRUCTION_ADD_D=Suma (coma flotante doble)
INSTRUCTION_ADDIU=Suma con inmediato sin desbordamiento
INSTRUCTION_ADDIUPC=Suma de inmediato y PC sin desbordamiento
INSTRUCTION_ADD_S=Suma (coma flotante)
INSTRUCTION_ADDU=Suma sin desbordamiento
INSTRUCTION_ALIGN=Concatenar dos registros generales, extrayendo un subconjunto contiguo a una posición de byte
INSTRUCTION_ALUIPC=Suma alineada del inmediato con los bits superiores del PC
INSTRUCTION_AND=And
INSTRUCTION_ANDI=And con inmediato
INSTRUCTION_AUI=Suma del inmediato con los bits superiores
INSTRUCTION_AUIPC=Suma del inmediato con los bits superiores del PC
INSTRUCTION_BAL=Ramificación y enlace
INSTRUCTION_BALC=Ramificación compacta y enlace
INSTRUCTION_BC=Ramificación compacta
INSTRUCTION_BC1EQZ=Ramificación si el bit 0 del registro COP1 es cero
INSTRUCTION_BC1NEZ=Ramificación si el bit 0 del registro COP1 no es cero
INSTRUCTION_BEQ=Ramificación si es igual
INSTRUCTION_BEQC=Ramificación compacta si es igual
INSTRUCTION_BEQZALC=Ramificación compacta y enlace si es igual que cero
INSTRUCTION_BEQZC=Ramificación compacta si es igual que cero
INSTRUCTION_BGEC=Ramificación compacta si es mayor o igual
INSTRUCTION_BGEUC=Ramificación compacta si es mayor o igual sin signo
INSTRUCTION_BGEZ=Ramificación si es mayor o igual que cero
INSTRUCTION_BGEZALC=Ramificación compacta y enlace si es mayor o igual que cero
INSTRUCTION_BGEZC=Ramificación compacta si es mayor o igual que cero
INSTRUCTION_BGTZ=Ramificación si es mayor que cero
INSTRUCTION_BGTZALC=Ramificación compacta y enlace si es mayor que cero
INSTRUCTION_BGTZC=Ramificación compacta si es mayor que cero
INSTRUCTION_BITSWAP=Intercambiar bits en cada byte
INSTRUCTION_BLEZ=Ramificación si es menor o igual que cero
INSTRUCTION_BLEZALC=Ramificación compacta y enlace si es menor o igual que cero
INSTRUCTION_BLEZC=Ramificación compacta si es menor o igual que cero
INSTRUCTION_BLTC=Ramificación compacta si es menor
INSTRUCTION_BLTUC=Ramificación compacta si es menor sin signo
INSTRUCTION_BLTZ=Ramificación si es menor que cero
INSTRUCTION_BLTZALC=Ramificación compacta y enlace si es menor que cero
INSTRUCTION_BLTZC=Ramificación compacta si es menor que cero
INSTRUCTION_BNE=Ramificación si no es igual
INSTRUCTION_BNEC=Ramificación compacta si no es igual
INSTRUCTION_BNEZALC=Ramificación compacta y enlace si no es igual que cero
INSTRUCTION_BNEZC=Ramificación compacta si no es igual que cero
INSTRUCTION_BNVC=Ramificación si la suma no desborda
INSTRUCTION_BOVC=Ramificación si la suma desborda
INSTRUCTION_BREAK=Punto de ruptura
INSTRUCTION_CEIL_L_D=Función techo de coma flotante doble a doble palabra
INSTRUCTION_CEIL_L_S=Función techo de coma flotante a doble palabra
INSTRUCTION_CEIL_W_D=Función techo de coma flotante doble a palabra
INSTRUCTION_CEIL_W_S=Función techo de coma flotante a palabra
INSTRUCTION_CLO=Conteo de los primeros unos en una palabra
INSTRUCTION_CLZ=Conteo de los primeros ceros en una palabra
INSTRUCTION_CMP_D=Comparación en coma flotante doble ({TYPE})
INSTRUCTION_CMP_S=Comparación en coma flotante ({TYPE})
INSTRUCTION_CVT=Convertir número de {FROM} a {TO}
INSTRUCTION_DIV=División
INSTRUCTION_DIV_D=División (coma flotante doble)
INSTRUCTION_DIV_S=División (coma flotante)
INSTRUCTION_DIVU=División sin signo
INSTRUCTION_ERET=Retorno de la excepción
INSTRUCTION_J=Salto
INSTRUCTION_JAL=Salto y enlace
INSTRUCTION_JALR=Salto y enlace a registros
INSTRUCTION_LB=Cargar byte
INSTRUCTION_LW=Cargar palabra
INSTRUCTION_MFC0=Mover desde el coprocesador 0
INSTRUCTION_MFC1=Mover desde el coprocesador 1
INSTRUCTION_MOD=Módulo
INSTRUCTION_MODU=Módulo sin signo
INSTRUCTION_MFC0=Mover al coprocesador 0
INSTRUCTION_MFC1=Mover al coprocesador 1
INSTRUCTION_MUH=Multiplicación devolviendo la parte más significante
INSTRUCTION_MUHU=Multiplicación sin signo devolviendo la parte más significante
INSTRUCTION_MUL=Multiplicación devolviendo la parte menos significante
INSTRUCTION_MUL_D=Multiplicación (coma flotante doble)
INSTRUCTION_MUL_S=Multiplicación (coma flotante)
INSTRUCTION_MULU=Multiplicación sin signo devolviendo la parte menos significante
INSTRUCTION_OR=Or
INSTRUCTION_ORI=Or con inmediato
INSTRUCTION_SB=Guardar byte
INSTRUCTION_SLL=Desplazar a la izquierda de manera lógica
INSTRUCTION_SLLV=Desplazar a la izquierda de manera lógica dependiendo de una variable
INSTRUCTION_SLT=Asignar si menor que valor
INSTRUCTION_SLTI=Asignar si menor que inmediato
INSTRUCTION_SLTIU=Asignar si menor que inmediato sin signo
INSTRUCTION_SLTU=Asignar si menor que sin signo
INSTRUCTION_SRL=Desplazar a la derecha de manera lógica
INSTRUCTION_SRLV=Desplazar a la derecha de manera lógica dependiendo de una variable
INSTRUCTION_SUB=Resta
INSTRUCTION_SUB_D=Resta (coma flotante doble)
INSTRUCTION_SUB_S=Resta (coma flotante)
INSTRUCTION_SUBU=Resta sin desbordamiento
INSTRUCTION_SW=Guardar palabra
INSTRUCTION_SYSCALL=Llamada al sistema

//PSEUDO INSTRUCTIONS

INSTRUCTION_B=Ramificación incondicional
INSTRUCTION_JR=Saltar al valor del registro
INSTRUCTION_LA=Cargar dirección
INSTRUCTION_LI=Cargar inmediato
INSTRUCTION_LUI=Cargar inmediato en los bits más significantes
INSTRUCTION_MOVE=Mover valor
INSTRUCTION_NOP=Operación nula
INSTRUCTION_SGE=Asignar si menor o igual que valor
INSTRUCTION_SGEI=Asignar si mayor o igual que inmediato
INSTRUCTION_SGEIU=Asignar si mayor o igual que inmediato sin signo
INSTRUCTION_SGEU=Asignar si mayor o igual que sin signo
INSTRUCTION_SGT=Asignar si mayor que valor
INSTRUCTION_SGTI=Asignar si mayor que inmediato
INSTRUCTION_SGTIU=Asignar si mayor que inmediato sin signo
INSTRUCTION_SGTU=Asignar si mayor que sin signo
INSTRUCTION_SLE=Asignar si menor o igual que valor
INSTRUCTION_SLEI=Asignar si menor o igual que inmediato
INSTRUCTION_SLEIU=Asignar si menor o igual que inmediato sin signo
INSTRUCTION_SLEU=Asignar si menor o igual que sin signo

//INSTRUCTIONS DOCUMENTATION

INSTRUCTION_ABS_D_DOCUMENTATION.=<u>Valor absoluto en coma flotante de precisión doble</u>

<b>Formato:</b>
abs.d fd, fs

| COP1      fmt      0      fs      fd      ABS   |
|010001    10001   00000                   000101 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
FPR[fd] <- abs(FRP[fs])

Asigna el valor absoluto de <i>fs</i> a <i>fd</i>. Tanto el operando como el resultado son valores en coma flotante de precisión doble.

<b>Restricciones:</b>
Los registros <i>fs</i> y <i>fd</i> deben ser FPRs pares. Si los registros no son válidos, el resultado es <black>IMPREDECIBLE</black>.
El operando debe ser un valor en coma flotante de precisión doble. Si no lo es, el resultado es <black>IMPREDECIBLE</black>.

<b>Operación:</b>
fmt <- double
StoreFPR(fd, fmt, AbsoluteValue(ValueFPR(fs, fmt)))

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_ABS_S_DOCUMENTATION.=<u>Valor absoluto en coma flotante</u>

<b>Formato:</b>
abs.s fd, fs

| COP1      fmt      0      fs      fd      ABS   |
|010001    10000   00000                   000101 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
FPR[fd] <- abs(FRP[fs])

Asigna el valor absoluto de <i>fs</i> a <i>fd</i>. Tanto el operando como el resultado son valores en coma flotante.

<b>Restricciones:</b>
El operando debe ser un valor en coma flotante. Si no lo es, el resultado es <black>IMPREDECIBLE</black>.

<b>Operación:</b>
fmt <- float
StoreFPR(fd, fmt, AbsoluteValue(ValueFPR(fs, fmt)))

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_ADD_DOCUMENTATION.=<u>Suma</u>

<b>Formato:</b>
add rd, rs, rt

|SPECIAL     rs      rt     rd      0       ADD   |
|000000                                    100000 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
GPR[rd] <- GPR[rs] + GPR[rt]

La palabra de 32 bits del registro <i>rt</i> es sumada a la palabra de 32 bits del registro <i>rs</i> para producir un resultado de 32 bits.
 - Si la suma resulta en un desbordamiento aritmético en complemento a 2 de 32 bits, el registro destino no es modificado y la excepción <black>Integer Overflow</black> es lanzada.
 - Si la suma no produce un desbordamiento, el resultado es insertado en el registro GPR <i>rd</i>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
temp <- (GPR[rs]<sub>31</sub> || GPR[rs]<sub>31..0</sub>) + (GPR[rt]<sub>31</sub> || GPR[rt]<sub>31..0</sub>)
if temp<sub>32</sub> != temp<sub>31</sub> then
    SignalException(IntegerOverflow)
else
    GPR[rd] <- temp
endif

<b>Excepciones:</b>
Integer Overflow

<b>Notas del programador:</b>
<black>addu</black> ejecuta la misma operación aritmética pero no lanza una excepción al desbordar.
\END

INSTRUCTION_ADD_D_DOCUMENTATION.=<u>Suma en coma flotante de precisión doble</u>

<b>Formato:</b>
add.d fd, fs, ft

| COP1      fmt      ft     fs      fd      ABS   |
|010001    10001   00000                   000000 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
FPR[fd] <- FRP[fs] + FPR[ft]

El valor en el registro <i>ft</i> es añadido al valor en el registro <i>fs</i>. El resultado es calculado en precisión infinita, usando el redondeo proporcionado por <i>Java</i>, y asignado al registro <i>fd</i>.
Los operando y el resultado son valores en coma flotante de precisión doble.

<b>Restricciones:</b>
Los registros <i>fs</i>, <i>ft</i> y <i>fd</i> deben ser FPRs pares. Si los registros no son válidos, el resultado es <black>IMPREDECIBLE</black>.
El operando debe ser un valor en coma flotante de precisión doble. Si no lo es, el resultado es <black>IMPREDECIBLE</black>.

<b>Operación:</b>
fmt <- double
StoreFPR(fd, fmt, ValueFPR(fs, fmt) +<sub>fmt</sub> ValueFPR(ft, fmt))

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_ADD_S_DOCUMENTATION.=<u>Suma en coma flotante</u>

<b>Formato:</b>
add.s fd, fs, ft

| COP1      fmt      ft     fs      fd      ABS   |
|010001    10000   00000                   000000 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
FPR[fd] <- FRP[fs] + FPR[ft]

El valor en el registro <i>ft</i> es añadido al valor en el registro <i>fs</i>. El resultado es calculado en precisión infinita, usando el redondeo proporcionado por <i>Java</i>, y asignado al registro <i>fd</i>.
Los operando y el resultado son valores en coma flotante.

<b>Restricciones:</b>
El operando debe ser un valor en coma flotante. Si no lo es, el resultado es <black>IMPREDECIBLE</black>.

<b>Operación:</b>
fmt <- float
StoreFPR(fd, fmt, ValueFPR(fs, fmt) +<sub>fmt</sub> ValueFPR(ft, fmt))

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_ADDIU_DOCUMENTATION.=<u>Suma con inmediato sin signo</u>

<b>Formato:</b>
addiu rt, rs, inmediato

| ADDIU      rs     rt     inmediato |
|001001                              |
|  6         5      5         16     |


<b>Descripción:</b>
GPR[rt] <- GPR[rs] + inmediato

El valor con signo de 16 bits <i>inmediato</i> es sumado al valor de 32 bits del registro <i>rs</i> y el resultado de 32 bits es asignado al registro <i>rt</i>.
Ninguna excepción de desbordamiento ocurre en ninguna de las circunstancias.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
temp <- GPR[rs] + sign_extend(inmediato)
GPR[rt] <- temp

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>
El término <i>sin signo</i> en esta instrucción es parcialmente incorrecto; esta instrucción ejecuta una operación aritmética de 32 bits que no lanza una excepción al desbordar. Esta instrucción es apropiada para aritmética sin signo, o entornos aritméticos que ignoran el desbordamiento, como puede ser la aritmética del lenguaje C.
\END

INSTRUCTION_ADDIUPC_DOCUMENTATION.=<u>Suma de inmediato y PC sin singo</u>

<b>Formato:</b>
addiupc rs, inmediato

| PCREL      rs   ADDIUPC   inmediato |
|111011              00               |
|  6         5       2         19     |


<b>Descripción:</b>
GPR[rs] <- PC + sign_extend(inmediato << 2)

Esta instrucción ejecuta el cálculo de una dirección relativa al PC. El <i>inmediato</i> de 19 bits es desplazado a la izquierda 2 bits, extendido con signo y sumado con la dirección de la instrucción.
El resultado es asignado al registro <i>rs</i>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
GPR[rs] <- PC + sign_extend(inmediato << 2)

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>
El término <i>sin signo</i> es parcialmente incorrecto. <i>Sin signo</i> aquí significa <i>ignorando desbordamientos</i>. Esta instrucción no lanza una excepción cuando la suma produce un desbordamiento. <black>addiupc</black> corresponde a la instrucción <black>addiu</black>, la cual no lanza excepciones al desbordar.
\END

INSTRUCTION_ADDU_DOCUMENTATION.=<u>Suma sin signo</u>

<b>Formato:</b>
addu rd, rs, rt

|SPECIAL     rs      rt     rd      0       ADD   |
|000000                                    100001 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
GPR[rd] <- GPR[rs] + GPR[rt]

La palabra de 32 bits del registro <i>rt</i> es sumada a la palabra de 32 bits del registro <i>rs</i> para producir un resultado de 32 bits.
El resultado es asignado al registro <i>rd</i>.
Ninguna excepción de desbordamiento ocurre en ninguna de las circunstancias.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
temp <- GPR[rs] + GPR[rt]
GPR[rd] <- temp

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>
El término <i>sin signo</i> en esta instrucción es parcialmente incorrecto; esta instrucción ejecuta una operación aritmética de 32 bits que no lanza una excepción al desbordar. Esta instrucción es apropiada para aritmética sin signo, o entornos aritméticos que ignoran el desbordamiento, como puede ser la aritmética del lenguaje C.
\END

INSTRUCTION_ALIGN_DOCUMENTATION.=<u>Concatenar dos registros generales, extrayendo un subconjunto contiguo a una posición de byte</u>

<b>Formato:</b>
align rd, rs, rt, bp

|SPECIAL3    rs    rt    rd    ALIGN   bp   BSGFL  |
| 011111                        010         100000 |
|   6        5     5     5       3     2      6    |


<b>Descripción:</b>
GPR[rd] <- (GPR[rt] << 8 * bp) or (GPR[rs] >> 8 * (4 - bp))

El registro <i>rt</i> y el registro <i>rs</i> son concatenados, y un subconjunto del tamaño de un registro es extraido, el cual está especificado por el puntero a byte <i>bp</i>.
La instrucción <black>align</black> opera con palabras de 32 bits, y tiene una celda de 2 bits <i>bp</i> representando el puntero a byte.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
tmp_rt_hi <- unsigned_word(GPR[rt]) << 8 * bp
tmp_rs_lo <- unsigned_word(GPR[rs]) >> 8 * (4 - bp)
GPR[rd] <- tmp_rt_hi or tmp_rs_lo

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_ALUIPC_DOCUMENTATION.=<u>Suma alineada del inmediato con los bits superiores del PC</u>

<b>Formato:</b>
aluipc rs, inmediato

| PCREL     rs     ALUIPC   inmediato |
|111011            11111              |
|  6        5        5         16     |


<b>Descrpción:</b>
GPR[rs] <- not 0x0FFFF and PC + sign_extend(inmediato << 16)

Esta instrucción ejecuta el cálculo de una dirección relativa al PC. El <i>inmediato</i> de 16 bits es desplazado a la izquierda 16 bits, extendido con signo y sumado con la dirección de la instrucción.
Los 16 bits menos significantes son pustos a 0. El resultado es asignado al registro <i>rs</i>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
GPR[rs] <- not 0x0FFFF and PC + sign_extend(inmediato << 16)

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_AND_DOCUMENTATION.=<u>And</u>

<b>Formato:</b>
and rd, rs, rt

|SPECIAL     rs      rt     rd      0       AND   |
|000000                                    100100 |
|  6         5       5      5       5        6    |


<b>Descripción:</b>
GPR[rd] <- GPR[rs] and GPR[rt]

Realiza la operación lógica AND usando los valores dentro de los registros <i>rs</i> y <i>rt</i>.
El resultado es asignado al registro <i>rd</i>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
GPR[rd] <- GPR[rs] and GPR[rt]

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_ANDI_DOCUMENTATION.=<u>And con inmediato</u>

<b>Formato:</b>
andi rt, rs, inmediato

| ANDI      rs     rt     inmediato |
|001100                             |
|  6        5      5         16     |


<b>Descripción:</b>
GPR[rt] <- GPR[rs] and zero_extend(inmediato)

El <i>inmediato</i> de 16 bits es extendido a la izquierda con ceros y combinado con el valor del registro <i>rs</i> usando la operación lógica AND.
El resultado es asignado al registro <i>rt</i>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
GPR[rt] <- GPR[rs] and zero_extend(immediate)

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_AUI_DOCUMENTATION.=<u>Suma del inmediato con los bits superiores</u>

<b>Formato:</b>
aui rt, rs, inmediato

| AUI       rs     rt     inmediato |
|001111                             |
|  6        5      5         16     |


<b>Descripción:</b>
GPR[rt] <- GPR[rs] + sign_extend(inmediato << 16)


El <i>inmediato</i> de 16 bits es desplazado a la izquierda unos 16 bits, extendido con signo y sumado al registro <i>rs</i>
El resultado es insertado en el registro <i>rt</i>
En MIPS32r6, <black>lui</black> es un alias de <black>aui</black> con <i>rs</i> = 0.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
GPR[rt] <- GPR[rs] + sign_extend(inmediato << 16)

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>
<black>aui</black> puede ser usado para sintetizar grandes constantes en situaciones donde no es conveniente cargar una constante de memoria.
\END

INSTRUCTION_AUIPC_DOCUMENTATION.=<u>Suma del inmediato con los bits superiores del PC</u>

<b>Formato:</b>
auipc rs, inmediato

| PCREL    rs    AUIPC    inmediato |
|111011          11110              |
|  6       5       5         16     |


<b>Descripción:</b>
GPR[rs] <- PC + (inmediato << 16)


Esta instrucción ejecuta el cálculo de una dirección relativa al PC. El <i>inmediato</i> de 16 bits es desplazado a la izquierda 16 bits y sumado con la dirección de la instrucción.
El resultado es asignado al registro <i>rs</i>.

<b>Restricciones:</b>
Ninguna

<b>Operación:</b>
GPR[rs] <- PC + (inmediato << 16)

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_BAL_DOCUMENTATION.=<u>Ramificación y enlace</u>

<b>Formato:</b>
b desplazamiento

|REGIMM             BAL    desplazamiento  |
|000001    00000   10001                   |
|  6         5       5           16        |


<b>Descripción:</b>
Inserta la dirección de retorno en el registro <i>31</i>. Ésta es la dirección de la instrucción donde la ejecución debe continuar después de una llamada a un procedimiento.
Un desplazamiento de 18 bits (la <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción parra formar una dirección efectiva.

<b>Restrictions:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

<b>Operación:</b>
<black>I:</black>
desp <- sign_extend(desplazamiento || 00)
GPR[31] <- PC + 4

<black>I+1:</black>
PC <- PC + desp

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>
<black>bal</black> sin un retorno correspondiente no debe ser usado para leer el PC. Hacerlo puede causar una pérdida de rendimiento en procesadores con un predictor de dirección de retorno.
\END

INSTRUCTION_BALC_DOCUMENTATION.=<u>Ramificación compacta y enlace</u>

<b>Formato:</b>
balc desplazamiento

| BALC     desplazamiento  |
|111010                    |
|  6             26        |


<b>Descripción:</b>
Inserta la dirección de retorno en el registro <i>31</i>. Ésta es la dirección de la instrucción donde la ejecución debe continuar después de una llamada a un procedimiento.
Un desplazamiento de 28 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción parra formar una dirección efectiva.
Esta instrución ejecuta una ramificación compacta. Las ramificaciones compactas no tienen huecos de retardo.

<b>Restrictions:</b>
Esta instrucción es una ramificación incondicional que siempre es tomada. No tiene ni huecos prohibidos ni huecos de retardo.

<b>Operación:</b>
target_offset <- sign_extend(desplazamiento || 00)
GPR[31] <- PC + 4
PC <- PC + 4 + target_offset

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_BC_DOCUMENTATION.=<u>Ramificación compacta</u>

<b>Formato:</b>
balc desplazamiento

|  BC      desplazamiento  |
|110010                    |
|  6             26        |


<b>Descripción:</b>
Un desplazamiento de 28 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción parra formar una dirección efectiva.
Esta instrución ejecuta una ramificación compacta. Las ramificaciones compactas no tienen huecos de retardo.

<b>Restrictions:</b>
Esta instrucción es una ramificación incondicional que siempre es tomada. No tiene ni huecos prohibidos ni huecos de retardo.

<b>Operación:</b>
target_offset <- sign_extend(desplazamiento || 00)
PC <- PC + 4 + target_offset

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_BC1EQZ_DOCUMENTATION.=<u>Ramificación si el bit 0 del registro COP1 es cero</u>

<b>Formato:</b>
bc1eqz ft, desplazamiento

| COP1      BC1EQZ     ft   desplazamiento  |
|010001     01001                           |
|  6          5        5          16        |


<b>Descripción:</b>
if FPR[ft] & 1 = 0 then branch

La condición es verdadera si y solo si el bit 0 del registro <i>ft</i> es cero.
Si la condición es falsa, la ramificación no es tomada y la ejecución continua con la siguiente instrucción.

If the condition is false, the branch is not taken and execution continues with the next instruction.
Un desplazamiento de 18 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción parra formar una dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

<b>Operación:</b>
temp = ValueFPR(ft, UNINTERPRETED_WORD)
cond = temp & 1 = 0
if cond then
    <black>I:</black>
    target_PC <- PC + 4 + sign_extend(desplazamiento << 2)
    <black>I+1:</black>
    PC <- target_PC
endif

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_BC1NEZ_DOCUMENTATION.=<u>Ramificación si el bit 0 del registro COP1 no es cero</u>

<b>Formato:</b>
bc1nez ft, desplazamiento

| COP1      BC1NEZ     ft   desplazamiento  |
|010001     01101                           |
|  6          5        5          16        |


<b>Descripción:</b>
if FPR[ft] & 1 != 0 then branch

La condición es verdadera si y solo si el bit 0 del registro <i>ft</i> no es cero.
Si la condición es falsa, la ramificación no es tomada y la ejecución continua con la siguiente instrucción.

If the condition is false, the branch is not taken and execution continues with the next instruction.
Un desplazamiento de 18 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción parra formar una dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

<b>Operación:</b>
temp = ValueFPR(ft, UNINTERPRETED_WORD)
cond = temp & 1 != 0
if cond then
    <black>I:</black>
    target_PC <- PC + 4 + sign_extend(desplazamiento << 2)
    <black>I+1:</black>
    PC <- target_PC
endif

<b>Excepciones:</b>
Ninguna
\END

INSTRUCTION_BEQ_DOCUMENTATION.=<u>Ramificación si es igual</u>

<b>Formato:</b>
beq rs, rt, desplazamiento

| BEQ       rs     rt     desplazamiento  |
|000100                                   |
|  6        5      5            16        |


<b>Descripción:</b>
if GPR[rs] = GPR[rt] then branch

Un desplazamiento de 18 bits (la celda <i>desplazamiento</i> desplazada 2 bits a la izquierda) es sumado a la dirección de la siguiente instrucción parra formar una dirección efectiva.
Si el contenido de los registros <i>rt</i> y <i>rs</i> son iguales, la instrucción ejecuta la ramificación a la dirección efectiva.

<b>Restricciones:</b>
Las <i>Instrucciones de control de tranferencia (CTIs)</i> <black>no deben</black> ser colocadas en los huecos de retardo o en los huecos prohibidos de la Release 6. Las CTIs incluyen todas las ramificaciones, saltos, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> y <black>pause</black>.
Si una CTI es ejecutada en el hueco de retardo de una ramificación o salto, las implementaciones de la Release 6 necesitan lanzar una excepción <black>Reserved Instruction</black>

<b>Operación:</b>
<black>I:</black>
target_offset <- sign_extend(desplazamiento || 00)
condition <- GPR[rs] = GPR[rt]
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Excepciones:</b>
Ninguna

<b>Notas del programador:</b>
Con el desplazamiento de 18 bits, el rango de la ramificación es de  ±128KBytes. Usa el salto (<black>j</black>) o el salto a registro (<black>jr</black>) para ramificar a direcciones fuera de este rango.
<black>beq $zero, $zero, desplazamiento</black>, expresado como <black>b desplazamiento</black>, es el equivalente en ensablador para denotar un salto incondicional.

\END

FLOAT_CONDITION_AF=Siempre falso
FLOAT_CONDITION_UN=Sin orden
FLOAT_CONDITION_EQ=Igual
FLOAT_CONDITION_UEQ=Sin orden o igual
FLOAT_CONDITION_LT=Menor que ordenado
FLOAT_CONDITION_ULT=Desordenado o menor que
FLOAT_CONDITION_LE=Menor o igual ordenado
FLOAT_CONDITION_ULE=Desordenado o menor o igual que
FLOAT_CONDITION_SAF=Siempre falso con señal
FLOAT_CONDITION_SUN=Desordenado con señal
FLOAT_CONDITION_SEQ=Igual ordenado con señal
FLOAT_CONDITION_SUEQ=Desordenado o igual con señal
FLOAT_CONDITION_SLT=Menor que ordenado con señal
FLOAT_CONDITION_SULT=Desordenado o menor que con señal
FLOAT_CONDITION_SLE=Menor o igual ordenado con señal
FLOAT_CONDITION_SULE=Desordenado o menor que o igual con señal
FLOAT_CONDITION_OR=Ordenado
FLOAT_CONDITION_UNE=No igual
FLOAT_CONDITION_NE=No igual ordenado
FLOAT_CONDITION_SOR=Ordenado con señal
FLOAT_CONDITION_SUNE=Desordenado o no igual con señal
FLOAT_CONDITION_SNE=No igual ordenado con señal

FMT_SINGLE=Coma flotante
FMT_DOUBLE=Coma flotante doble
FMT_WORD=palabra
FMT_LONG=doble palabra

ABOUT=JAMS\nVersión {VERSION}\n\nCopyright 2020-2021\nCreado por Gael Rial Costas