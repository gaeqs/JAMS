English

GENERAL_CONFIRM=Confirm
GENERAL_OK=Ok
GENERAL_FINISH=Finish
GENERAL_CANCEL=Cancel
GENERAL_CREATE=Create
GENERAL_CONFIRMATION=Confirmation
GENERAL_CONFIRMATION=Confirmation
GENERAL_ADD=Add
GENERAL_REMOVE=Remove
GENERAL_COPY=Copy
GENERAL_PASTE=Paste
GENERAL_SORT=Sort

START_TITLE=JAMS {VERSION}
START_PROJECTS=Projects
START_NEW_PROJECT=New project
START_ABOUT=About

BOTTOM_BAR_MEMORY={USED} of {TOTAL}MiB
BOTTOM_BAR_MEMORY_TOOLTIP=Click to execute the garbage collector.

PROJECT_CREATOR_MIPS_ASSEMBLER=Assembler:
PROJECT_CREATOR_MIPS_INSTRUCTION_SET=Instruction set:
PROJECT_CREATOR_MIPS_DIRECTIVE_SET=Directive set:
PROJECT_CREATOR_MIPS_REGISTERS=Registers:

PROJECT_CREATOR_MIPS_EMPTY=Empty MIPS project

MAIN_MENU_FILE=File
MAIN_MENU_EDIT=Edit
MAIN_MENU_SIMULATION=Simulation
MAIN_MENU_TOOLS=Tools
MAIN_MENU_HELP=Help

MAIN_MENU_FILE_EXIT=Exit
MAIN_MENU_FILE_SETTINGS=Settings
MAIN_MENU_FILE_OPEN_PROJECT=Open project
MAIN_MENU_FILE_CREATE_PROJECT=Create project
MAIN_MENU_FILE_CREATE_PROJECT_TITLE=Create project
MAIN_MENU_FILE_CREATE_PROJECT_NAME=Name:
MAIN_MENU_FILE_CREATE_PROJECT_PATH=Path:

MAIN_MENU_HELP_ABOUT=About

PROJECT_TAB_STRUCTURE=Project structure
PROJECT_TAB_SIMULATION=Simulation

BAR_VIEW_MODE_PANE=Show in pane
BAR_VIEW_MODE_WINDOW=Show in window
BAR_VIEW_MODE_PERSISTENT_WINDOW=Show in persistent window

BAR_EXPLORER_NAME=Explorer
BAR_FILES_TO_ASSEMBLE_NAME=Files to assemble
BAR_LOG_NAME=Log
BAR_SEARCH_RESULTS={RESULTS} results

SIMULATION_CONFIGURATION_CONFIGURATIONS=Configurations:
SIMULATION_CONFIGURATION_INFO=Configurations settings
SIMULATION_CONFIGURATION_GENERAL=General
SIMULATION_CONFIGURATION_GENERAL_REGION=General settings
SIMULATION_CONFIGURATION_NAME=Name:
SIMULATION_CONFIGURATION_ARCHITECTURE=Architecture:
SIMULATION_CONFIGURATION_ARCHITECTURE_TOOLTIP=The architecture the simulation will use.\n\nSome options are only available in specific architectures.
SIMULATION_CONFIGURATION_MEMORY=Memory:
SIMULATION_CONFIGURATION_MEMORY_TOOLTIP=The memory the simulation will use.
SIMULATION_CONFIGURATION_CALL_EVENTS=Call memory, registers and instructions events.
SIMULATION_CONFIGURATION_CALL_EVENTS_TOOLTIP=Allows the simulation to notify memory, registers and instructions' changes.\n\nIf this option is disabled, the simulation will work faster, but some debugger and plug-ins' options won't work. Events will work when the simulation is stopped.
SIMULATION_CONFIGURATION_ENABLE_UNDO=Allow to undo steps
SIMULATION_CONFIGURATION_ENABLE_UNDO_TOOLTIP=Allows you to undo simulation's steps.\n\nIf this option is disabled, the simulation will work faster and it will consume less memory, but you will be unable to undo steps.\n\nThis option requires events to be activated.
SIMULATION_CONFIGURATION_ENABLE_FORWARDING=Enable forwarding
SIMULATION_CONFIGURATION_ENABLE_FORWARDING_TOOLTIP=Allows instructions to forward data on a pipelined architecture.
SIMULATION_CONFIGURATION_SOLVE_BRANCH_ON_DECODE=Solve branches on decode
SIMULATION_CONFIGURATION_SOLVE_BRANCH_ON_DECODE_TOOLTIP=Allows to solve branches on decode. This only works on architectures with multiple steps.
SIMULATION_CONFIGURATION_ENABLE_DELAY_SLOTS=Use delay slots
SIMULATION_CONFIGURATION_ENABLE_DELAY_SLOTS_TOOLTIP=Enable delay slots.\n\nIf this option is enabled, the instruction right after an non-compact transfer control instruction will be always executed.
SIMULATION_CONFIGURATION_SYSTEM_CALLS_TAB=System calls
SIMULATION_CONFIGURATION_SYSTEM_CALLS_TAB_LOAD_BUNDLE=Load bundle
SIMULATION_CONFIGURATION_SYSTEM_CALLS_TAB_PROPERTIES=Call properties
SIMULATION_CONFIGURATION_CACHES_TAB=Caches
SIMULATION_CONFIGURATION_CACHES_TAB_PROPERTIES=Cache properties
SIMULATION_CONFIGURATION_CACHES_TAB_INFO=Cache info
SIMULATION_CONFIGURATION_CACHES_TAB_SIZE=Cache size:

MIPS_ELEMENT_COMMENT=Comment
MIPS_ELEMENT_LABEL=Label
MIPS_ELEMENT_GLOBAL_LABEL=Globla label
MIPS_ELEMENT_DIRECTIVE=Directive
MIPS_ELEMENT_DIRECTIVE_PARAMETER=Directive parameter
MIPS_ELEMENT_INSTRUCTION=Instruction
MIPS_ELEMENT_PSEUDOINSTRUCTION=Pseudoinstruction
MIPS_ELEMENT_INSTRUCTION_PARAMETER_REGISTER=Register
MIPS_ELEMENT_INSTRUCTION_PARAMETER_IMMEDIATE=Immediate
MIPS_ELEMENT_INSTRUCTION_PARAMETER_STRING=String
MIPS_ELEMENT_INSTRUCTION_PARAMETER_LABEL=Label reference
MIPS_ELEMENT_INSTRUCTION_PARAMETER_GLOBAL_LABEL=Global label reference
MIPS_ELEMENT_MACRO_CALL=Macro call
MIPS_ELEMENT_MACRO_CALL_PARAMETER=Macro call parameter
MIPS_ELEMENT_ERRORS=Errors:
MIPS_ELEMENT_WARNINGS=Warnings:

SYSCALL_RUN_EXCEPTION_HANDLER=X Run exception handler

SYSCALL_PRINT_INTEGER=SPIM 1 Print integer
SYSCALL_PRINT_INTEGER_PROPERTY_PRINT_HEX=Print hex number
SYSCALL_PRINT_INTEGER_PROPERTY_LINE_JUMP=Add line jump
SYSCALL_PRINT_INTEGER_PROPERTY_REGISTER=Register

SYSCALL_PRINT_FLOAT=SPIM 2 Print float
SYSCALL_PRINT_FLOAT_PROPERTY_PRINT_HEX=Print hex number
SYSCALL_PRINT_FLOAT_PROPERTY_LINE_JUMP=Add line jump
SYSCALL_PRINT_FLOAT_PROPERTY_REGISTER=Register

SYSCALL_PRINT_DOUBLE=SPIM 3 Print double
SYSCALL_PRINT_DOUBLE_PROPERTY_PRINT_HEX=Print hex number
SYSCALL_PRINT_DOUBLE_PROPERTY_LINE_JUMP=Add line jump
SYSCALL_PRINT_DOUBLE_PROPERTY_REGISTER=Register

SYSCALL_PRINT_STRING=SPIM 4 Print string
SYSCALL_PRINT_STRING_PROPERTY_LINE_JUMP=Add line jump
SYSCALL_PRINT_STRING_PROPERTY_MAX_CHARACTERS=Max characters
SYSCALL_PRINT_STRING_PROPERTY_REGISTER=Register

SYSCALL_READ_INTEGER=SPIM 5 Read integer
SYSCALL_READ_INTEGER_PROPERTY_LINE_JUMP=Add line jump
SYSCALL_READ_INTEGER_PROPERTY_REGISTER=Register

SYSCALL_READ_FLOAT=SPIM 6 Read float
SYSCALL_READ_FLOAT_PROPERTY_LINE_JUMP=Add line jump
SYSCALL_READ_FLOAT_PROPERTY_REGISTER=Register

SYSCALL_READ_DOUBLE=SPIM 7 Read double
SYSCALL_READ_DOUBLE_PROPERTY_LINE_JUMP=Add line jump
SYSCALL_READ_DOUBLE_PROPERTY_REGISTER=Register

SYSCALL_READ_STRING=SPIM 8 Read string
SYSCALL_READ_STRING_PROPERTY_LINE_JUMP=Add line jump
SYSCALL_READ_STRING_PROPERTY_ADDRESS_REGISTER=Address register
SYSCALL_READ_STRING_PROPERTY_MAX_CHARS_REGISTER=Max chars register

SYSCALL_ALLOCATE_MEMORY=SPIM 9 Allocate memory
SYSCALL_ALLOCATE_MEMORY_PROPERTY_AMOUNT_REGISTER=Amount register
SYSCALL_ALLOCATE_MEMORY_PROPERTY_ADDRESS_REGISTER=Address register

SYSCALL_EXIT=SPIM 10 Exit

SYSCALL_PRINT_CHARACTER=SPIM 11 Print char
SYSCALL_PRINT_CHARACTER_PROPERTY_LINE_JUMP=Add line jump
SYSCALL_PRINT_CHARACTER_PROPERTY_REGISTER=Register

SYSCALL_READ_CHARACTER=SPIM 12 Read char
SYSCALL_READ_CHARACTER_PROPERTY_LINE_JUMP=Add line jump
SYSCALL_READ_CHARACTER_PROPERTY_REGISTER=Register

SYSCALL_OPEN_FILE=SPIM 13 Open file
SYSCALL_OPEN_FILE_PROPERTY_NAME_REGISTER=Name register
SYSCALL_OPEN_FILE_PROPERTY_FLAG_REGISTER=Flag register
SYSCALL_OPEN_FILE_PROPERTY_MODE_REGISTER=Mode register
SYSCALL_OPEN_FILE_PROPERTY_RESULT_REGISTER=Result register

SYSCALL_READ_FILE=SPIM 14 Read from file
SYSCALL_READ_FILE_PROPERTY_ID_REGISTER=Id register
SYSCALL_READ_FILE_PROPERTY_ADDRESS_REGISTER=Address register
SYSCALL_READ_FILE_PROPERTY_MAX_BYTES_REGISTER=Max bytes register
SYSCALL_READ_FILE_PROPERTY_RESULT_REGISTER=Result register

SYSCALL_WRITE_FILE=SPIM 15 Write to file
SYSCALL_WRITE_FILE_PROPERTY_ID_REGISTER=Id register
SYSCALL_WRITE_FILE_PROPERTY_ADDRESS_REGISTER=Address register
SYSCALL_WRITE_FILE_PROPERTY_AMOUNT_REGISTER=Amount register
SYSCALL_WRITE_FILE_PROPERTY_RESULT_REGISTER=Result register

SYSCALL_CLOSE_FILE=SPIM 16 Close file
SYSCALL_CLOSE_FILE_PROPERTY_ID_REGISTER=Id register

SYSCALL_EXIT_WITH_VALUE=SPIM 17 Exit with value
SYSCALL_EXIT_WITH_VALUE_PROPERTY_REGISTER=Register

SYSCALL_SYSTEM_TIME=MARS 30 System time
SYSCALL_SYSTEM_TIME_PROPERTY_LOW_REGISTER=Low value register
SYSCALL_SYSTEM_TIME_PROPERTY_HIGH_REGISTER=High value register

SYSCALL_SLEEP=MARS 32 Sleep
SYSCALL_SLEEP_PROPERTY_REGISTER=Register

SYSCALL_PRINT_HEXADECIMAL_INTEGER=MARS 34 Print hexadecimal integer
SYSCALL_PRINT_HEXADECIMAL_INTEGER_PROPERTY_LINE_JUMP=Add line jump
SYSCALL_PRINT_HEXADECIMAL_INTEGER_PROPERTY_REGISTER=Register

SYSCALL_PRINT_BINARY_INTEGER=MARS 35 Print binary integer
SYSCALL_PRINT_BINARY_INTEGER_PROPERTY_LINE_JUMP=Add line jump
SYSCALL_PRINT_BINARY_INTEGER_PROPERTY_REGISTER=Register

SYSCALL_PRINT_UNSIGNED_INTEGER=MARS 36 Print unsigned integer
SYSCALL_PRINT_UNSIGNED_INTEGER_PROPERTY_LINE_JUMP=Add line jump
SYSCALL_PRINT_UNSIGNED_INTEGER_PROPERTY_REGISTER=Register

SYSCALL_SET_SEED=MARS 40 Set seed
SYSCALL_SET_SEED_PROPERTY_GENERATOR_REGISTER=Generator register
SYSCALL_SET_SEED_PROPERTY_SEED_REGISTER=Seed register

SYSCALL_RANDOM_INTEGER=MARS 41 Random integer
SYSCALL_RANDOM_INTEGER_PROPERTY_GENERATOR_REGISTER=Generator register
SYSCALL_RANDOM_INTEGER_PROPERTY_VALUE_REGISTER=Value register

SYSCALL_RANDOM_RANGED_INTEGER=MARS 42 Random ranged integer
SYSCALL_RANDOM_RANGED_INTEGER_PROPERTY_GENERATOR_REGISTER=Generator register
SYSCALL_RANDOM_RANGED_INTEGER_PROPERTY_RANGE_REGISTER=Range register
SYSCALL_RANDOM_RANGED_INTEGER_PROPERTY_VALUE_REGISTER=Value register

SYSCALL_RANDOM_FLOAT=MARS 43 Random float
SYSCALL_RANDOM_FLOAT_PROPERTY_GENERATOR_REGISTER=Generator register
SYSCALL_RANDOM_FLOAT_PROPERTY_VALUE_REGISTER=Value register

SYSCALL_RANDOM_DOUBLE=MARS 44 Random double
SYSCALL_RANDOM_DOUBLE_PROPERTY_GENERATOR_REGISTER=Generator register
SYSCALL_RANDOM_DOUBLE_PROPERTY_VALUE_REGISTER=Value register

CACHE_DIRECT=Direct mapping
CACHE_DIRECT_PROPERTY_WRITE_BACK=Write-back mode
CACHE_DIRECT_PROPERTY_BLOCK_SIZE=Block size (words)
CACHE_DIRECT_PROPERTY_BLOCKS_AMOUNT=Blocks

CACHE_ASSOCIATIVE=Associative mapping
CACHE_ASSOCIATIVE_PROPERTY_WRITE_BACK=Write-back mode
CACHE_ASSOCIATIVE_PROPERTY_BLOCK_SIZE=Block size (words)
CACHE_ASSOCIATIVE_PROPERTY_BLOCKS_AMOUNT=Blocks
CACHE_ASSOCIATIVE_PROPERTY_REPLACEMENT_POLICY=Replacement policy

CACHE_SET_ASSOCIATIVE=Set-associative mapping
CACHE_SET_ASSOCIATIVE_PROPERTY_WRITE_BACK=Write-back mode
CACHE_SET_ASSOCIATIVE_PROPERTY_BLOCK_SIZE=Block size (words)
CACHE_SET_ASSOCIATIVE_PROPERTY_BLOCKS_AMOUNT=Blocks
CACHE_SET_ASSOCIATIVE_PROPERTY_SET_SIZE=Set size
CACHE_SET_ASSOCIATIVE_PROPERTY_REPLACEMENT_POLICY=Replacement policy

SIMULATION_BUTTON_TOOLTIP_EXECUTE_ALL=Execute all instructions
SIMULATION_BUTTON_TOOLTIP_STOP=Stop
SIMULATION_BUTTON_TOOLTIP_EXECUTE_ONE=Execute one step
SIMULATION_BUTTON_TOOLTIP_UNDO=Undo one step
SIMULATION_BUTTON_TOOLTIP_RESET=Reset

SIMULATION_INSTRUCTION_VIEWER_DISASSEMBLED=Disasembled
SIMULATION_INSTRUCTION_VIEWER_ORIGINAL=Original
SIMULATION_INSTRUCTION_VIEWER_HEXADECIMAL=Hexadecimal

BAR_REGISTERS_NAME=Registers
BAR_MEMORY_NAME=Memory
BAR_FLOW_NAME=Flow
BAR_CONSOLE_NAME=Console
BAR_LABELS_NAME=Labels
BAR_LAB_NAME=Lab
BAR_CACHES_NAME=Caches

INSTRUCTIONS_USER=Text
INSTRUCTIONS_KERNEL=Kernel

INSTRUCTIONS_BREAKPOINT=Brk.
INSTRUCTIONS_ADDRESS=Address
INSTRUCTIONS_CODE=Code
INSTRUCTIONS_INSTRUCTION=Instruction
INSTRUCTIONS_ORIGINAL=Original

REGISTERS_GENERAL=General
REGISTERS_COP0=COP0
REGISTERS_COP1=COP1
REGISTERS_ID=Id
REGISTERS_SELECTION=Sel
REGISTERS_NAME=Name
REGISTERS_VALUE=Value
REGISTERS_HEX=Hex

MEMORY_ADDRESS=Address
MEMORY_MEMORY=Memory
MEMORY_CACHE_TAG=Tag: {TAG}
MEMORY_CACHE_BLOCK=Block: {BLOCK}

LABELS_ADDRESS=Address: {ADDRESS}
LABELS_LINE=Line: {LINE}
LABELS_REFERENCES=References

LAB_SOFTWARE_INTERRUPTS=Software interrupts
LAB_HARDWARE_INTERRUPTS=Hardware interrupts
LAB_COUNTER=Counter
LAB_COUNTER_RESET=Reset
LAB_INTERRUPT=Interrupt

CACHE_HITS=Hits
CACHE_MISSES=Misses
CACHE_STATS=Stats
CACHE_STATS_OPERATIONS=Operations:
CACHE_STATS_HITS=Hits:
CACHE_STATS_MISSES=Misses:
CACHE_RESET=Reset caches
CACHE_LOG=Log
CACHE_LOG_HIT=Operation {OPERATION}. Hit.
CACHE_LOG_MISS=Operation {OPERATION}. Miss.
CACHE_LOG_INDEX=Index {INDEX} ({TAG})
CACHE_LOG_CLEAR=Clear log
CACHE_LOG_CLEAR_ALL=Clear all logs

FLOW_CYCLE=Cycle: {CYCLE}

TASK_ASSEMBLING=Assembling...

CONFIG=Configuration

CONFIG_ACTION=Actions
CONFIG_ACTION_SEARCH=Search...
CONFIG_ACTION_BIND_TITLE=Bind combination to action
CONFIG_ACTION_BIND_ENTER=Press the combination of keys to bind
CONFIG_ACTION_BIND_CONFIRM=The following actions will be unbind from the given combination:
CONFIG_ACTION_BIND_CONFIRM_2=Do you want to continue?
CONFIG_ACTION_UNBIND=Are you sure you want to unbind this combination?

CONFIG_PLUGIN=Plugins
CONFIG_PLUGIN_INSTALL=Install
CONFIG_PLUGIN_UNINSTALL=Unistall
CONFIG_PLUGIN_UNINSTALL_CONFIRM=Are you sure you want to unistall the plugin {PLUGIN}?

CONFIG_APPEARANCE=Appearance
CONFIG_APPEARANCE_REGION_THEME=Theme
CONFIG_APPEARANCE_REGION_TWEAKS=Tweaks
CONFIG_APPEARANCE_THEME=Theme:
CONFIG_APPEARANCE_THEME_TOOLTIP=Themes changes the whole appearance of the application.
CONFIG_APPEARANCE_GENERAL_FONT=General font:
CONFIG_APPEARANCE_GENERAL_FONT_TOOLTIP=This font is used on all JAMS except text editors.
CONFIG_APPEARANCE_CODE_FONT=Editor font:
CONFIG_APPEARANCE_CODE_FONT_TOOLTIP=This font is used on text editors.
CONFIG_APPEARANCE_HIDE_TOP_BAR=Hide top bar\t(Windows only, requires restart)
CONFIG_APPEARANCE_HIDE_TOP_BAR_TOOLTIP=This option integrates the main window's bar into the taskbar.
CONFIG_APPEARANCE_ANTIALIASING=Antialiasing\t(Requires restart)
CONFIG_APPEARANCE_ANTIALIASING_TOOLTIP=Enables the antialiasing in all scenes.

CONFIG_EDITOR=Editor
CONFIG_EDITOR_REGION_MOUSE_CONTROL=Mouse control
CONFIG_EDITOR_ZOOM_USING_MOUSE_WHEEL=Zoom with Shortcut+Mouse Wheel
CONFIG_EDITOR_ZOOM_USING_MOUSE_WHEEL_TOOLTIP=If this option is enable you can zoom using the mouse wheel while pressing the Shortcut key.
CONFIG_EDITOR_RESET_ZOOM_USING_MIDDLE_BUTTON=Reset zoom with Shortcut+Mouse Middle Button
CONFIG_EDITOR_RESET_ZOOM_USING_MIDDLE_BUTTON_TOOLTIP=If this option is enable you can reset the zoom using the mouse middle button while pressing the Shortcut key.
CONFIG_EDITOR_RESET_ZOOM_SENSIBILITY=Zoom sensibility:
CONFIG_EDITOR_RESET_ZOOM_SENSIBILITY_TOOLTIP=This option configures the zoom made in each wheel scroll.\n\nRemember that the default zoom value is '1' and the 2x zoom value is '2'.

CONFIG_EDITOR_MIPS=MIPS
CONFIG_EDITOR_MIPS_REGION_TABS=Tabs
CONFIG_EDITOR_MIPS_REGION_SPACES=Spaces
CONFIG_EDITOR_MIPS_REGION_BLANK_LINES=Blank lines
CONFIG_EDITOR_MIPS_USE_TABS=Use tabs character
CONFIG_EDITOR_MIPS_USE_TABS_TOOLTIP=If this option is enabled JAMS will use TABs instead of spaces on the code editor.
CONFIG_EDITOR_MIPS_PRESERVE_TABS=Preserve tabs after the label
CONFIG_EDITOR_MIPS_PRESERVE_TABS_TOOLTIP=This option sets whether tabs added by the user between the label and the instruction / directive should be preserved when formatting.
CONFIG_EDITOR_MIPS_PRESERVE_TABS_BEFORE_LABELS=Preserve tabs before the label
CONFIG_EDITOR_MIPS_PRESERVE_TABS_BEFORE_LABELS_TOOLTIP=This option sets whether tabs added before labels should be preserved when formatting.
CONFIG_EDITOR_MIPS_SPACE_AFTER_INSTRUCTION=After instruction:
CONFIG_EDITOR_MIPS_SPACE_AFTER_INSTRUCTION_TOOLTIP=This option tells JAMS what to add after an instruction.
CONFIG_EDITOR_MIPS_SPACE_AFTER_INSTRUCTION_PARAMETER=After instruction parameter:
CONFIG_EDITOR_MIPS_SPACE_AFTER_INSTRUCTION_PARAMETER_TOOLTIP=This option tells JAMS what to add after an instruction's parameter.
CONFIG_EDITOR_MIPS_SPACE_AFTER_DIRECTIVE=After directive:
CONFIG_EDITOR_MIPS_SPACE_AFTER_DIRECTIVE_TOOLTIP=This option tells JAMS what to add after a directive.
CONFIG_EDITOR_MIPS_SPACE_AFTER_DIRECTIVE_PARAMETER=After directive parameter:
CONFIG_EDITOR_MIPS_SPACE_AFTER_DIRECTIVE_PARAMETER_TOOLTIP=This option tells JAMS what to add after a directive's parameter.
CONFIG_EDITOR_MIPS_MAXIMUM_BLANK_LINES=Maximum blank lines:
CONFIG_EDITOR_MIPS_MAXIMUM_BLANK_LINES_TOOLTIP=The maximum amount of blank lines JAMS will keep on formatting.

CONFIG_EXPLORER=Explorer
CONFIG_EXPLORER_REGION_SIZE=Size
CONFIG_EXPLORER_SECTION_SEPARATOR_WIDTH=Width per hierarchy level for sections:
CONFIG_EXPLORER_SECTION_SEPARATOR_WIDTH_TOOLTIP=Represents the width that a section will shift per hierarchy level
CONFIG_EXPLORER_ELEMENT_SEPARATOR_WIDTH=Width per hierarchy level for elements:
CONFIG_EXPLORER_ELEMENT_SEPARATOR_WIDTH_TOOLTIP=Represents the width that an element will shift per hierarchy level
CONFIG_EXPLORER_MIPS=MIPS
CONFIG_EXPLORER_MIPS_REGION_CREATION=Creation
CONFIG_EXPLORER_MIPS_ADD_CREATED_ASM_FILES_TO_ASSEMBLE=Add created asm files to assemble automatically
CONFIG_EXPLORER_MIPS_ADD_CREATED_ASM_FILES_TO_ASSEMBLE_TOOLTIP=Assembly files will be added automatically into the assembly list if this option is enabled.\n\nThis option can be changed when you create an assembly file.

CONFIG_LANGUAGE=Language
CONFIG_LANGUAGE_REGION_LANGUAGE=Language
CONFIG_LANGUAGE_DEFAULT=Fallback language:
CONFIG_LANGUAGE_DEFAULT_TOOLTIP=This language will be used when the selected language doesn't have the required message.\n\nThis language is the English language by default.
CONFIG_LANGUAGE_SELECTED=Selected language:
CONFIG_LANGUAGE_SELECTED_TOOLTIP=This language will be used by JAMS to show all its messages.

CONFIG_SIMULATION=Simulation
CONFIG_SIMULATION_MIPS=MIPS
CONFIG_SIMULATION_REGION_ASSEMBLY=Assembly
CONFIG_SIMULATION_OPEN_LOG_ON_ASSEMBLE=Open log pane when assembling.
CONFIG_SIMULATION_REGION_MEMORY=Memory
CONFIG_SIMULATION_MEMORY_ROWS=Rows:
CONFIG_SIMULATION_MEMORY_ROWS_TOOLTIP=The amount of rows the memory display can show at the same time.
CONFIG_SIMULATION_MIPS_REGION_FLOW=Flow
CONFIG_SIMULATION_MIPS_FLOW_MAX_ITEMS=Maximum entries:
CONFIG_SIMULATION_MIPS_FLOW_MAX_ITEMS_TOOLTIP=The maximum amount of entries the flow pane can hold at the same time.
CONFIG_SIMULATION_MIPS_REGION_INSTRUCTIONS=Instruction viewer
CONFIG_SIMULATION_MIPS_INSTRUCTIONS_VIEWER_ELEMENTS_ORDER=Viewer's elements order:
CONFIG_SIMULATION_MIPS_INSTRUCTIONS_VIEWER_ELEMENTS_ORDER_TOOLTIP=In this panel you can change the order of the elements in the instruction viewer.
CONFIG_SIMULATION_MIPS_INSTRUCTIONS_VIEWER_ELEMENTS_ORDER_USING=Using:
CONFIG_SIMULATION_MIPS_INSTRUCTIONS_VIEWER_ELEMENTS_ORDER_NOT_USING=Not using:
CONFIG_SIMULATION_MIPS_INSTRUCTIONS_SHOW_LABELS=Show labels.
CONFIG_SIMULATION_MIPS_INSTRUCTIONS_SHOW_LABELS_TOOLTIP=This option allows labels to be shown in the instruction viewer.
CONFIG_SIMULATION_MIPS_REGION_LAB=Lab
CONFIG_SIMULATION_MIPS_LAB_FIRST_SEGMENT_ADDRESS=First display address:
CONFIG_SIMULATION_MIPS_LAB_FIRST_SEGMENT_ADDRESS_TOOLTIP=The address used by the first display of the lab.
CONFIG_SIMULATION_MIPS_LAB_SECOND_SEGMENT_ADDRESS=Second display address:
CONFIG_SIMULATION_MIPS_LAB_SECOND_SEGMENT_ADDRESS_TOOLTIP=The address used by the second display of the lab.
CONFIG_SIMULATION_MIPS_LAB_FIRST_HEX_KERBOARD_ADDRESS=First hex kerboard address:
CONFIG_SIMULATION_MIPS_LAB_FIRST_HEX_KERBOARD_ADDRESS_TOOLTIP=The address used by the least 8 significant numbers of the hexadeximal keyboard.
CONFIG_SIMULATION_MIPS_LAB_SECOND_HEX_KERBOARD_ADDRESS=Second hex kerboard address:
CONFIG_SIMULATION_MIPS_LAB_SECOND_HEX_KERBOARD_ADDRESS_TOOLTIP=The address used by the most 8 significant numbers of the hexadeximal keyboard.
CONFIG_SIMULATION_MIPS_LAB_COUNTER_ADDRESS=Counter address:
CONFIG_SIMULATION_MIPS_LAB_COUNTER_ADDRESS_TOOLTIP=The address used by the counter. The value in this address represents the amount of cycles the counter will wait before an interrupt.

EDITOR_MIPS_ERROR_ILLEGAL_LABEL=The label '{TEXT}' has an invalid name.
EDITOR_MIPS_ERROR_LABEL_NOT_FOUND=Couldn't find label '{NAME}'.
EDITOR_MIPS_ERROR_DUPLICATE_LABEL=Found duplicated label '{NAME}'.
EDITOR_MIPS_ERROR_DUPLICATE_GLOBAL_LABEL=Found duplicated global label '{NAME}' on file '{FILE}'.
EDITOR_MIPS_ERROR_INVALID_DIRECTIVE_PARAMETER=The parameter '{NAME}' is invalid.
EDITOR_MIPS_ERROR_INSTRUCTION_NOT_FOUND=Couldn't find instruction '{NAME}' with the given parameters.
EDITOR_MIPS_ERROR_MACRO_NOT_FOUND=Couldn't find macro '{NAME}'.
EDITOR_MIPS_ERROR_INVALID_MACRO_PARAMETERS_AMOUNT=Invalid amount of arguments for macro '{NAME}'. (Expected: {EXPECTED}. Found: {FOUND})

EDITOR_MIPS_WARNING_DIRECTIVE_NOT_FOUND=Couldn't find directive '{NAME}'.
EDITOR_MIPS_WARNING_REGISTER_USING_AT=Avoid using the register $at. Its value may change unexpectedly when a pseudoinstruction is executed.
EDITOR_MIPS_WARNING_USING_EQUIVALENT=Avoid using equivalents. Equivalents ofter make code less legible and prevents the inspector from working.

ACTION_REGION_GENERAL=General
ACTION_GENERAL_CREATE_PROJECT=Create project
ACTION_GENERAL_OPEN_PROJECT=Open project
ACTION_GENERAL_OPEN_RECENT=Open recent
ACTION_GENERAL_SETTINGS=Settings
ACTION_GENERAL_ASSEMBLE=Assemble code

ACTION_REGION_EDITOR=Editor
ACTION_EDITOR_SAVE=Save file

ACTION_REGION_TEXT_EDITOR=Text editor
ACTION_TEXT_EDITOR_REFORMAT=Reformat code
ACTION_TEXT_EDITOR_SHOW_AUTOCOMPLETION_POPUP=Show autocompletion popup
ACTION_TEXT_EDITOR_SHOW_DOCUMENTATION_POPUP=Show documentation popup
ACTION_TEXT_EDITOR_PREVIOUS_FILE=Move to the previous file
ACTION_TEXT_EDITOR_NEXT_FILE=Move to the next file
ACTION_TEXT_EDITOR_REFRESH_FROM_DISK=Refresh from disk
ACTION_TEXT_EDITOR_COPY=Copy
ACTION_TEXT_EDITOR_PASTE=Paste
ACTION_TEXT_EDITOR_CUT=Cut
ACTION_TEXT_EDITOR_UNDO=Undo
ACTION_TEXT_EDITOR_REDO=Redo
ACTION_TEXT_EDITOR_SELECT_ALL=Select all
ACTION_TEXT_EDITOR_DUPLICATE_LINE=Duplicate line
ACTION_TEXT_EDITOR_FIND=Find
ACTION_TEXT_EDITOR_REPLACE=Replace

ACTION_REGION_EXPLORER_ELEMENT=Explorer elements
ACTION_EXPLORER_ELEMENT_CONTRACT_OR_SELECT_PARENT=Contract folder / Select parent
ACTION_EXPLORER_ELEMENT_EXPAND_OR_NEXT=Expand folder / Select next
ACTION_EXPLORER_ELEMENT_SELECT_NEXT=Select next
ACTION_EXPLORER_ELEMENT_SELECT_NEXT_MULTIPLE=Select next (multi-selection)
ACTION_EXPLORER_ELEMENT_SELECT_PREVIOUS=Select previous
ACTION_EXPLORER_ELEMENT_SELECT_PREVIOUS_MULTIPLE=Select previous (multi-selection)
ACTION_EXPLORER_ELEMENT_SELECT_ALL=Select all

ACTION_REGION_FOLDER_EXPLORER_ELEMENT=Folder explorer elements
ACTION_FOLDER_EXPLORER_ELEMENT_RENAME=Rename
ACTION_FOLDER_EXPLORER_ELEMENT_DELETE=Delete
ACTION_FOLDER_EXPLORER_ELEMENT_PASTE=Paste
ACTION_FOLDER_EXPLORER_ELEMENT_PASTE_ALREADY_EXIST=Enter a new name.
ACTION_FOLDER_EXPLORER_ELEMENT_COPY=Copy
ACTION_FOLDER_EXPLORER_ELEMENT_SHOW_IN_FILES=Show in files
ACTION_FOLDER_EXPLORER_ELEMENT_NEW=New
ACTION_FOLDER_EXPLORER_ELEMENT_NEW_FILE=File
ACTION_FOLDER_EXPLORER_ELEMENT_NEW_ASSEMBLY_FILE=Assembly file
ACTION_FOLDER_EXPLORER_ELEMENT_NEW_FOLDER=Folder
ACTION_FOLDER_EXPLORER_ELEMENT_ADD_FILE_TO_ASSEMBLER=Add file to the assembler
ACTION_FOLDER_EXPLORER_ELEMENT_ADD_ALL_FILES_TO_ASSEMBLER=Add assembly files to the assembler
ACTION_FOLDER_EXPLORER_ELEMENT_REMOVE_FILE_FROM_ASSEMBLER=Remove file from the assembler
ACTION_FOLDER_EXPLORER_ELEMENT_REMOVE_ALL_FILES_FROM_ASSEMBLER=Remove files from the assembler

ACTION_REGION_EDITOR_TAB=Editor tab
ACTION_EDITOR_TAB_SPLIT_HORIZONTALLY=Split horizontally
ACTION_EDITOR_TAB_SPLIT_VERTICALLY=Split vertically

ACTION_REGION_FILES_TO_ASSEMBLE=Files to assemble
ACTION_FILES_TO_ASSEMBLE_REMOVE=Remover from assembler

ACTION_REGION_MIPS_SIMULATION=MIPS Simulation
ACTION_MIPS_SIMULATION_EXECUTE_ALL_INSTRUCTIONS=Execute all instructions
ACTION_MIPS_SIMULATION_EXECUTE_ONE_STEP=Execute one step
ACTION_MIPS_SIMULATION_RESET=Reset
ACTION_MIPS_SIMULATION_STOP=Stop
ACTION_MIPS_SIMULATION_UNDO_ONE_STEP=Undo one step
ACTION_MIPS_SIMULATION_CYCLE_DELAY=Delay per cycle

ACTION_REGION_MIPS_SIMULATION_LABELS_LABEL=Label table (Label)
ACTION_REGION_MIPS_SIMULATION_LABELS_REFERENCE=Label table (Reference)
ACTION_MIPS_SIMULATION_LABELS_LABEL_SHOW_IN_MEMORY=Show in memory
ACTION_MIPS_SIMULATION_LABELS_LABEL_SHOW_IN_INSTRUCTION_VIEWER=Show in instruction viewer
ACTION_MIPS_SIMULATION_LABELS_REFERENCE_SHOW_IN_MEMORY=Show in memory
ACTION_MIPS_SIMULATION_LABELS_REFERENCE_SHOW_IN_INSTRUCTION_VIEWER=Show in instruction viewer

NUMBER_FORMAT_HEXADECIMAL=Hexadecimal
NUMBER_FORMAT_DECIMAL=Decimal
NUMBER_FORMAT_OCTAL=Octal
NUMBER_FORMAT_BINARY=Binary
NUMBER_FORMAT_LONG=Long
NUMBER_FORMAT_FLOAT=Float
NUMBER_FORMAT_DOUBLE=Double
NUMBER_FORMAT_CHAR=Characters
NUMBER_FORMAT_RGB=RGB
NUMBER_FORMAT_RGBA=RGBA
NUMBER_FORMAT_ENGLISH=English text
NUMBER_FORMAT_ROMAN=Roman

//INSTRUCTIONS

INSTRUCTION_ABS_D=Absolute (double)
INSTRUCTION_ABS_S=Absolute (single)
INSTRUCTION_ADD=Addition
INSTRUCTION_ADD_D=Addition (double)
INSTRUCTION_ADDIU=Immediate addition without overflow
INSTRUCTION_ADDIUPC=Immediate addition to PC without overflow
INSTRUCTION_ADD_S=Addition (single)
INSTRUCTION_ADDU=Addition without overflow
INSTRUCTION_ALIGN=Concatenate two GRPs extracting a contiguous subset at a byte position
INSTRUCTION_ALUIPC=Aligned add upper immediate on PC
INSTRUCTION_AND=And
INSTRUCTION_ANDI=Immediate and
INSTRUCTION_AUI=Immediate addition to upper bits
INSTRUCTION_AUIPC=Immediate addition to PC upper bits
INSTRUCTION_BAL=Branch and link
INSTRUCTION_BALC=Branch and link compact
INSTRUCTION_BC=Branch compact
INSTRUCTION_BC1EQZ=Branch if COP1 register bit 0 is zero
INSTRUCTION_BC1NEZ=Branch if COP1 register bit 0 is not zero
INSTRUCTION_BEQ=Branch on equal
INSTRUCTION_BEQC=Branch on equal compact
INSTRUCTION_BEQZALC=Branch and link on equal to zero compact
INSTRUCTION_BEQZC=Branch on equal to zero compact
INSTRUCTION_BGEC=Branch on greater than or equal compact
INSTRUCTION_BGEUC=Branch on greater than or equal unsigned compact
INSTRUCTION_BGEZ=Branch on greater than or equal to zero
INSTRUCTION_BGEZALC=Branch and link on greater than or equal to zero compact
INSTRUCTION_BGEZC=Branch on greater than or equal to zero compact
INSTRUCTION_BGTZ=Branch on greater than zero
INSTRUCTION_BGTZALC=Branch and link on greater than zero compact
INSTRUCTION_BGTZC=Branch on greater than zero compact
INSTRUCTION_BITSWAP=Swap bits in each byte
INSTRUCTION_BLEZ=Branch on less than or equal to zero
INSTRUCTION_BLEZALC=Branch and link on less than or equal to zero compact
INSTRUCTION_BLEZC=Branch on less than or equal to zero compact
INSTRUCTION_BLTC=Branch on less than compact
INSTRUCTION_BLTUC=Branch on less than unsigned compact
INSTRUCTION_BLTZ=Branch on less than zero
INSTRUCTION_BLTZALC=Branch and link on less than zero compact
INSTRUCTION_BLTZC=Branch on less than zero compact
INSTRUCTION_BNE=Branch on not equal
INSTRUCTION_BNEC=Branch on not equal compact
INSTRUCTION_BNEZALC=Branch and link on not equal to zero compact
INSTRUCTION_BNEZC=Branch on not equal to zero compact
INSTRUCTION_BNVC=Branch on no overflow compact
INSTRUCTION_BOVC=Branch on overflow compact
INSTRUCTION_BREAK=Breakpoint
INSTRUCTION_CEIL_L_D=Ceiling double to long
INSTRUCTION_CEIL_L_S=Ceiling single to long
INSTRUCTION_CEIL_W_D=Ceiling double to word
INSTRUCTION_CEIL_W_S=Ceiling single to word
INSTRUCTION_CLO=Count leading ones in word
INSTRUCTION_CLZ=Count leading zeros in word
INSTRUCTION_CMP_D=Floating point compare ({TYPE}) (double)
INSTRUCTION_CMP_S=Floating point compare ({TYPE}) (single)
INSTRUCTION_CVT=Convert from {FROM} to {TO}
INSTRUCTION_DIV=Division
INSTRUCTION_DIV_D=Division (double)
INSTRUCTION_DIV_S=Division (single)
INSTRUCTION_DIVU=Unsigned division
INSTRUCTION_ERET=Exception return
INSTRUCTION_J=Jump
INSTRUCTION_JAL=Jump and link
INSTRUCTION_JALR=Jump and link register
INSTRUCTION_LB=Load byte
INSTRUCTION_LW=Load word
INSTRUCTION_MFC0=Move from coprocessor 0
INSTRUCTION_MFC1=Move from coprocessor 1
INSTRUCTION_MOD=Modulo
INSTRUCTION_MODU=Unsigned module
INSTRUCTION_MFC0=Move to coprocessor 0
INSTRUCTION_MFC1=Move to coprocessor 1
INSTRUCTION_MUH=Multiplication and return high word
INSTRUCTION_MUHU=Unsigned multiplication and return high word
INSTRUCTION_MUL=Multiplication and return low word
INSTRUCTION_MUL_D=Multiplication (double)
INSTRUCTION_MUL_S=Multiplication (single)
INSTRUCTION_MULU=Unsigned multiplication and return low word
INSTRUCTION_OR=Or
INSTRUCTION_ORI=Immediate or
INSTRUCTION_SB=Save byte
INSTRUCTION_SLL=Shift word left logical
INSTRUCTION_SLLV=Shift word left logical variable
INSTRUCTION_SLT=Set on less than
INSTRUCTION_SLTI=Set on less than immediate
INSTRUCTION_SLTIU=Set on less than immediate unsigned
INSTRUCTION_SLTU=Set on less than unsigned
INSTRUCTION_SRL=Shift word right logical
INSTRUCTION_SRLV=Shift word right logical variable
INSTRUCTION_SUB=Subtraction
INSTRUCTION_SUB_D=Subtraction (double)
INSTRUCTION_SUB_S=Subtraction (single)
INSTRUCTION_SUBU=Subtraction without overflow
INSTRUCTION_SW=Save word
INSTRUCTION_SYSCALL=System call
INSTRUCTION_TEQ=Trap on equal
INSTRUCTION_TEQI=Trap on equal immediate
INSTRUCTION_TGE=Trap on greater or equal
INSTRUCTION_TGEI=Trap on greater or equal immediate
INSTRUCTION_TGEIU=Trap on greater or equal immediate unsigned
INSTRUCTION_TGEU=Trap on greater or equal unsigne
INSTRUCTION_TLT=Trap on less than
INSTRUCTION_TLTI=Trap on less than immediate
INSTRUCTION_TLTIU=Trap on less than immediate unsigned
INSTRUCTION_TLTU=Trap on less than unsigned
INSTRUCTION_TNE=Trap on not equal
INSTRUCTION_TNEI=Trap on not equal immediate
INSTRUCTION_XOR=Xor
INSTRUCTION_XORI=Immediate xor

//PSEUDO INSTRUCTIONS

INSTRUCTION_ADDI=Immediate addition with overflow
INSTRUCTION_B=Unconditional branch
INSTRUCTION_JR=Jump register
INSTRUCTION_LA=Load address
INSTRUCTION_LI=Load immediate
INSTRUCTION_LUI=Load upper immediate
INSTRUCTION_LIF=Load immediate float
INSTRUCTION_MOVE=Value movement
INSTRUCTION_NOP=No operation
INSTRUCTION_SGE=Set on greater than or equal
INSTRUCTION_SGEI=Set on greater than or equal immediate
INSTRUCTION_SGEIU=Set on greater than or equal immediate unsigned
INSTRUCTION_SGEU=Set on greater than or equal unsigned
INSTRUCTION_SGT=Set on greater than
INSTRUCTION_SGTI=Set on greater than immediate
INSTRUCTION_SGTIU=Set on greater than immediate unsigned
INSTRUCTION_SGTU=Set on greater than unsigned
INSTRUCTION_SLE=Set on lower than or equal
INSTRUCTION_SLEI=Set on lower than or equal immediate
INSTRUCTION_SLEIU=Set on lower than or equal immediate unsigned
INSTRUCTION_SLEU=Set on lower than or equal unsigned

//INSTRUCTIONS DOCUMENTATION

INSTRUCTION_ABS_D_DOCUMENTATION.=<u>Double precision floating point absolute value</u>

<b>Format:</b>
abs.d fd, fs

| COP1      fmt      0      fs      fd      ABS   |
|010001    10001   00000                   000101 |
|  6         5       5      5       5        6    |


<b>Description:</b>
FPR[fd] <- abs(FPR[fs])

Places the absolute value of <i>fs</i> in <i>fd</i>. The operand and result are values in double precision floating point.

<b>Restrictions:</b>
The fields <i>fs</i> and <i>fd</i> must be even FPRs. If the fields are not valid, the result is <black>UNPREDICTABLE</black>.
The operand must be a value in double precision floating point. If it is not, the result is <black>UNPREDICTABLE</black>.

<b>Operation:</b>
fmt <- double
StoreFPR(fd, fmt, AbsoluteValue(ValueFPR(fs, fmt)))

<b>Exceptions:</b>
None
\END

INSTRUCTION_ABS_S_DOCUMENTATION.=<u>Floating point absolute value</u>

<b>Format:</b>
abs.s fd, fs

| COP1      fmt      0      fs      fd      ABS   |
|010001    10000   00000                   000101 |
|  6         5       5      5       5        6    |


<b>Description:</b>
FPR[fd] <- abs(FPR[fs])

Places the absolute value of <i>fs</i> in <i>fd</i>. The operand and result are values in floating point.

<b>Restrictions:</b>
The operand must be a value in floating point. If it is not, the result is <black>UNPREDICTABLE</black>.

<b>Operation:</b>
fmt <- float
StoreFPR(fd, fmt, AbsoluteValue(ValueFPR(fs, fmt)))

<b>Exceptions:</b>
None
\END

INSTRUCTION_ADD_DOCUMENTATION.=<u>Addition</u>

<b>Format:</b>
add rd, rs, rt

|SPECIAL     rs      rt     rd      0       ADD   |
|000000                                    100000 |
|  6         5       5      5       5        6    |


<b>Description:</b>
GPR[rd] <- GPR[rs] + GPR[rt]

The 32-bit word value in GPR <i>rt</i> is added to the 32-bit value in GPR <i>rs</i> to produce a 32-bit result.
 - If the adition results in 32-bit 2's complement arithmetic overflow, the destination register is not modified and an <black>Integer Overflow</black> exception occurs.
 - If the addition does not overflow, the 32-bit result is placed intoto GPR <i>rd</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>
temp <- (GPR[rs]<sub>31</sub> || GPR[rs]<sub>31..0</sub>) + (GPR[rt]<sub>31</sub> || GPR[rt]<sub>31..0</sub>)
if temp<sub>32</sub> != temp<sub>31</sub> then
    SignalException(IntegerOverflow)
else
    GPR[rd] <- temp<sub>31..0</sub>
endif

<b>Exceptions:</b>
Integer Overflow

<b>Programming Notes:</b>
<black>addu</black> performs the same arithmetic operation but does not trap on overflow.
\END

INSTRUCTION_ADD_D_DOCUMENTATION.=<u>Double precision floating point addition</u>

<b>Format:</b>
add.d fd, fs, ft

| COP1      fmt      0      fs      fd      ADD   |
|010001    10001   00000                   000000 |
|  6         5       5      5       5        6    |


<b>Description:</b>
FPR[fd] <- FPR[fs] + FPR[ft]

The value in FPR <i>ft</i> is added to the value in FPR <i>fs</i>. The result is calculated to infinite precision, rounded using the <i>Java</i> rounding mode, and placed into FPR <i>fd</i>.
The operands and result are values in double precision floating point.

<b>Restrictions:</b>
The fields <i>fs</i>, <i>ft</i> and <i>fd</i> must be even FPRs. If the fields are not valid, the result is <black>UNPREDICTABLE</black>.
The operand must be a value in double precision floating point. If it is not, the result is <black>UNPREDICTABLE</black>.

<b>Operation:</b>
fmt <- double
StoreFPR(fd, fmt, ValueFPR(fs, fmt) +<sub>fmt</sub> ValueFPR(ft, fmt))

<b>Exceptions:</b>
None
\END

INSTRUCTION_ADD_S_DOCUMENTATION.=<u>Floating point addition</u>

<b>Format:</b>
add.s fd, fs, ft

| COP1      fmt      0      fs      fd      ADD   |
|010001    10000   00000                   000000 |
|  6         5       5      5       5        6    |


<b>Description:</b>
FPR[fd] <- FPR[fs] + FPR[ft]

The value in FPR <i>ft</i> is added to the value in FPR <i>fs</i>. The result is calculated to infinite precision, rounded using the <i>Java</i> rounding mode, and placed into FPR <i>fd</i>.
The operands and result are values in floating point.

<b>Restrictions:</b>
The operand must be a value in floating point. If it is not, the result is <black>UNPREDICTABLE</black>.

<b>Operation:</b>
fmt <- float
StoreFPR(fd, fmt, ValueFPR(fs, fmt) +<sub>fmt</sub> ValueFPR(ft, fmt))

<b>Exceptions:</b>
None
\END

INSTRUCTION_ADDIU_DOCUMENTATION.=<u>Immediate unsigned addition</u>

<b>Format:</b>
addiu rt, rs, immediate

| ADDIU      rs     rt     immediate |
|001001                              |
|  6         5      5         16     |


<b>Description:</b>
GPR[rt] <- GPR[rs] + immediate

The 16-bit signed <i>immediate</i> is added to the 32-bit value in GRP <i>rs</i> and the 32-bit arithmetic result is placed into GPR <i>rt</i>.
No <black>Integer Overflow</black> exception occurs under any circumstances.

<b>Restrictions:</b>
None

<b>Operation:</b>
temp <- GPR[rs] + sign_extend(immediate)
GPR[rt] <- temp

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
The term <i>unsigned</i> in the instruction name is a misnomer; this operation is a 32-bit modulo arithmetic that does not trap on overflow. This instruction is appropiate for unsigned arithmetic, such as address arithmetic, or integer arithmetic environments that ignore overflow, such as the C language arithmetic.
\END

INSTRUCTION_ADDIUPC_DOCUMENTATION.=<u>Immediate unsigned addition to PC</u>

<b>Format:</b>
addiupc rs, immediate

| PCREL      rs   ADDIUPC   immediate |
|111011              00               |
|  6         5       2         19     |


<b>Description:</b>
GPR[rs] <- PC + sign_extend(immediate << 2)

This instruction performs a PC-relative address calculation. The 19-bit <i>immediate</i> is shifted left by 2 bits, sign-extended and added to the address of the instruction.
The result is placed into GPR <i>rs</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>
GPR[rs] <- PC + sign_extend(immediate << 2)

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
The term <i>unsigned</i> in the instruction name is a misnomer. <i>Unsigned</i> here means <i>non-trapping</i>. It does not trap on a signed 32-bit overflow. <black>addiupc</black> corresponds to unsigned <black>addiu</black>, which does not trap on overflow.
\END

INSTRUCTION_ADDU_DOCUMENTATION.=<u>Unsigned addition</u>

<b>Format:</b>
addu rd, rs, rt

|SPECIAL     rs      rt     rd      0       ADDU  |
|000000                                    100001 |
|  6         5       5      5       5        6    |


<b>Description:</b>
GPR[rd] <- GPR[rs] + GPR[rt]

The 32-bit word value in GPR <i>rt</i> is added to the 32-bit value in GPR <i>rs</i> to produce a 32-bit result.
The 32-bit result is placed into GPR <i>rd</i>.
No <black>Integer Overflow</black> exception occurs under any circumstances.

<b>Restrictions:</b>
None

<b>Operation:</b>
temp <- GPR[rs] + GPR[rt]
GPR[rd] <- temp

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
The term <i>unsigned</i> in the instruction name is a misnomer; this operation is a 32-bit modulo arithmetic that does not trap on overflow. This instruction is appropiate for unsigned arithmetic, such as address arithmetic, or integer arithmetic environments that ignore overflow, such as the C language arithmetic.
\END

INSTRUCTION_ALIGN_DOCUMENTATION.=<u>Concatenate two GRPs extracting a contiguous subset at a byte position</u>

<b>Format:</b>
align rd, rs, rt, bp

|SPECIAL3    rs    rt    rd    ALIGN   bp   BSGFL  |
| 011111                        010         100000 |
|   6        5     5     5       3     2      6    |


<b>Description:</b>
GPR[rd] <- (GPR[rt] << 8 * bp) or (GPR[rs] >> 8 * (4 - bp))

The input registers GPR <i>rt</i> and GPR <i>rs</i> are concatenated, and a register width contiguous subset is extracted, which is specified by the byte pointer <i>bp</i>.
The <black>align</black> instruction operates on 32-bit words, and has a 2-bit byte position field <i>bp</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>
tmp_rt_hi <- unsigned_word(GPR[rt]) << 8 * bp
tmp_rs_lo <- unsigned_word(GPR[rs]) >> 8 * (4 - bp)
GPR[rd] <- tmp_rt_hi or tmp_rs_lo

<b>Exceptions:</b>
None
\END

INSTRUCTION_ALUIPC_DOCUMENTATION.=<u>Aligned add upper immediate on PC</u>

<b>Format:</b>
aluipc rs, immediate

| PCREL     rs     ALUIPC   immediate |
|111011            11111              |
|  6        5        5         16     |


<b>Description:</b>
GPR[rs] <- not 0x0FFFF and PC + sign_extend(immediate << 16)

This instruction performs a PC-relative address calculation. The 16-bit <i>immediate</i> is shifted left by 16 bits, sign-extended and added to the address of the instruction.
The low 16 bits of the result are cleard. The result is placed into GPR <i>rs</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>
GPR[rs] <- not 0x0FFFF and PC + sign_extend(immediate << 16)

<b>Exceptions:</b>
None
\END

INSTRUCTION_AND_DOCUMENTATION.=<u>And</u>

<b>Format:</b>
and rd, rs, rt

|SPECIAL     rs      rt     rd      0       AND   |
|000000                                    100100 |
|  6         5       5      5       5        6    |


<b>Description:</b>
GPR[rd] <- GPR[rs] and GPR[rt]

Performs a bitwise logical AND using the values inside GPR <i>rs</i> and GPR <i>rt</i>.
The result is placed into GPR <i>rd</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>
GPR[rd] <- GPR[rs] and GPR[rt]

<b>Exceptions:</b>
None
\END

INSTRUCTION_ANDI_DOCUMENTATION.=<u>Immediate and</u>

<b>Format:</b>
andi rt, rs, immediate

| ANDI      rs     rt     immediate |
|001100                             |
|  6        5      5         16     |


<b>Description:</b>
GPR[rt] <- GPR[rs] and zero_extend(immediate)

The 16-bit <i>immediate</i> is zero-extended to the left and combined with the value of GPR <i>rs</i> in a bitwise logical AND operation.
The result is placed into GPR <i>rt</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>
GPR[rt] <- GPR[rs] and zero_extend(immediate)

<b>Exceptions:</b>
None
\END

INSTRUCTION_AUI_DOCUMENTATION.=<u>Add immediate to upper bits</u>

<b>Format:</b>
aui rt, rs, immediate

| AUI       rs     rt     immediate |
|001111                             |
|  6        5      5         16     |


<b>Description:</b>
GPR[rt] <- GPR[rs] + sign_extend(immediate << 16)

The 16-bit <i>immediate</i> is shifted left 16 bits, sign-extended and added to the GPR <i>rs</i>.
The result is placed into GPR <i>rt</i>.
In MIPS32r6, <black>lui</black> is an assembly idiom for <black>aui</black> with <i>rs</i> = 0.

<b>Restrictions:</b>
None

<b>Operation:</b>
GPR[rt] <- GPR[rs] + sign_extend(immediate << 16)

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
<black>aui</black> can be used to synthesize large constants in situations where it is not convenient to load a large constant from memory.
\END

INSTRUCTION_AUIPC_DOCUMENTATION.=<u>Add immediate to PC upper bits</u>

<b>Format:</b>
auipc rs, immediate

| PCREL    rs    AUIPC    immediate |
|111011          11110              |
|  6       5       5         16     |


<b>Description:</b>
GPR[rs] <- PC + (immediate << 16)

This instruction performs a PC-relative address calculation. The 16-bit <i>immediate</i> is shifted left by 16 bits and added to the address of the instruction.
The result is placed into GPR <i>rs</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>
GPR[rs] <- PC + (immediate << 16)

<b>Exceptions:</b>
None
\END

INSTRUCTION_BAL_DOCUMENTATION.=<u>Branch and link</u>

<b>Format:</b>
b offset

|REGIMM      0      BAL      offset  |
|000001    00000   10001             |
|  6         5       5        16     |


<b>Description:</b>
Places the return address link in GPR <i>31</i>. The return link is the address of the instruction where the execution continues after a procedure call.
An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
<black>I:</black>
target_offset <- sign_extend(offset || 00)
GPR[31] <- PC + 4

<black>I+1:</black>
PC <- PC + target_offset

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
<black>bal</black> without a corresponding return should NOT be used to read the PC. Doing so is likely to cause a performance loss on processors with a return address predictor.
\END

INSTRUCTION_BALC_DOCUMENTATION.=<u>Branch and link compact</u>

<b>Format:</b>
balc offset

| BALC      offset  |
|111010             |
|  6         26     |


<b>Description:</b>
Places the return address link in GPR <i>31</i>. The return link is the address of the instruction where the execution continues after a procedure call.
An 28-bit signed offset (the 26-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
This instruction performs a compact branch. Compact branches don't have delay slots.

<b>Restrictions:</b>
This instruction is an unconditional, always taken, compact branch. It does not have a forbidden slot nor a delay slot.

<b>Operation:</b>
target_offset <- sign_extend(offset || 00)
GPR[31] <- PC + 4
PC <- PC + 4 + target_offset

<b>Exceptions:</b>
None
\END

INSTRUCTION_BC_DOCUMENTATION.=<u>Branch compact</u>

<b>Format:</b>
bc offset

|  BC       offset  |
|110010             |
|  6         26     |


<b>Description:</b>
A 28-bit signed offset (the 26-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
This instruction performs a compact branch. Compact branches don't have delay slots.

<b>Restrictions:</b>
This instruction is an unconditional, always taken, compact branch. It does not have a forbidden slot nor a delay slot.

<b>Operation:</b>
target_offset <- sign_extend(offset || 00)
PC <- PC + 4 + target_offset

<b>Exceptions:</b>
None
\END

INSTRUCTION_BC1EQZ_DOCUMENTATION.=<u>Branch if COP1 register bit 0 is zero</u>

<b>Format:</b>
bc1eqz ft, offset

| COP1      BC1EQZ     ft     offset  |
|010001     01001                     |
|  6          5        5        16    |


<b>Description:</b>
if FPR[ft] & 1 = 0 then branch

The condition is true if and ofly if bit 0 of the FPR <i>ft</i> is zero.
If the condition is false, the branch is not taken and execution continues with the next instruction.
An 18-bit signed offset (the 26-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
temp = ValueFPR(ft, UNINTERPRETED_WORD)
cond = temp & 1 = 0
if cond then
    <black>I:</black>
    target_PC <- PC + 4 + sign_extend(offset << 2)
    <black>I+1:</black>
    PC <- target_PC
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_BC1NEZ_DOCUMENTATION.=<u>Branch if COP1 register bit 0 is not zero</u>

<b>Format:</b>
bc1nez ft, offset

| COP1      BC1NEZ     ft     offset  |
|010001     01101                     |
|  6          5        5        16    |


<b>Description:</b>
if FPR[ft] & 1 != 0 then branch

The condition is true if and ofly if bit 0 of the FPR <i>ft</i> is not zero.
If the condition is false, the branch is not taken and execution continues with the next instruction.
An 18-bit signed offset (the 26-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
temp = ValueFPR(ft, UNINTERPRETED_WORD)
cond = temp & 1 != 0
if cond then
    <black>I:</black>
    target_PC <- PC + 4 + sign_extend(offset << 2)
    <black>I+1:</black>
    PC <- target_PC
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_BEQ_DOCUMENTATION.=<u>Branch on equal</u>

<b>Format:</b>
beq rs, rt, offset

| BEQ       rs     rt     offset  |
|000100                           |
|  6        5      5       16     |


<b>Description:</b>
if GPR[rs] = GPR[rt] then branch

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rt</i> and GPR <i>rs</i> are equal, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
<black>I:</black>
target_offset <- sign_extend(offset || 00)
condition <- GPR[rs] = GPR[rt]
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
With the 18-bit signed instruction offset, the conditional branch range is ±128KBytes. Use jump (<black>j</black>) or jump register (<black>jr</black>) to branch to addresses outside this range.
<black>beq $zero, $zero, offset</black>, expressed as <black>b offset</black>, is the assembly idiom used to denote an unconditional branch.
\END

INSTRUCTION_BGEZ_DOCUMENTATION.=<u>Branch on greater than or equal to zero</u>

<b>Format:</b>
bgez rs, offset

|REGIMM     rs    BGEZ    offset  |
|000001          00001            |
|  6        5      5        16    |


<b>Description:</b>
if GPR[rs] >= 0 then branch

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rs</i> are greater than or equal to zero, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
<black>I:</black>
target_offset <- sign_extend(offset || 00)
condition <- GPR[rs] >= 0
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
With the 18-bit signed instruction offset, the conditional branch range is ±128KBytes. Use jump (<black>j</black>) or jump register (<black>jr</black>) to branch to addresses outside this range.
\END

INSTRUCTION_BLEZALC_DOCUMENTATION.=<u>Branch and link on less than or equal to zero compact</u>

<b>Format:</b>
blezalc rt, offset

| POP06     0    rt != 0   offset  |
|000110   00000                    |
|  6        5       5        16    |


<b>Description:</b>
Compact branch and link if GPR[rt] <= 0.

Places the return address link in GPR <i>31</i>. The return link is the address of the instruction where the execution continues after a procedure call.

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rt</i> are less than or equal to zero, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

GPR <i>31</i> must not be used by the sorce register, because such instructions don't have the same effect when re-executed. The result of executing such an instruction is <black>UNPREDICTABLE</black>. This restriction permits an exception handler to resume execution by re-executing the branch when an exception occurs in the branch delay slot.

<b>Operation:</b>
<black>I:</black>
GPR[31] <- PC + 4
target_offset <- sign_extend(offset || 00)
condition <- GPR[rt] <= 0
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
With the 18-bit signed instruction offset, the conditional branch range is ±128KBytes. Use jump (<black>j</black>) or jump register (<black>jr</black>) to branch to addresses outside this range.
\END

INSTRUCTION_BGEZALC_DOCUMENTATION.=<u>Branch and link on greater than or equal to zero compact</u>

<b>Format:</b>
bgezalc rt, offset

| POP06     rs      rt     offset  |
|000110    rs = rt != 0            |
|  6        5       5        16    |


<b>Description:</b>
Compact branch and link if GPR[rt] >= 0.

Places the return address link in GPR <i>31</i>. The return link is the address of the instruction where the execution continues after a procedure call.
An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rt</i> are greater than or equal to zero, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.
GPR <i>31</i> must not be used by the sorce register, because such instructions don't have the same effect when re-executed. The result of executing such an instruction is <black>UNPREDICTABLE</black>. This restriction permits an exception handler to resume execution by re-executing the branch when an exception occurs in the branch delay slot.

<b>Operation:</b>
<black>I:</black>
GPR[31] <- PC + 4
target_offset <- sign_extend(offset || 00)
condition <- GPR[rt] >= 0
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
With the 18-bit signed instruction offset, the conditional branch range is ±128KBytes. Use jump (<black>j</black>) or jump register (<black>jr</black>) to branch to addresses outside this range.
\END

INSTRUCTION_BGTZALC_DOCUMENTATION.=<u>Branch and link on greater than zero compact</u>

<b>Format:</b>
bgtzalc rt, offset

| POP07     0    rt != 0   offset  |
|000111   00000                    |
|  6        5       5        16    |


<b>Description:</b>
Compact branch and link if GPR[rt] > 0.

Places the return address link in GPR <i>31</i>. The return link is the address of the instruction where the execution continues after a procedure call.

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rt</i> are greater than zero, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

GPR <i>31</i> must not be used by the sorce register, because such instructions don't have the same effect when re-executed. The result of executing such an instruction is <black>UNPREDICTABLE</black>. This restriction permits an exception handler to resume execution by re-executing the branch when an exception occurs in the branch delay slot.

<b>Operation:</b>
<black>I:</black>
GPR[31] <- PC + 4
target_offset <- sign_extend(offset || 00)
condition <- GPR[rt] > 0
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
With the 18-bit signed instruction offset, the conditional branch range is ±128KBytes. Use jump (<black>j</black>) or jump register (<black>jr</black>) to branch to addresses outside this range.
\END

INSTRUCTION_BLTZALC_DOCUMENTATION.=<u>Branch and link on less than zero compact</u>

<b>Format:</b>
bltzalc rt, offset

| POP07     rs      rt     offset  |
|000111    rs = rt != 0            |
|  6        5       5        16    |


<b>Description:</b>
Compact branch and link if GPR[rt] < 0.

Places the return address link in GPR <i>31</i>. The return link is the address of the instruction where the execution continues after a procedure call.

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rt</i> are lower than zero, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

GPR <i>31</i> must not be used by the sorce register, because such instructions don't have the same effect when re-executed. The result of executing such an instruction is <black>UNPREDICTABLE</black>. This restriction permits an exception handler to resume execution by re-executing the branch when an exception occurs in the branch delay slot.

<b>Operation:</b>
<black>I:</black>
GPR[31] <- PC + 4
target_offset <- sign_extend(offset || 00)
condition <- GPR[rt] < 0
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
With the 18-bit signed instruction offset, the conditional branch range is ±128KBytes. Use jump (<black>j</black>) or jump register (<black>jr</black>) to branch to addresses outside this range.
\END

INSTRUCTION_BEQZALC_DOCUMENTATION.=<u>Branch and link on equal to zero compact</u>

<b>Format:</b>
beqzalc rt, offset

| POP10     rs     rt != 0    offset  |
|001000       rs < rt                 |
|  6        5         5         16    |


<b>Description:</b>
Compact branch and link if GPR[rt] = 0.

Places the return address link in GPR <i>31</i>. The return link is the address of the instruction where the execution continues after a procedure call.

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rt</i> are equal to zero, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

GPR <i>31</i> must not be used by the sorce register, because such instructions don't have the same effect when re-executed. The result of executing such an instruction is <black>UNPREDICTABLE</black>. This restriction permits an exception handler to resume execution by re-executing the branch when an exception occurs in the branch delay slot.

<b>Operation:</b>
<black>I:</black>
GPR[31] <- PC + 4
target_offset <- sign_extend(offset || 00)
condition <- GPR[rt] = 0
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
With the 18-bit signed instruction offset, the conditional branch range is ±128KBytes. Use jump (<black>j</black>) or jump register (<black>jr</black>) to branch to addresses outside this range.
\END

INSTRUCTION_BNEZALC_DOCUMENTATION.=<u>Branch and link on not equal to zero compact</u>

<b>Format:</b>
bnezalc rt, offset

| POP30     rs     rt != 0    offset  |
|011000       rs < rt                 |
|  6        5         5         16    |


<b>Description:</b>
Compact branch and link if GPR[rt] != 0.

Places the return address link in GPR <i>31</i>. The return link is the address of the instruction where the execution continues after a procedure call.

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rt</i> are not equal to zero, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

GPR <i>31</i> must not be used by the sorce register, because such instructions don't have the same effect when re-executed. The result of executing such an instruction is <black>UNPREDICTABLE</black>. This restriction permits an exception handler to resume execution by re-executing the branch when an exception occurs in the branch delay slot.

<b>Operation:</b>
<black>I:</black>
GPR[31] <- PC + 4
target_offset <- sign_extend(offset || 00)
condition <- GPR[rt] != 0
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
With the 18-bit signed instruction offset, the conditional branch range is ±128KBytes. Use jump (<black>j</black>) or jump register (<black>jr</black>) to branch to addresses outside this range.
\END

INSTRUCTION_BLEZC_DOCUMENTATION.=<u>Branch on less than or equal to zero compact</u>

<b>Format:</b>
blezc rt, offset

| POP26     0      rt != 0    offset  |
|010110   00000                       |
|  6        5         5         16    |


<b>Description:</b>
Compact branch if GPR[rt] <= 0.

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rt</i> less than or equal to zero, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
target_offset <- sign_extend(offset || 00)
condition <- GPR[rt] <= 0
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_BGEZC_DOCUMENTATION.=<u>Branch on greater than or equal to zero compact</u>

<b>Format:</b>
bgezc rt, offset

| POP26  rs != 0   rt != 0    offset  |
|010110       rs = rt                 |
|  6        5         5         16    |


<b>Description:</b>
Compact branch if GPR[rt] >= 0.

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rt</i> greater than or equal to zero, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
target_offset <- sign_extend(offset || 00)
condition <- GPR[rt] >= 0
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_BGTZC_DOCUMENTATION.=<u>Branch on greater than zero compact</u>

<b>Format:</b>
bgtzc rt, offset

| POP27     0      rt != 0    offset  |
|010111   00000                       |
|  6        5         5         16    |


<b>Description:</b>
Compact branch if GPR[rt] > 0.

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rt</i> greater than zero, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
target_offset <- sign_extend(offset || 00)
condition <- GPR[rt] > 0
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_BLTZC_DOCUMENTATION.=<u>Branch on less than zero compact</u>

<b>Format:</b>
bltzc rt, offset

| POP27  rs != 0   rt != 0    offset  |
|010111       rs = rt                 |
|  6        5         5         16    |


<b>Description:</b>
Compact branch if GPR[rt] < 0.

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rt</i> less than zero, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
target_offset <- sign_extend(offset || 00)
condition <- GPR[rt] < 0
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_BGEC_DOCUMENTATION.=<u>Branch on greater than or equal compact</u>

<b>Format:</b>
bgec rs, rt, offset

| POP26  rs != 0   rt != 0    offset  |
|010110       rs != rt                |
|  6        5         5         16    |


<b>Description:</b>
Compact branch if GPR[rs] >= GPR[rt].

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rs</i> are greater than or equal to the contents of GPR <i>rt</i>, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
target_offset <- sign_extend(offset || 00)
condition <- GPR[rs] >= GPR[rt]
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_BLTC_DOCUMENTATION.=<u>Branch on less than or equal compact</u>

<b>Format:</b>
bltc rs, rt, offset

| POP27  rs != 0   rt != 0    offset  |
|010111       rs != rt                |
|  6        5         5         16    |


<b>Description:</b>
Compact branch if GPR[rs] < GPR[rt].

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rs</i> are less than the contents of GPR <i>rt</i>, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
target_offset <- sign_extend(offset || 00)
condition <- GPR[rt] < GPR[rt]
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_BGEUC_DOCUMENTATION.=<u>Branch on greater than or equal unsigned compact</u>

<b>Format:</b>
bgeuc rs, rt, offset

| POP06  rs != 0   rt != 0    offset  |
|000110       rs != rt                |
|  6        5         5         16    |


<b>Description:</b>
Compact branch if GPR[rs] >= GPR[rt].

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rs</i> are greater than or equal to the contents of GPR <i>rt</i>, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
target_offset <- sign_extend(offset || 00)
condition <- unsigned_word(GPR[rt]) >= unsigned_word(GPR[rt])
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_BLTUC_DOCUMENTATION.=<u>Branch on less than or equal unsigned compact</u>

<b>Format:</b>
bltuc rs, rt, offset

| POP07  rs != 0   rt != 0    offset  |
|000111       rs != rt                |
|  6        5         5         16    |


<b>Description:</b>
Compact branch if GPR[rs] < GPR[rt].

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rs</i> are less than the contents of GPR <i>rt</i>, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
target_offset <- sign_extend(offset || 00)
condition <- unsigned_word(GPR[rt]) < unsigned_word(GPR[rt])
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_BEQC_DOCUMENTATION.=<u>Branch on equal compact</u>

<b>Format:</b>
beqc rs, rt, offset

| POP10  rs != 0   rt != 0    offset  |
|001000       rs < rt                 |
|  6        5         5         16    |


<b>Description:</b>
Compact branch if GPR[rs] = GPR[rt].

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rs</i> are equal to the contents of GPR <i>rt</i>, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
target_offset <- sign_extend(offset || 00)
condition <- GPR[rt] = GPR[rt]
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_BNEC_DOCUMENTATION.=<u>Branch on not equal compact</u>

<b>Format:</b>
bnec rs, rt, offset

| POP30  rs != 0   rt != 0    offset  |
|011000       rs < rt                 |
|  6        5         5         16    |


<b>Description:</b>
Compact branch if GPR[rs] != GPR[rt].

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rs</i> are not equal to the contents of GPR <i>rt</i>, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
target_offset <- sign_extend(offset || 00)
condition <- GPR[rt] != GPR[rt]
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_BEQZC_DOCUMENTATION.=<u>Branch on equal to zero compact</u>

<b>Format:</b>
beqzc rs, offset

| POP66   BEQZC    offset  |
|110110  rs != 0           |
|  6        5        16    |


<b>Description:</b>
Compact branch if GPR[rs] == 0.

An 23-bit signed offset (the 21-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rs</i> are equal to zero, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
target_offset <- sign_extend(offset || 00)
condition <- GPR[rt] == 0
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_BNEZC_DOCUMENTATION.=<u>Branch on not equal to zero compact</u>

<b>Format:</b>
bnezc rs, offset

| POP76   BNEZC    offset  |
|111110  rs != 0           |
|  6        5        16    |


<b>Description:</b>
Compact branch if GPR[rs] != 0.

An 23-bit signed offset (the 21-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rs</i> are not equal to zero, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
target_offset <- sign_extend(offset || 00)
condition <- GPR[rt] != 0
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_BGTZ_DOCUMENTATION.=<u>Branch on greater than zero</u>

<b>Format:</b>
bgtz rs, offset

| BGTZ      rs     0      offset  |
|000111          00000            |
|  6        5      5        16    |


<b>Description:</b>
if GPR[rs] > 0 then branch

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rs</i> are greater than zero, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
<black>I:</black>
target_offset <- sign_extend(offset || 00)
condition <- GPR[rs] > 0
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
With the 18-bit signed instruction offset, the conditional branch range is ±128KBytes. Use jump (<black>j</black>) or jump register (<black>jr</black>) to branch to addresses outside this range.
\END

INSTRUCTION_BITSWAP_DOCUMENTATION.=<u>Swap bits in each byte</u>

<b>Format:</b>
bitswap rd, rt

|SPECIAL3    0    rt    rd    BITSWAP   BSGFL  |
| 011111   00000               00000    100000 |
|   6        5     5     5       5        6    |


<b>Description:</b>
GPR[rd].byte[i] <- reverse_bits(GPR[rt].byte[i]), for all bytes i

Each byte in GPR <i>rt</i> has its bytes reversed and moved to the same position in GPR <i>rd</i>.
This instruction operates on all 4 bytes of a 32-bit word.

<b>Restrictions:</b>
None

<b>Operation:</b>

function reverse_bits (in)
    out<sub>7</sub> <- in<sub>0</sub>
    out<sub>6</sub> <- in<sub>1</sub>
    out<sub>5</sub> <- in<sub>2</sub>
    out<sub>4</sub> <- in<sub>3</sub>
    out<sub>3</sub> <- in<sub>4</sub>
    out<sub>2</sub> <- in<sub>5</sub>
    out<sub>1</sub> <- in<sub>6</sub>
    out<sub>0</sub> <- in<sub>7</sub>
    return out
end function

for i in 0 to 3 do
    GPR[rd].byte[i] <- reverse_bits(GPR[rt].byte[i])
endfor

<b>Exceptions:</b>
None
\END

INSTRUCTION_BLEZ_DOCUMENTATION.=<u>Branch on less than or equal to zero</u>

<b>Format:</b>
blez rs, offset

| BLEZ      rs     0      offset  |
|000110          00000            |
|  6        5      5        16    |


<b>Description:</b>
if GPR[rs] <= 0 then branch

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rs</i> are less than or equal to zero, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
<black>I:</black>
target_offset <- sign_extend(offset || 00)
condition <- GPR[rs] <= 0
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
With the 18-bit signed instruction offset, the conditional branch range is ±128KBytes. Use jump (<black>j</black>) or jump register (<black>jr</black>) to branch to addresses outside this range.
\END

INSTRUCTION_BLTZ_DOCUMENTATION.=<u>Branch on less than zero</u>

<b>Format:</b>
bltz rs, offset

|REGIMM     rs    BLTZ    offset  |
|000001          00000            |
|  6        5      5        16    |


<b>Description:</b>
if GPR[rs] < 0 then branch

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rs</i> are less than zero, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
<black>I:</black>
target_offset <- sign_extend(offset || 00)
condition <- GPR[rs] < 0
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
With the 18-bit signed instruction offset, the conditional branch range is ±128KBytes. Use jump (<black>j</black>) or jump register (<black>jr</black>) to branch to addresses outside this range.
\END

INSTRUCTION_BNE_DOCUMENTATION.=<u>Branch on not equal</u>

<b>Format:</b>
bne rs, rt, offset

| BNE       rs     rt     offset  |
|000101                           |
|  6        5      5       16     |


<b>Description:</b>
if GPR[rs] != GPR[rt] then branch

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rt</i> and GPR <i>rs</i> are not equal, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
<black>I:</black>
target_offset <- sign_extend(offset || 00)
condition <- GPR[rs] != GPR[rt]
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
With the 18-bit signed instruction offset, the conditional branch range is ±128KBytes. Use jump (<black>j</black>) or jump register (<black>jr</black>) to branch to addresses outside this range.
\END

INSTRUCTION_BOVC_DOCUMENTATION.=<u>Branch on overflow compact</u>

<b>Format:</b>
bovc rs, rt, offset

| POP10     rs        rt      offset  |
|001000       rs >= rt                |
|  6        5         5         16    |


<b>Description:</b>
Compact branch if GPR[rs] + GPR[rt] overflows

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rs</i> plus the contents of GPR <i>rt</i> overflow, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
target_offset <- sign_extend(offset || 00)
temp_d = GPR[rs] + GPR[rt]
condition <- temp_d<sub>32</sub> != temp_d<sub>31</sub>

if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_BNVC_DOCUMENTATION.=<u>Branch on no overflow compact</u>

<b>Format:</b>
bnvc rs, rt, offset

| POP30     rs        rt      offset  |
|011000       rs >= rt                |
|  6        5         5         16    |


<b>Description:</b>
Compact branch if GPR[rs] + GPR[rt] doesn't overflow

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rs</i> plus the contents of GPR <i>rt</i> don't overflow, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
target_offset <- sign_extend(offset || 00)
temp_d = GPR[rs] + GPR[rt]
condition <- temp_d<sub>32</sub> = temp_d<sub>31</sub>

if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_BREAK_DOCUMENTATION.=<u>Breakpoint</u>

<b>Format:</b>
break

|SPECIAL    0       BREAK  |
|000000                    |
|  6        20     001101  |


<b>Description:</b>
Breakpoint

A breakpoint exception occurs, immediately and unconditionally transfering control to the exception handler.

<b>Restrictions:</b>
None

<b>Operation:</b>
SignalException(Breakpoint)

<b>Exceptions:</b>
Breakpoint
\END

INSTRUCTION_CEIL_L_D_DOCUMENTATION.=<u>Ceiling double to long</u>

<b>Format:</b>
ceil.l.d fd, fs

| COP1      fmt      0      fs      fd     CEIL.L |
|010001    10001   00000                   001010 |
|  6         5       5      5       5        6    |


<b>Description:</b>
FPR[fd] <- convert_and_round(FPR[fs])

The double precission floating point value of FPR <i>fs</i> is converted to a ceiled 64-bit word.
The result is placed in FPR <i>fd</i>.

When the source value is <black>Infinity</black>, <black>NaN</black> or is outside of a 64-bit word, the result cannot be represented correctly. These cases are handled by the JVM itself.

<b>Restrictions:</b>
The fields <i>fs</i> and <i>fd</i> must be even FPRs. If the fields are not valid, the result is <black>UNPREDICTABLE</black>.
The operand must be a value in double precision floating point. If it is not, the result is <black>UNPREDICTABLE</black>.

<b>Operation:</b>
fmt <- double
StoreFPR(fd, L, ConvertFmt(ValueFPR(fs, fmt), fmt, L))

<b>Exceptions:</b>
None
\END

INSTRUCTION_CEIL_W_D_DOCUMENTATION.=<u>Ceiling double to word</u>

<b>Format:</b>
ceil.w.d fd, fs

| COP1      fmt      0      fs      fd     CEIL.W |
|010001    10001   00000                   001110 |
|  6         5       5      5       5        6    |


<b>Description:</b>
FPR[fd] <- convert_and_round(FPR[fs])

The double precission floating point value of FPR <i>fs</i> is converted to a ceiled 32-bit word.
The result is placed in FPR <i>fd</i>.

When the source value is <black>Infinity</black>, <black>NaN</black> or is outside of a 32-bit word, the result cannot be represented correctly. These cases are handled by the JVM itself.

<b>Restrictions:</b>
The field <i>fs</i> must be a even FPR. If the field is not valid, the result is <black>UNPREDICTABLE</black>.
The operand must be a value in double precision floating point. If it is not, the result is <black>UNPREDICTABLE</black>.

<b>Operation:</b>
fmt <- double
StoreFPR(fd, W, ConvertFmt(ValueFPR(fs, fmt), fmt, W))

<b>Exceptions:</b>
None
\END


INSTRUCTION_CEIL_L_S_DOCUMENTATION.=<u>Ceiling float to long</u>

<b>Format:</b>
ceil.l.s fd, fs

| COP1      fmt      0      fs      fd     CEIL.L |
|010001    10000   00000                   001010 |
|  6         5       5      5       5        6    |


<b>Description:</b>
FPR[fd] <- convert_and_round(FPR[fs])

The floating point value of FPR <i>fs</i> is converted to a ceiled 64-bit word.
The result is placed in FPR <i>fd</i>.

When the source value is <black>Infinity</black>, <black>NaN</black> or is outside of a 64-bit word, the result cannot be represented correctly. These cases are handled by the JVM itself.

<b>Restrictions:</b>
The field <i>fd</i> must be a even FPR. If the field is not valid, the result is <black>UNPREDICTABLE</black>.
The operand must be a value in floating point. If it is not, the result is <black>UNPREDICTABLE</black>.

<b>Operation:</b>
fmt <- float
StoreFPR(fd, L, ConvertFmt(ValueFPR(fs, fmt), fmt, L))

<b>Exceptions:</b>
None
\END

INSTRUCTION_CEIL_W_S_DOCUMENTATION.=<u>Ceiling float to word</u>

<b>Format:</b>
ceil.w.s fd, fs

| COP1      fmt      0      fs      fd     CEIL.W |
|010001    10000   00000                   001110 |
|  6         5       5      5       5        6    |


<b>Description:</b>
FPR[fd] <- convert_and_round(FPR[fs])

The floating point value of FPR <i>fs</i> is converted to a ceiled 32-bit word.
The result is placed in FPR <i>fd</i>.

When the source value is <black>Infinity</black>, <black>NaN</black> or is outside of a 32-bit word, the result cannot be represented correctly. These cases are handled by the JVM itself.

<b>Restrictions:</b>
The operand must be a value in floating point. If it is not, the result is <black>UNPREDICTABLE</black>.

<b>Operation:</b>
fmt <- float
StoreFPR(fd, W, ConvertFmt(ValueFPR(fs, fmt), fmt, W))

<b>Exceptions:</b>
None
\END

INSTRUCTION_CLO_DOCUMENTATION.=<u>Count leading ones in word</u>

<b>Format:</b>
clo rd, rs

|SPECIAL     rs      0      rd      1       CLO   |
|000000            00000          00001    010001 |
|  6         5       5      5       5        6    |


<b>Description:</b>
GPR[rd] <- count_leading_ones(GPR[rs])

Bits 31 to 0 of GPR <i>rs</i> are scanned from most significant to least significant bit. The number of leading ones is counted and the result is written to GPR <i>rd</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>

temp <- 32
for i in 31 to 0
    if GPR[rs]<sub>i</sub> = 0 then
        temp <- 31 - i
        break
    endif
endfor
GPR[rd] <- temp

<b>Exceptions:</b>
None
\END


INSTRUCTION_CLZ_DOCUMENTATION.=<u>Count leading zeros in word</u>

<b>Format:</b>
clz rd, rs

|SPECIAL     rs      0      rd      1       CLZ   |
|000000            00000          00001    010000 |
|  6         5       5      5       5        6    |


<b>Description:</b>
GPR[rd] <- count_leading_zeros(GPR[rs])

Bits 31 to 0 of GPR <i>rs</i> are scanned from most significant to least significant bit. The number of leading zeros is counted and the result is written to GPR <i>rd</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>

temp <- 32
for i in 31 to 0
    if GPR[rs]<sub>i</sub> = 1 then
        temp <- 31 - i
        break
    endif
endfor
GPR[rd] <- temp

<b>Exceptions:</b>
None
\END

INSTRUCTION_CMP_D_DOCUMENTATION.=<u>Floating point compare ({TYPE}) (double)</u>

<b>Format:</b>
cmp.{MNEMONIC}.d fd, fs, ft

| COP1    CMP.c.D   ft   fs   fd   0   {MNEMONIC}\t|
|000001    10101                   0   {CODE}\t|
|  6         5      5    5    5    1     5     \t|


<b>Description:</b>
FPR[fd] <- FPR[fs] compare_cond FPR[ft] where compare_cond = {TYPE}.

The value in FPR <i>fs</i> is compared to the value in FPR <i>ft</i>.
The FPR <i>fd</i> is filled with zeros if the result is false or ones of the result is true.

Each bit 2 to 0 in the condition repesents a check. If one of these bits is active the check linked to it will be executed.
The result is true when any of these checks return true.

The checks linked to the bits are the next:
- Bit 0: unordered.
- Bit 1: equal.
- Bit 2: less than.

If bit 4 is active the result is negated.
If bit 3 is active and any of the operands are <black>NaN</black>, a Floating Point Exception will be thrown.

<b>Restrictions:</b>
The fields <i>fs</i>, <i>ft</i> and <i>fd</i> must be even FPRs. If the fields are not valid, the result is <black>UNPREDICTABLE</black>.
Operands must be values in double precision floating point. If they are not, the result is <black>UNPREDICTABLE</black>.

<b>Operation:</b>
fmt <- double
fsv <- ValueFPR(fs, fmt)
ftv <- ValueFPR(ft, fmt)

if is_NaN(fsv) or is_NaN(ftv) then
    less <- false
    equal <- false
    unordered <- true
    if cond<sub>3</sub> then
        SignalException(FloatingPointException)
    endif
else
    less <- fsv <<sub>fmt</sub> ftv
    less <- fsv =<sub>fmt</sub> ftv
    unordered <- false
endif

condition <- cond<sub>4</sub> xor ((cond<sub>2</sub> and less) or (cond<sub>1</sub> and equal) or (cond<sub>0</sub> and unordered))
StoreFPR(fd, fmt, extend_bit.fmt(condition))

<b>Exceptions:</b>
Floating Point Exception
\END

INSTRUCTION_CMP_S_DOCUMENTATION.=<u>Floating point compare ({TYPE}) (single)</u>

<b>Format:</b>
cmp.{MNEMONIC}.s fd, fs, ft

| COP1    CMP.c.S   ft   fs   fd   0   {MNEMONIC}\t|
|000001    10100                   0   {CODE}\t|
|  6         5      5    5    5    1     5     \t|


<b>Description:</b>
FPR[fd] <- FPR[fs] compare_cond FPR[ft] where compare_cond = {TYPE}.

The value in FPR <i>fs</i> is compared to the value in FPR <i>ft</i>.
The FPR <i>fd</i> is filled with zeros if the result is false or ones of the result is true.

Each bit 2 to 0 in the condition repesents a check. If one of these bits is active the check linked to it will be executed.
The result is true when any of these checks return true.

The checks linked to the bits are the next:
- Bit 0: unordered.
- Bit 1: equal.
- Bit 2: less than.

If bit 4 is active the result is negated.
If bit 3 is active and any of the operands are <black>NaN</black>, a Floating Point Exception will be thrown.

<b>Restrictions:</b>
Operands must be values in floating point. If they are not, the result is <black>UNPREDICTABLE</black>.

<b>Operation:</b>
fmt <- float
fsv <- ValueFPR(fs, fmt)
ftv <- ValueFPR(ft, fmt)

if is_NaN(fsv) or is_NaN(ftv) then
    less <- false
    equal <- false
    unordered <- true
    if cond<sub>3</sub> then
        SignalException(FloatingPointException)
    endif
else
    less <- fsv <<sub>fmt</sub> ftv
    less <- fsv =<sub>fmt</sub> ftv
    unordered <- false
endif

condition <- cond<sub>4</sub> xor ((cond<sub>2</sub> and less) or (cond<sub>1</sub> and equal) or (cond<sub>0</sub> and unordered))
StoreFPR(fd, fmt, extend_bit.fmt(condition))

<b>Exceptions:</b>
Floating Point Exception
\END


INSTRUCTION_CVT_DOCUMENTATION.=<u>Convert from {FROM} to {TO}</u>

<b>Format:</b>
cvt.{TO_MNEMONIC}.{FROM_MNEMONIC} fd, fs

| COP1      fmt      0      fs      fd      CVT.{TO_MNEMONIC}  |
|010001    {FROM_FMT}   00000                   {TO_CVT}  |
|  6         5       5      5       5        6     |


<b>Description:</b>
FPR[fd] <- convert_and_round(FPR[fs])

The value of FPR <i>fs</i> in the format of {FROM} is converted to a value in the format of {TO}.
The result is placed in FPR <i>fd</i>.

<b>Restrictions:</b>
Values whose format rely on two register must be placed on an even FPR. If they are not, the result is <black>UNPREDICTABLE</black>.
The operand must be in the value of its respective format. If it is not, the result is <black>UNPREDICTABLE</black>.

<b>Operation:</b>
from <- {FROM_MNEMONIC}
to <- {TO_MNEMONIC}
StoreFPR(fd, to, ConvertFmt(ValueFPR(fs, from), from, to))

<b>Exceptions:</b>
None
\END

INSTRUCTION_DIV_DOCUMENTATION.=<u>Division</u>

<b>Format:</b>
div rd, rs, rt

|SPECIAL     rs      rt     rd     DIV      SOP32 |
|000000                           00010    011010 |
|  6         5       5      5       5        6    |


<b>Description:</b>
GPR[rd] <- GPR[rs] / GPR[rt]

The 32-bit word value in GPR <i>rs</i> is divided by the 32-bit value in GPR <i>rt</i> to produce a 32-bit quotient.
The 32-bit quotient is placed into GPR <i>rd</i>.

<b>Restrictions:</b>
If the divisor in GPR <i>rt</i> is zero, the result value is <black>UNPREDICTABLE</black>.

<b>Operation:</b>

GPR[rd] <- GPR[rs] / GPR[rt]

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
Because the divide and modulo instructions are define to not trap if dividing by zero, it is safe to emit code that checks for zero-divide after the divide or modulo instruction.
\END

INSTRUCTION_MOD_DOCUMENTATION.=<u>Modulo</u>

<b>Format:</b>
mod rd, rs, rt

|SPECIAL     rs      rt     rd     MOD      SOP32 |
|000000                           00011    011010 |
|  6         5       5      5       5        6    |


<b>Description:</b>
GPR[rd] <- GPR[rs] % GPR[rt]

The 32-bit word value in GPR <i>rs</i> is divided by the 32-bit value in GPR <i>rt</i> to produce a 32-bit remainder.
The 32-bit remainder is placed into GPR <i>rd</i>.

<b>Restrictions:</b>
If the divisor in GPR <i>rt</i> is zero, the result value is <black>UNPREDICTABLE</black>.

<b>Operation:</b>

GPR[rd] <- GPR[rs] % GPR[rt]

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
Because the divide and modulo instructions are define to not trap if dividing by zero, it is safe to emit code that checks for zero-divide after the divide or modulo instruction.
\END

INSTRUCTION_DIVU_DOCUMENTATION.=<u>Unsigned division</u>

<b>Format:</b>
divu rd, rs, rt

|SPECIAL     rs      rt     rd     DIVU     SOP33 |
|000000                           00010    011011 |
|  6         5       5      5       5        6    |


<b>Description:</b>
GPR[rd] <- GPR[rs] / GPR[rt]

The 32-bit word value in GPR <i>rs</i> is divided by the 32-bit value in GPR <i>rt</i> to produce a 32-bit quotient.
The 32-bit quotient is placed into GPR <i>rd</i>.

<b>Restrictions:</b>
If the divisor in GPR <i>rt</i> is zero, the result value is <black>UNPREDICTABLE</black>.

<b>Operation:</b>

GPR[rd] <- unsigned_word(GPR[rs]) / unsigned_word(GPR[rt])

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
Because the divide and modulo instructions are define to not trap if dividing by zero, it is safe to emit code that checks for zero-divide after the divide or modulo instruction.
\END

INSTRUCTION_MODU_DOCUMENTATION.=<u>Unsigned modulo</u>

<b>Format:</b>
modu rd, rs, rt

|SPECIAL     rs      rt     rd     MODU     SOP33 |
|000000                           00011    011011 |
|  6         5       5      5       5        6    |


<b>Description:</b>
GPR[rd] <- GPR[rs] % GPR[rt]

The 32-bit word value in GPR <i>rs</i> is divided by the 32-bit value in GPR <i>rt</i> to produce a 32-bit remainder.
The 32-bit remainder is placed into GPR <i>rd</i>.

<b>Restrictions:</b>
If the divisor in GPR <i>rt</i> is zero, the result value is <black>UNPREDICTABLE</black>.

<b>Operation:</b>

GPR[rd] <- unsigned_word(GPR[rs]) % unsigned_word(GPR[rt])

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
Because the divide and modulo instructions are define to not trap if dividing by zero, it is safe to emit code that checks for zero-divide after the divide or modulo instruction.
\END

INSTRUCTION_DIV_D_DOCUMENTATION.=<u>Double precision floating point division</u>

<b>Format:</b>
div.d fd, fs, ft

| COP1      fmt      0      fs      fd      DIV   |
|010001    10001   00000                   000011 |
|  6         5       5      5       5        6    |


<b>Description:</b>
FPR[fd] <- FPR[fs] / FPR[ft]

The value in FPR <i>ft</i> is divided by the value in FPR <i>fs</i>. The result is calculated to infinite precision, rounded using the <i>Java</i> rounding mode, and placed into FPR <i>fd</i>.
The operands and result are values in double precision floating point.

<b>Restrictions:</b>
The fields <i>fs</i>, <i>ft</i> and <i>fd</i> must be even FPRs. If the fields are not valid, the result is <black>UNPREDICTABLE</black>.
Operands must be values in double precision floating point. If they are not, the result is <black>UNPREDICTABLE</black>.

<b>Operation:</b>
fmt <- double
StoreFPR(fd, fmt, ValueFPR(fs, fmt) /<sub>fmt</sub> ValueFPR(ft, fmt))

<b>Exceptions:</b>
None
\END

INSTRUCTION_DIV_S_DOCUMENTATION.=<u>Floating point division</u>

<b>Format:</b>
div.s fd, fs, ft

| COP1      fmt      0      fs      fd      DIV   |
|010001    10000   00000                   000011 |
|  6         5       5      5       5        6    |


<b>Description:</b>
FPR[fd] <- FPR[fs] / FPR[ft]

The value in FPR <i>ft</i> is divided by the value in FPR <i>fs</i>. The result is calculated to infinite precision, rounded using the <i>Java</i> rounding mode, and placed into FPR <i>fd</i>.
The operands and result are values in floating point.

<b>Restrictions:</b>
Operands must be values in floating point. If they are not, the result is <black>UNPREDICTABLE</black>.

<b>Operation:</b>
fmt <- float
StoreFPR(fd, fmt, ValueFPR(fs, fmt) /<sub>fmt</sub> ValueFPR(ft, fmt))

<b>Exceptions:</b>
None
\END

INSTRUCTION_ERET_DOCUMENTATION.=<u>Exception return</u>

<b>Format:</b>
eret

| COP0     CO    0     ERET   |
|010000    1           011000 |
|  6       1     19      6    |


<b>Description:</b>
This instruction clears the execution and all instruction hazards and returns to the interrupted instruction by an interruption, exception or error proccesing.
<black>eret</black> doesn't execute the next instruction and doesn't have a delay slot.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
if Status<sub>ERL</sub> = 1 then
    temp <- ErrorEPC
    Status<sub>ERL</sub> <- 0
else
    temp <- EPC
    Status<sub>EXL</sub> <- 0
endif

PC <- temp

ClearHazards()

<b>Exceptions:</b>
None
\END

INSTRUCTION_J_DOCUMENTATION.=<u>Jump</u>

<b>Format:</b>
j target

|  J      index |
|000010         |
|  6       26   |


<b>Description:</b>
This is a PC-region branch (not PC-relative); the effective target address is the 256MB-aligned region.
The low 28 bits of the target addres is the <i>index</i> field shifted left 2 bits. The remaining upper bits are the corresponding bits of the addres of the instruction in the delay slot (not the branch itself).
Jump to the effective target address. If delay slots are enabled, this instruction also executes the instruction that follows the jump, in the branch delay slot, before executing the jump itself.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
<black>I:</black>
<black>I+1:</black>
PC <- PC<sub>31..28</sub> || index || 00

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
Forming the branch target address by catenating PC and index bits rather than adding a signed offset to the PC is an advantage if all program code addresses fit into a 256MB region aligned on a 256MB boundary. It allows a branch from anywhere to anywhere in the region, an action not allowed by a signed relative offset.
This definition creates the following boundary case: when the jump instruction is in the last word of a 256MB region, it can branch only to the following 256MB region containing the branch delay slot.
The jump instruction has been deprecated in Release 6. Use <black>bc</black> instead.
\END

INSTRUCTION_JAL_DOCUMENTATION.=<u>Jump and link</u>

<b>Format:</b>
jal target

| JAL     index |
|000011         |
|  6       26   |


<b>Description:</b>
This is a PC-region branch (not PC-relative); the effective target address is the 256MB-aligned region.

Places the return address link in GPR <i>31</i>. The return link is the address of the instruction where the execution continues after a procedure call.
The low 28 bits of the target addres is the <i>index</i> field shifted left 2 bits. The remaining upper bits are the corresponding bits of the addres of the instruction in the delay slot (not the branch itself).
Jump to the effective target address. If delay slots are enabled, this instruction also executes the instruction that follows the jump, in the branch delay slot, before executing the jump itself.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
<black>I:</black>
GPR[31] <- PC + 4
<black>I+1:</black>
PC <- PC<sub>31..28</sub> || index || 00

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
Forming the branch target address by catenating PC and index bits rather than adding a signed offset to the PC is an advantage if all program code addresses fit into a 256MB region aligned on a 256MB boundary. It allows a branch from anywhere to anywhere in the region, an action not allowed by a signed relative offset.
This definition creates the following boundary case: when the jump instruction is in the last word of a 256MB region, it can branch only to the following 256MB region containing the branch delay slot.
The jump and link instruction has been deprecated in Release 6. Use <black>balc</black> instead.
\END

INSTRUCTION_JALR_DOCUMENTATION.=<u>Jump and link register</u>

<b>Format:</b>
jalr rs (rd = 31 implied)
jalr rd, rs

|SPECIAL     rs      rt     rd      0       JALR  |
|000000                                    001001 |
|  6         5       5      5       5        6    |


<b>Description:</b>
GPR[rd] <- return_addr, PC <- GPR[rs]

Places the return address link in GPR <i>rd</i>. The return link is the address of the instruction where the execution continues after a procedure call.

Jump to the effective target addres in GPR <i>rs</i>. If the target address is not 4-bytes aligned, an Address Error exception will occur when the target address is fetched.
If delay slots are enabled, this instruction also executes the instruction that follows the jump, in the branch delay slot, before executing the jump itself.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

Register <i>rs</i> and <i>rd</i> must not be equal, because such an instruction does not have the same effect when re-executed. The result of execution such an instruction is <black>UNPREDICTABLE</black>. This restriction permits an exception handler to resume execution by re-executing the branch when an exception occurs in the delay slot.

<b>Operation:</b>
<black>I:</black>
temp <- GPR[rs]
GPR[31] <- PC + 4
<black>I+1:</black>
PC <- temp

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
This jump-and-link register instruction can select a register for the return link; other link instructions use GPR 31.
The default register for GPR <i>rd</i>, if omitted in the assembly language instruction, is GPR 31.
\END

INSTRUCTION_LB_DOCUMENTATION.=<u>Load byte</u>

<b>Format:</b>
lb rt offset(base)

|  LB      base     rt    offset |
|100000                          |
|  6        5       5       16   |


<b>Description:</b>
GPR[rt] <- memory[GPR[base] + offset]

The contents of the 8-bit byte at the memory location by the effective address are fetched, sign-extended and placed in GPR <i>rt</i>.
The 16-bit signed <i>offset</i> is added to the contents of GPR <i>base</i> to form the effective address.

<b>Restrictions:</b>
None

<b>Operation:</b>
v_addr <- sign_extend(offset) + GPR[base]
(p_addr, cca) <- AddressTranslation(v_addr, DATA, LOAD)
mem_byte <- LoadMemory(CCA, BYTE, p_addr, v_addr, DATA)
GPR[rt] <- sign_extend(mem_byte)

<b>Exceptions:</b>
Address Error
\END

INSTRUCTION_LW_DOCUMENTATION.=<u>Load word</u>

<b>Format:</b>
lw rt offset(base)

|  LW      base     rt    offset |
|100011                          |
|  6        5       5       16   |


<b>Description:</b>
GPR[rt] <- memory[GPR[base] + offset]

The contents of the 32-bit word at the memory location by the effective address are fetched, sign-extended and placed in GPR <i>rt</i>.
The 16-bit signed <i>offset</i> is added to the contents of GPR <i>base</i> to form the effective address.

<b>Restrictions:</b>
None

<b>Operation:</b>
v_addr <- sign_extend(offset) + GPR[base]
(p_addr, cca) <- AddressTranslation(v_addr, DATA, LOAD)
mem_word <- LoadMemory(CCA, WORD, p_addr, v_addr, DATA)
GPR[rt] <- sign_extend(mem_word)

<b>Exceptions:</b>
Address Error
\END

INSTRUCTION_MFC0_DOCUMENTATION.=<u>Move from coprocessor 0</u>

<b>Format:</b>
mfc0 rt, rd (sel = 0 implied)
mfc0 rt, rd, sel

| COP0     MF     rt    rd    0    sel |
|010000  00000                         |
|  6       5      5     5     8     0  |


<b>Description:</b>
GPR[rt] <- CPR[0, rd, sel]

The contents of the coprocessor 0 register specified by the combination of <i>rd</i> and <i>sel</i> are loaded into the general register <i>rt</i>.

<b>Restrictions:</b>
Reading a reserved register or a register that is not implemented for the current core configuration returns 0.

<b>Operation:</b>
if IsCoprocessorRegisterImplemented(0, rd, sel) then
    GPR[rt] <- CPR[0, rd, sel]
else
    GPR[rt] <- 0
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_MFC1_DOCUMENTATION.=<u>Move from coprocessor 1</u>

<b>Format:</b>
mfc1 rt, rd

| COP1     MF     rt    fs     0 |
|010001  00000                   |
|  6       5      5     5     11 |


<b>Description:</b>
GPR[rt] <- FPR[fs]

The contents of the coprocessor 1 register <i>fs</i> are loaded into the general register <i>rt</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>
GPR[rt] <- ValueFPR(fs, UNINTERPRETED_WORD)

<b>Exceptions:</b>
None
\END

INSTRUCTION_MTC0_DOCUMENTATION.=<u>Move to coprocessor 0</u>

<b>Format:</b>
mtc0 rt, rd (sel = 0 implied)
mtc0 rt, rd, sel

| COP0     MT     rt    rd    0    sel |
|010000  00100                         |
|  6       5      5     5     8     0  |


<b>Description:</b>
CPR[0, rd, sel] <- GPR[rt]

The contents of the general register <i>rt</i> are loaded into the coprocessor 0 register specified by the combination of <i>rd</i> and <i>sel</i>.

<b>Restrictions:</b>
Writes to a reserved register or a register that is not implemented for the current core configuration are ignored.

<b>Operation:</b>
if IsCoprocessorRegisterImplemented(0, rd, sel) then
    CPR[0, rd, sel] <- GPR[rt]
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_MTC1_DOCUMENTATION.=<u>Move to coprocessor 1</u>

<b>Format:</b>
mtc1 rt, rd

| COP1     MT     rt    fs     0 |
|010001  00100                   |
|  6       5      5     5     11 |


<b>Description:</b>
FPR[fs] <- GPR[rt]

The contents of the general register <i>rt</i> are loaded into the coprocessor 1 register <i>fs</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>
StoreFPR(fs, UNINTERPRETED_WORD, GPR[rt])

<b>Exceptions:</b>
None
\END

INSTRUCTION_MUL_DOCUMENTATION.=<u>Multiplication and return low word</u>

<b>Format:</b>
mul rd, rs, rt

|SPECIAL     rs      rt     rd     MUL      SOP30 |
|000000                           00010    011000 |
|  6         5       5      5       5        6    |


<b>Description:</b>
GPR[rd] <- lo_word(GPR[rs] * GPR[rt])

The 32-bit word value in GPR <i>rs</i> is multiplied by the 32-bit value in GPR <i>rt</i> to produce a 32-bit word contaning the low 32 bits of the result.
The 32-bit word is placed into GPR <i>rd</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>

GPR[rd] <- lo_word(GPR[rs] * GPR[rt])

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
The low half of the integer multiplication result is identical for signed and unsigned. Neverthless, there different instructions for unsigned and signed multiplication that produce the low half of the result.
Implementations may choose to optimize a multiply that produces the low half followed by a multiply that produces the upper half. Programmers are recommended to use matching lower and upper half multiplications.
\END

INSTRUCTION_MUH_DOCUMENTATION.=<u>Multiplication and return high word</u>

<b>Format:</b>
muh rd, rs, rt

|SPECIAL     rs      rt     rd     MUH      SOP30 |
|000000                           00011    011000 |
|  6         5       5      5       5        6    |


<b>Description:</b>
GPR[rd] <- hi_word(GPR[rs] * GPR[rt])

The 32-bit word value in GPR <i>rs</i> is multiplied by the 32-bit value in GPR <i>rt</i> to produce a 32-bit word contaning the upper 32 bits of the result.
The 32-bit word is placed into GPR <i>rd</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>

GPR[rd] <- hi_word(GPR[rs] * GPR[rt])

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
The low half of the integer multiplication result is identical for signed and unsigned. Neverthless, there different instructions for unsigned and signed multiplication that produce the low half of the result.
Implementations may choose to optimize a multiply that produces the low half followed by a multiply that produces the upper half. Programmers are recommended to use matching lower and upper half multiplications.
\END

INSTRUCTION_MULU_DOCUMENTATION.=<u>Unsigned multiplication and return low word</u>

<b>Format:</b>
mulu rd, rs, rt

|SPECIAL     rs      rt     rd     MULU     SOP31 |
|000000                           00010    011001 |
|  6         5       5      5       5        6    |


<b>Description:</b>
GPR[rd] <- lo_word(GPR[rs] * GPR[rt])

The 32-bit word value in GPR <i>rs</i> is multiplied by the 32-bit value in GPR <i>rt</i> to produce a 32-bit word contaning the low 32 bits of the result.
The 32-bit word is placed into GPR <i>rd</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>

GPR[rd] <- lo_word(unsigned_word(GPR[rs]) * unsigned_word(GPR[rt]))

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
The low half of the integer multiplication result is identical for signed and unsigned. Neverthless, there different instructions for unsigned and signed multiplication that produce the low half of the result.
Implementations may choose to optimize a multiply that produces the low half followed by a multiply that produces the upper half. Programmers are recommended to use matching lower and upper half multiplications.
\END

INSTRUCTION_MUHU_DOCUMENTATION.=<u>Unsigned multiplication and return high word</u>

<b>Format:</b>
muhu rd, rs, rt

|SPECIAL     rs      rt     rd     MUHU     SOP31 |
|000000                           00011    011001 |
|  6         5       5      5       5        6    |


<b>Description:</b>
GPR[rd] <- hi_word(GPR[rs] * GPR[rt])

The 32-bit word value in GPR <i>rs</i> is multiplied by the 32-bit value in GPR <i>rt</i> to produce a 32-bit word contaning the upper 32 bits of the result.
The 32-bit word is placed into GPR <i>rd</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>

GPR[rd] <- hi_word(unsigned_word(GPR[rs]) * unsigned_word(GPR[rt]))

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
The low half of the integer multiplication result is identical for signed and unsigned. Neverthless, there different instructions for unsigned and signed multiplication that produce the low half of the result.
Implementations may choose to optimize a multiply that produces the low half followed by a multiply that produces the upper half. Programmers are recommended to use matching lower and upper half multiplications.
\END

INSTRUCTION_MUL_D_DOCUMENTATION.=<u>Double precision floating point multiplication</u>

<b>Format:</b>
mul.d fd, fs, ft

| COP1      fmt      0      fs      fd      MUL   |
|010001    10001   00000                   000010 |
|  6         5       5      5       5        6    |


<b>Description:</b>
FPR[fd] <- FPR[fs] * FPR[ft]

The value in FPR <i>ft</i> is multiplied by the value in FPR <i>fs</i>. The result is calculated to infinite precision, rounded using the <i>Java</i> rounding mode, and placed into FPR <i>fd</i>.
The operands and result are values in double precision floating point.

<b>Restrictions:</b>
The fields <i>fs</i>, <i>ft</i> and <i>fd</i> must be even FPRs. If the fields are not valid, the result is <black>UNPREDICTABLE</black>.
Operands must be values in double precision floating point. If they are not, the result is <black>UNPREDICTABLE</black>.

<b>Operation:</b>
fmt <- double
StoreFPR(fd, fmt, ValueFPR(fs, fmt) *<sub>fmt</sub> ValueFPR(ft, fmt))

<b>Exceptions:</b>
None
\END

INSTRUCTION_MUL_S_DOCUMENTATION.=<u>Floating point multiplication</u>

<b>Format:</b>
div.s fd, fs, ft

| COP1      fmt      0      fs      fd      MUL   |
|010001    10000   00000                   000010 |
|  6         5       5      5       5        6    |


<b>Description:</b>
FPR[fd] <- FPR[fs] * FPR[ft]

The value in FPR <i>ft</i> is multiplied by the value in FPR <i>fs</i>. The result is calculated to infinite precision, rounded using the <i>Java</i> rounding mode, and placed into FPR <i>fd</i>.
The operands and result are values in floating point.

<b>Restrictions:</b>
Operands must be values in floating point. If they are not, the result is <black>UNPREDICTABLE</black>.

<b>Operation:</b>
fmt <- float
StoreFPR(fd, fmt, ValueFPR(fs, fmt) *<sub>fmt</sub> ValueFPR(ft, fmt))

<b>Exceptions:</b>
None
\END

INSTRUCTION_OR_DOCUMENTATION.=<u>Or</u>

<b>Format:</b>
or rd, rs, rt

|SPECIAL     rs      rt     rd      0        OR   |
|000000                                    100101 |
|  6         5       5      5       5        6    |


<b>Description:</b>
GPR[rd] <- GPR[rs] or GPR[rt]

Performs a bitwise logical OR using the values inside GPR <i>rs</i> and GPR <i>rt</i>.
The result is placed into GPR <i>rd</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>
GPR[rd] <- GPR[rs] or GPR[rt]

<b>Exceptions:</b>
None
\END

INSTRUCTION_ORI_DOCUMENTATION.=<u>Immediate or</u>

<b>Format:</b>
ori rt, rs, immediate

| ORI       rs     rt     immediate |
|001101                             |
|  6        5      5         16     |


<b>Description:</b>
GPR[rt] <- GPR[rs] or zero_extend(immediate)

The 16-bit <i>immediate</i> is zero-extended to the left and combined with the value of GPR <i>rs</i> in a bitwise logical OR operation.
The result is placed into GPR <i>rt</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>
GPR[rt] <- GPR[rs] or zero_extend(immediate)

<b>Exceptions:</b>
None
\END

INSTRUCTION_SB_DOCUMENTATION.=<u>Save byte</u>

<b>Format:</b>
sb rt offset(base)

|  SB      base     rt    offset |
|101000                          |
|  6        5       5       16   |


<b>Description:</b>
memory[GPR[base] + offset] <- GPR[rt]

The least-significant 8-bit byte of GPR <i>rt</i> is stored in memory at the location specified by the effective address.
The 16-bit signed <i>offset</i> is added to the contents of GPR <i>base</i> to form the effective address.

<b>Restrictions:</b>
None

<b>Operation:</b>
v_addr <- sign_extend(offset) + GPR[base]
(p_addr, cca) <- AddressTranslation(v_addr, DATA, LOAD)

byte_sel <- v_addr<sub>1..0</sub> xor BigEndianCPU<sub>2</sub>
data_byte <- GPR[rt]<sub>31 - 8 * byte_sel .. 0</sub> || 0<sub>8 * bytesel</sub>
StoreMemory (CCA, BYTE, data_byte, p_addr, v_addr, DATA)

<b>Exceptions:</b>
Address Error
\END

INSTRUCTION_SLL_DOCUMENTATION.=<u>Shift word left logical</u>

<b>Format:</b>
sll rd, rt, sa

|SPECIAL     0      rt     rd      sa      SLL   |
|000000                                   000000 |
|  6         5      5      5       5        6    |


<b>Description:</b>
GPR[rd] <- GPR[rt] << sa

The contents of GPR <i>rt</i> are shifted left, inserting zeros into the emptied bits. The result is placed in GPR <i>rd</i>. The bit-shift amount is specified by <i>sa</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>
GPR[rd] <- GPR[rt]<sub>31-sa..0</sub> || 0<sub>sa</sub>

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
<black>sll $zero, $zero, 0</black>, expressed as <black>NOP</black>, is the assembly idiom used to denote no operation.
\END

INSTRUCTION_SLLV_DOCUMENTATION.=<u>Shift word left logical variable</u>

<b>Format:</b>
sllv rd, rt, rs

|SPECIAL     rs     rt     rd     0      SLLV  |
|000000                                 000100 |
|  6         5      5      5      5       6    |


<b>Description:</b>
GPR[rd] <- GPR[rt] << GPR[rs]

The contents of GPR <i>rt</i> are shifted left, inserting zeros into the emptied bits. The result is placed in GPR <i>rd</i>. The bit-shift amount is specified by the low-order 5 bits of GPR <i>rs</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>
sa <- GPR[rs]<sub>4..0</sub>
GPR[rd] <- GPR[rt]<sub>31-sa..0</sub> || 0<sub>sa</sub>

<b>Exceptions:</b>
None
\END

INSTRUCTION_SLT_DOCUMENTATION.=<u>Set on less than</u>

<b>Format:</b>
slt rd, rt, rs

|SPECIAL     rs     rt     rd     0      SLT   |
|000000                                 101010 |
|  6         5      5      5      5       6    |


<b>Description:</b>
GPR[rd] <- (GPR[rs] < GPR[rt])

Compare the contents of GPR <i>rs</i> and GPR <i>rt</i> as signed integers; record the boolean result of the comparision in GPR <i>rd</i>.
If GPR <i>rs</i> is less than GPR <i>rt</i>, the result is 1 (true); otherwise, it is 0 (false).

<b>Restrictions:</b>
None

<b>Operation:</b>
if GPR[rs] < GPR[rt] then
    GPR[rd] <- 0<sub>31..0</sub> || 1
else
    GPR[rd] <- 0
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_SLTI_DOCUMENTATION.=<u>Set on less than immediate</u>

<b>Format:</b>
slti rt, rs, immediate

| SLTI       rs     rt     immediate |
|001010                              |
|  6         5      5         16     |


<b>Description:</b>
GPR[rd] <- (GPR[rs] < sign_extend(immediate))

Compare the contents of GPR <i>rs</i> and the 16-bit signed <i>immediate</i> as signed integers; record the boolean result of the comparision in GPR <i>rd</i>.
If GPR <i>rs</i> is less than <i>immediate</i>, the result is 1 (true); otherwise, it is 0 (false).

<b>Restrictions:</b>
None

<b>Operation:</b>
if GPR[rs] < sign_extend(immediate) then
    GPR[rd] <- 0<sub>31..0</sub> || 1
else
    GPR[rd] <- 0
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_SLTIU_DOCUMENTATION.=<u>Set on less than immediate unsigned</u>

<b>Format:</b>
sltiu rt, rs, immediate

| SLTIU      rs     rt     immediate |
|001011                              |
|  6         5      5         16     |


<b>Description:</b>
GPR[rd] <- (GPR[rs] < sign_extend(immediate))

Compare the contents of GPR <i>rs</i> and the 16-bit signed <i>immediate</i> as unsigned integers; record the boolean result of the comparision in GPR <i>rd</i>.
If GPR <i>rs</i> is less than <i>immediate</i>, the result is 1 (true); otherwise, it is 0 (false).

<b>Restrictions:</b>
None

<b>Operation:</b>
if (0 || GPR[rs]) < (0 || sign_extend(immediate)) then
    GPR[rd] <- 0<sub>31..0</sub> || 1
else
    GPR[rd] <- 0
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_SLTU_DOCUMENTATION.=<u>Set on less than unsigned</u>

<b>Format:</b>
sltu rd, rt, rs

|SPECIAL     rs     rt     rd     0      SLTU  |
|000000                                 101011 |
|  6         5      5      5      5       6    |


<b>Description:</b>
GPR[rd] <- (GPR[rs] < GPR[rt])

Compare the contents of GPR <i>rs</i> and GPR <i>rt</i> as unsigned integers; record the boolean result of the comparision in GPR <i>rd</i>.
If GPR <i>rs</i> is less than GPR <i>rt</i>, the result is 1 (true); otherwise, it is 0 (false).

<b>Restrictions:</b>
None

<b>Operation:</b>
if (0 || GPR[rs]) < (0 || GPR[rt]) then
    GPR[rd] <- 0<sub>31..0</sub> || 1
else
    GPR[rd] <- 0
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_SRL_DOCUMENTATION.=<u>Shift word right logical</u>

<b>Format:</b>
srl rd, rt, sa

|SPECIAL    0    R    rt    rd     sa     SRL   |
|000000          0                       000010 |
|  6        4    1    5     5      5       6    |


<b>Description:</b>
GPR[rd] <- GPR[rt] >> sa

The contents of GPR <i>rt</i> are shifted right, inserting zeros into the emptied bits. The result is placed in GPR <i>rd</i>. The bit-shift amount is specified by <i>sa</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>
GPR[rd] <- 0<sub>sa</sub> || GPR[rt]<sub>31..sa</sub>

<b>Exceptions:</b>
None
\END

INSTRUCTION_SRLV_DOCUMENTATION.=<u>Shift word right logical variable</u>

<b>Format:</b>
srlv rd, rt, rs

|SPECIAL     rs     rt     rd     0      SRLV  |
|000000                                 000110 |
|  6         5      5      5      5       6    |


<b>Description:</b>
GPR[rd] <- GPR[rt] >> GPR[rs]

The contents of GPR <i>rt</i> are shifted right, inserting zeros into the emptied bits. The result is placed in GPR <i>rd</i>. The bit-shift amount is specified by the low-order 5 bits of GPR <i>rs</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>
sa <- GPR[rs]<sub>4..0</sub>
GPR[rd] <- 0<sub>sa</sub> || GPR[rt]<sub>31..sa</sub>

<b>Exceptions:</b>
None
\END

INSTRUCTION_SUB_DOCUMENTATION.=<u>Subtraction</u>

<b>Format:</b>
sub rd, rs, rt

|SPECIAL     rs      rt     rd      0       SUB   |
|000000                                    100010 |
|  6         5       5      5       5        6    |


<b>Description:</b>
GPR[rd] <- GPR[rs] - GPR[rt]

The 32-bit word value in GPR <i>rt</i> is subtracted to the 32-bit value in GPR <i>rs</i> to produce a 32-bit result.
 - If the subtraction results in 32-bit 2's complement arithmetic overflow, the destination register is not modified and an <black>Integer Overflow</black> exception occurs.
 - If the subtraction does not overflow, the 32-bit result is placed intoto GPR <i>rd</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>
temp <- (GPR[rs]<sub>31</sub> || GPR[rs]<sub>31..0</sub>) - (GPR[rt]<sub>31</sub> || GPR[rt]<sub>31..0</sub>)
if temp<sub>32</sub> != temp<sub>31</sub> then
    SignalException(IntegerOverflow)
else
    GPR[rd] <- temp<sub>31..0</sub>
endif

<b>Exceptions:</b>
Integer Overflow

<b>Programming Notes:</b>
<black>subu</black> performs the same arithmetic operation but does not trap on overflow.
\END

INSTRUCTION_SUB_D_DOCUMENTATION.=<u>Double precision floating point subtraction</u>

<b>Format:</b>
sub.d fd, fs, ft

| COP1      fmt      0      fs      fd      SUB   |
|010001    10001   00000                   000001 |
|  6         5       5      5       5        6    |


<b>Description:</b>
FPR[fd] <- FPR[fs] - FPR[ft]

The value in FPR <i>ft</i> is subtracted to the value in FPR <i>fs</i>. The result is calculated to infinite precision, rounded using the <i>Java</i> rounding mode, and placed into FPR <i>fd</i>.
The operands and result are values in double precision floating point.

<b>Restrictions:</b>
The fields <i>fs</i>, <i>ft</i> and <i>fd</i> must be even FPRs. If the fields are not valid, the result is <black>UNPREDICTABLE</black>.
The operand must be a value in double precision floating point. If it is not, the result is <black>UNPREDICTABLE</black>.

<b>Operation:</b>
fmt <- double
StoreFPR(fd, fmt, ValueFPR(fs, fmt) -<sub>fmt</sub> ValueFPR(ft, fmt))

<b>Exceptions:</b>
None
\END

INSTRUCTION_SUB_S_DOCUMENTATION.=<u>Floating point subtraction</u>

<b>Format:</b>
sub.s fd, fs, ft

| COP1      fmt      0      fs      fd      SUB   |
|010001    10000   00000                   000001 |
|  6         5       5      5       5        6    |


<b>Description:</b>
FPR[fd] <- FPR[fs] - FPR[ft]

The value in FPR <i>ft</i> is subtracted to the value in FPR <i>fs</i>. The result is calculated to infinite precision, rounded using the <i>Java</i> rounding mode, and placed into FPR <i>fd</i>.
The operands and result are values in floating point.

<b>Restrictions:</b>
The operand must be a value in floating point. If it is not, the result is <black>UNPREDICTABLE</black>.

<b>Operation:</b>
fmt <- float
StoreFPR(fd, fmt, ValueFPR(fs, fmt) -<sub>fmt</sub> ValueFPR(ft, fmt))

<b>Exceptions:</b>
None
\END

INSTRUCTION_SUBU_DOCUMENTATION.=<u>Unsigned subtraction</u>

<b>Format:</b>
subu rd, rs, rt

|SPECIAL     rs      rt     rd      0       SUBU  |
|000000                                    100011 |
|  6         5       5      5       5        6    |


<b>Description:</b>
GPR[rd] <- GPR[rs] - GPR[rt]

The 32-bit word value in GPR <i>rt</i> is subtracted to the 32-bit value in GPR <i>rs</i> to produce a 32-bit result.
The 32-bit result is placed into GPR <i>rd</i>.
No <black>Integer Overflow</black> exception occurs under any circumstances.

<b>Restrictions:</b>
None

<b>Operation:</b>
temp <- GPR[rs] - GPR[rt]
GPR[rd] <- temp

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
The term <i>unsigned</i> in the instruction name is a misnomer; this operation is a 32-bit modulo arithmetic that does not trap on overflow. This instruction is appropiate for unsigned arithmetic, such as address arithmetic, or integer arithmetic environments that ignore overflow, such as the C language arithmetic.
\END

INSTRUCTION_SW_DOCUMENTATION.=<u>Save word</u>

<b>Format:</b>
sw rt offset(base)

|  SW      base     rt    offset |
|101011                          |
|  6        5       5       16   |


<b>Description:</b>
memory[GPR[base] + offset] <- GPR[rt]

The word of GPR <i>rt</i> is stored in memory at the location specified by the effective address.
The 16-bit signed <i>offset</i> is added to the contents of GPR <i>base</i> to form the effective address.

<b>Restrictions:</b>
None

<b>Operation:</b>
v_addr <- sign_extend(offset) + GPR[base]
(p_addr, cca) <- AddressTranslation(v_addr, DATA, LOAD)

word <- GPR[rt]
StoreMemory (CCA, WORD, word, p_addr, v_addr, DATA)

<b>Exceptions:</b>
Address Error
\END

INSTRUCTION_SYSCALL_DOCUMENTATION.=<u>System call</u>

<b>Format:</b>
syscall

|SPECIAL     0     SYSCALL |
| 00000            001100  |
|   6        20      6     |


<b>Description:</b>
System call

A System Call excepcion occurs, immediately and unconditionally transfering control to the exception handler.

<b>Restrictions:</b>
None

<b>Operation:</b>
SignalException(SystemCall)

<b>Exceptions:</b>
System Call
\END

INSTRUCTION_TEQ_DOCUMENTATION.=<u>Trap on equal</u>

<b>Format:</b>
teq rs, rt

|SPECIAL     rs      rt      0         TEQ   |
|000000                               110100 |
|  6         5       5       10         6    |


<b>Description:</b>
if GPR[rs] = GPR[rt] then Trap

Compares the contents of GPR <i>rs</i> and GPR <i>rt</i> as signed integers. If both values are equal, throws a <black>Trap</black> exception.

<b>Restrictions:</b>
None

<b>Operation:</b>
if GPR[rs] = GPR[rt] then
    SignalException(Trap)
endif

<b>Exceptions:</b>
Trap
\END

INSTRUCTION_TEQI_DOCUMENTATION.=<u>Trap on equal immediate</u>

<b>Format:</b>
teqi rs, immediate

|REGIMM      rs     TEQI     immediate |
|000001            01100               |
|  6         5       5          16     |


<b>Description:</b>
if GPR[rs] = immediate then Trap

Compares the contents of GPR <i>rs</i> and the immediate value as signed integers. If both values are equal, throws a <black>Trap</black> exception.

<b>Restrictions:</b>
None

<b>Operation:</b>
if GPR[rs] = immediate then
    SignalException(Trap)
endif

<b>Exceptions:</b>
Trap
\END

INSTRUCTION_TGE_DOCUMENTATION.=<u>Trap on greater or equal</u>

<b>Format:</b>
tge rs, rt

|SPECIAL     rs      rt      0         TGE   |
|000000                               110000 |
|  6         5       5       10         6    |


<b>Description:</b>
if GPR[rs] >= GPR[rt] then Trap

Compares the contents of GPR <i>rs</i> and GPR <i>rt</i> as signed integers. If the first value is greater or equal to the second value, throws a <black>Trap</black> exception.

<b>Restrictions:</b>
None

<b>Operation:</b>
if GPR[rs] >= GPR[rt] then
    SignalException(Trap)
endif

<b>Exceptions:</b>
Trap
\END

INSTRUCTION_TGEI_DOCUMENTATION.=<u>Trap on greater or equal immediate</u>

<b>Format:</b>
tgei rs, immediate

|REGIMM      rs     TGEI     immediate |
|000001            01000               |
|  6         5       5          16     |


<b>Description:</b>
if GPR[rs] >= immediate then Trap

Compares the contents of GPR <i>rs</i> and the immediate value as signed integers. If the first value is greater or equal to the second value, throws a <black>Trap</black> exception.

<b>Restrictions:</b>
None

<b>Operation:</b>
if GPR[rs] >= immediate then
    SignalException(Trap)
endif

<b>Exceptions:</b>
Trap
\END

INSTRUCTION_TGEIU_DOCUMENTATION.=<u>Trap on greater or equal immediate unsigned</u>

<b>Format:</b>
tgeiu rs, immediate

|REGIMM     rs     TGEIU     immediate |
|000001            01001               |
|  6         5       5          16     |


<b>Description:</b>
if GPR[rs] >= immediate then Trap

Compares the contents of GPR <i>rs</i> and the immediate value as unsigned integers. If the first value is greater or equal to the second value, throws a <black>Trap</black> exception.

<b>Restrictions:</b>
None

<b>Operation:</b>
if unsigned_word(GPR[rs]) >= unsigned_word(immediate) then
    SignalException(Trap)
endif

<b>Exceptions:</b>
Trap
\END

INSTRUCTION_TGEU_DOCUMENTATION.=<u>Trap on greater or equal unsigned</u>

<b>Format:</b>
tgeu rs, rt

|SPECIAL     rs      rt      0         TGEU  |
|000000                               110001 |
|  6         5       5       10         6    |


<b>Description:</b>
if GPR[rs] >= GPR[rt] then Trap

Compares the contents of GPR <i>rs</i> and GPR <i>rt</i> as unsigned integers. If the first value is greater or equal to the second value, throws a <black>Trap</black> exception.

<b>Restrictions:</b>
None

<b>Operation:</b>
if unsigned_word(GPR[rs]) >= unsigned_word(GPR[rt]) then
    SignalException(Trap)
endif

<b>Exceptions:</b>
Trap
\END

INSTRUCTION_TLT_DOCUMENTATION.=<u>Trap on less than</u>

<b>Format:</b>
tlt rs, rt

|SPECIAL     rs      rt      0         TLT   |
|000000                               110010 |
|  6         5       5       10         6    |


<b>Description:</b>
if GPR[rs] < GPR[rt] then Trap

Compares the contents of GPR <i>rs</i> and GPR <i>rt</i> as signed integers. If the first value is less than the second value, throws a <black>Trap</black> exception.

<b>Restrictions:</b>
None

<b>Operation:</b>
if GPR[rs] < GPR[rt] then
    SignalException(Trap)
endif

<b>Exceptions:</b>
Trap
\END

INSTRUCTION_TLTI_DOCUMENTATION.=<u>Trap on lower than immediate</u>

<b>Format:</b>
tlti rs, immediate

|REGIMM      rs     TLTI     immediate |
|000001            01010               |
|  6         5       5          16     |


<b>Description:</b>
if GPR[rs] < immediate then Trap

Compares the contents of GPR <i>rs</i> and the immediate value as signed integers. If the first value is less than the second value, throws a <black>Trap</black> exception.

<b>Restrictions:</b>
None

<b>Operation:</b>
if GPR[rs] < immediate then
    SignalException(Trap)
endif

<b>Exceptions:</b>
Trap
\END

INSTRUCTION_TLTIU_DOCUMENTATION.=<u>Trap on less than immediate unsigned</u>

<b>Format:</b>
tltiu rs, immediate

|REGIMM     rs     TLTIU     immediate |
|000001            01011               |
|  6         5       5          16     |


<b>Description:</b>
if GPR[rs] < immediate then Trap

Compares the contents of GPR <i>rs</i> and the immediate value as unsigned integers. If the first value is less than the second value, throws a <black>Trap</black> exception.

<b>Restrictions:</b>
None

<b>Operation:</b>
if unsigned_word(GPR[rs]) < unsigned_word(immediate) then
    SignalException(Trap)
endif

<b>Exceptions:</b>
Trap
\END

INSTRUCTION_TLTU_DOCUMENTATION.=<u>Trap on less than unsigned</u>

<b>Format:</b>
tltu rs, rt

|SPECIAL     rs      rt      0         TLTU  |
|000000                               110011 |
|  6         5       5       10         6    |


<b>Description:</b>
if GPR[rs] < GPR[rt] then Trap

Compares the contents of GPR <i>rs</i> and GPR <i>rt</i> as unsigned integers. If the first value is less than the second value, throws a <black>Trap</black> exception.

<b>Restrictions:</b>
None

<b>Operation:</b>
if unsigned_word(GPR[rs]) < unsigned_word(GPR[rt]) then
    SignalException(Trap)
endif

<b>Exceptions:</b>
Trap
\END

INSTRUCTION_TNE_DOCUMENTATION.=<u>Trap on not equal</u>

<b>Format:</b>
tne rs, rt

|SPECIAL     rs      rt      0         TNE   |
|000000                               110110 |
|  6         5       5       10         6    |


<b>Description:</b>
if GPR[rs] != GPR[rt] then Trap

Compares the contents of GPR <i>rs</i> and GPR <i>rt</i> as signed integers. If both values are not equal, throws a <black>Trap</black> exception.

<b>Restrictions:</b>
None

<b>Operation:</b>
if GPR[rs] != GPR[rt] then
    SignalException(Trap)
endif

<b>Exceptions:</b>
Trap
\END

INSTRUCTION_TNEI_DOCUMENTATION.=<u>Trap on not equal immediate</u>

<b>Format:</b>
tnei rs, immediate

|REGIMM      rs     TNEI     immediate |
|000001            01110               |
|  6         5       5          16     |


<b>Description:</b>
if GPR[rs] != immediate then Trap

Compares the contents of GPR <i>rs</i> and the immediate value as signed integers. If both values are not equal, throws a <black>Trap</black> exception.

<b>Restrictions:</b>
None

<b>Operation:</b>
if GPR[rs] != immediate then
    SignalException(Trap)
endif

<b>Exceptions:</b>
Trap
\END


INSTRUCTION_XOR_DOCUMENTATION.=<u>Xor</u>

<b>Format:</b>
xor rd, rs, rt

|SPECIAL     rs      rt     rd      0        XOR  |
|000000                                    100110 |
|  6         5       5      5       5        6    |


<b>Description:</b>
GPR[rd] <- GPR[rs] xor GPR[rt]

Performs a bitwise logical XOR using the values inside GPR <i>rs</i> and GPR <i>rt</i>.
The result is placed into GPR <i>rd</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>
GPR[rd] <- GPR[rs] xor GPR[rt]

<b>Exceptions:</b>
None
\END

INSTRUCTION_XORI_DOCUMENTATION.=<u>Immediate xor</u>

<b>Format:</b>
xori rt, rs, immediate

| XORI      rs     rt     immediate |
|001110                             |
|  6        5      5         16     |


<b>Description:</b>
GPR[rt] <- GPR[rs] xor zero_extend(immediate)

The 16-bit <i>immediate</i> is zero-extended to the left and combined with the value of GPR <i>rs</i> in a bitwise logical XOR operation.
The result is placed into GPR <i>rt</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>
GPR[rt] <- GPR[rs] xor zero_extend(immediate)

<b>Exceptions:</b>
None
\END

INSTRUCTION_ADDI_DOCUMENTATION.=<u>Immediate addition with overflow</u>

<b>Format:</b>
addi rt, rs, immediate

<b>Conversion:</b>
addiu $at, $zero, immediate
add rt, $at, rs

<b>Description:</b>
GPR[rt] <- GPR[rs] + immediate

The 16-bit signed <i>immediate</i> is added to the 32-bit value in GRP <i>rs</i> to produce a 32-bit arithmetic result.
 - If the adition results in 32-bit 2's complement arithmetic overflow, the destination register is not modified and an <black>Integer Overflow</black> exception occurs.
 - If the addition does not overflow, the 32-bit result is placed into GPR <i>rt</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>
temp <- (GPR[rs]<sub>31</sub> || GPR[rs]<sub>31..0</sub>) + (immediate<sub>31</sub> || immediate<sub>31..0</sub>)
if temp<sub>32</sub> != temp<sub>31</sub> then
    SignalException(IntegerOverflow)
else
    GPR[rt] <- temp<sub>31..0</sub>
endif

<b>Exceptions:</b>
Integer Overflow

<b>Programming Notes:</b>
<black>addiu</black> performs the same arithmetic operation but does not trap on overflow.
\END

INSTRUCTION_B_DOCUMENTATION.=<u>Unconditional branch</u>

<b>Format:</b>
b offset

<b>Conversion:</b>
beq $zero, $zero, offset

<b>Description:</b>
An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
Branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
With the 18-bit signed instruction offset, the conditional branch range is ±128KBytes. Use jump (<black>j</black>) or jump register (<black>jr</black>) to branch to addresses outside this range.
<black>beq $zero, $zero, offset</black>, expressed as <black>b offset</black>, is the assembly idiom used to denote an unconditional branch.
\END

INSTRUCTION_JR_DOCUMENTATION.=<u>Jump register</u>

<b>Format:</b>
jr rs

<b>Conversion:</b>
jr $zero, rs

<b>Description:</b>
Jump to the effective target addres in GPR <i>rs</i>. If the target address is not 4-bytes aligned, an Address Error exception will occur when the target address is fetched.
If delay slots are enabled, this instruction also executes the instruction that follows the jump, in the branch delay slot, before executing the jump itself.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>,  <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Exceptions:</b>
None
\END

INSTRUCTION_LA_DOCUMENTATION.=<u>Load address</u>

<b>Format:</b>
la rs, label

<b>Conversion:</b>
address <- get_address(label)
aui $at, $zero, address<sub>31..16</sub>
ori rs, $at, address<sub>15..0</sub>

<b>Description:</b>
Loads the address of the <i>label</i> into GPR <i>rs</i>.

<b>Restrictions:</b>
None

<b>Exceptions:</b>
None
\END

INSTRUCTION_LI_DOCUMENTATION.=<u>Load immediate</u>

<b>Format:</b>
li rs, number

<b>Conversion:</b>
if number<sub>31..16</sub> = 0
    addiu rs, $zero, number<sub>15..0</sub>
else
    aui $at, $zero, number<sub>31..16</sub>
    ori rs, $at, number<sub>15..0</sub>
endif

<b>Description:</b>
Loads the <i>number</i> into GPR <i>rs</i>.

<b>Restrictions:</b>
None

<b>Exceptions:</b>
None
\END

INSTRUCTION_LUI_DOCUMENTATION.=<u>Load upper immediate</u>

<b>Format:</b>
lui rs, number

<b>Conversion:</b>
aui rs, $zero, number<sub>15..0</sub>

<b>Description:</b>
Loads the <i>number</i> into the upper part of GPR <i>rs</i>.

<b>Restrictions:</b>
None

<b>Exceptions:</b>
None
\END

INSTRUCTION_LIF_DOCUMENTATION.=<u>Load immediate float</u>

<b>Format:</b>
lif fd, float

<b>Conversion:</b>
aui $at, $zero, float<sub>31..16</sub>
ori $at, $at, float<sub>15..0</sub>
mtc1 $at, fd

<b>Description:</b>
Loads the <i>float</i> into the FPR <i>fd</i>.

<b>Restrictions:</b>
None

<b>Exceptions:</b>
None
\END

INSTRUCTION_MOVE_DOCUMENTATION.=<u>Value movement</u>

<b>Format:</b>
move rd, rs

<b>Conversion:</b>
add rd, $zero, rs

<b>Description:</b>
GPR[rd] <- GPR[rs]

Moves the contents of the GPR <i>rs</i> to the GPR <i>rd</i>.

<b>Restrictions:</b>
None

<b>Exceptions:</b>
None
\END

INSTRUCTION_NOP_DOCUMENTATION.=<u>No operation</u>

<b>Format:</b>
nop

<b>Conversion:</b>
sll $zero, $zero, $zero

<b>Description:</b>
No operation. Does nothing.

<b>Restrictions:</b>
None

<b>Exceptions:</b>
None
\END

INSTRUCTION_SGE_DOCUMENTATION.=<u>Set on greater than or equal</u>

<b>Format:</b>
sge rd, rt, rs

<b>Conversion:</b>
slt rd, rt, rs
ori $at, $zero, 1
subu rd, $at, rd

<b>Description:</b>
GPR[rd] <- (GPR[rs] >= GPR[rt])

Compare the contents of GPR <i>rs</i> and GPR <i>rt</i> as signed integers; record the boolean result of the comparision in GPR <i>rd</i>.
If GPR <i>rs</i> is greater than or equal GPR <i>rt</i>, the result is 1 (true); otherwise, it is 0 (false).

<b>Restrictions:</b>
None

<b>Exceptions:</b>
None
\END

INSTRUCTION_SGEI_DOCUMENTATION.=<u>Set on greater than or equal immediate</u>

<b>Format:</b>
sgei rt, rs, immediate

<b>Conversion:</b>
slti rt, rs, immediate
ori $at, $zero, 1
subu rd, $at, rd

<b>Description:</b>
GPR[rd] <- (GPR[rs] >= sign_extend(immediate))

Compare the contents of GPR <i>rs</i> and the 16-bit signed <i>immediate</i> as signed integers; record the boolean result of the comparision in GPR <i>rd</i>.
If GPR <i>rs</i> is greater than or equal <i>immediate</i>, the result is 1 (true); otherwise, it is 0 (false).

<b>Restrictions:</b>
None

<b>Exceptions:</b>
None
\END

INSTRUCTION_SGEIU_DOCUMENTATION.=<u>Set on greater than or equal immediate unsigned</u>

<b>Format:</b>
sgeiu rt, rs, immediate

<b>Conversion:</b>
sltiu rt, rs, immediate
ori $at, $zero, 1
subu rd, $at, rd

<b>Description:</b>
GPR[rd] <- (GPR[rs] >= sign_extend(immediate))

Compare the contents of GPR <i>rs</i> and the 16-bit signed <i>immediate</i> as unsigned integers; record the boolean result of the comparision in GPR <i>rd</i>.
If GPR <i>rs</i> is greater than or equal <i>immediate</i>, the result is 1 (true); otherwise, it is 0 (false).

<b>Restrictions:</b>
None

<b>Exceptions:</b>
None
\END

INSTRUCTION_SGEU_DOCUMENTATION.=<u>Set on greater than or equal unsigned</u>

<b>Format:</b>
sgeu rd, rt, rs

<b>Conversion:</b>
sltu rd, rt, rs
ori $at, $zero, 1
subu rd, $at, rd

<b>Description:</b>
GPR[rd] <- (GPR[rs] >= GPR[rt])

Compare the contents of GPR <i>rs</i> and GPR <i>rt</i> as unsigned integers; record the boolean result of the comparision in GPR <i>rd</i>.
If GPR <i>rs</i> is greater than or equal GPR <i>rt</i>, the result is 1 (true); otherwise, it is 0 (false).

<b>Restrictions:</b>
None

<b>Exceptions:</b>
None
\END

INSTRUCTION_SGT_DOCUMENTATION.=<u>Set on greater than or equal</u>

<b>Format:</b>
sgt rd, rt, rs

<b>Conversion:</b>
slt rd, rs, rt

<b>Description:</b>
GPR[rd] <- (GPR[rs] > GPR[rt])

Compare the contents of GPR <i>rs</i> and GPR <i>rt</i> as signed integers; record the boolean result of the comparision in GPR <i>rd</i>.
If GPR <i>rs</i> is greater than GPR <i>rt</i>, the result is 1 (true); otherwise, it is 0 (false).

<b>Restrictions:</b>
None

<b>Exceptions:</b>
None
\END

INSTRUCTION_SGTI_DOCUMENTATION.=<u>Set on greater than immediate</u>

<b>Format:</b>
sgti rt, rs, immediate

<b>Conversion:</b>
addiu $at, $zero, immediate
slt rd, $at, rs

<b>Description:</b>
GPR[rd] <- (GPR[rs] > sign_extend(immediate))

Compare the contents of GPR <i>rs</i> and the 16-bit signed <i>immediate</i> as signed integers; record the boolean result of the comparision in GPR <i>rd</i>.
If GPR <i>rs</i> is greater than <i>immediate</i>, the result is 1 (true); otherwise, it is 0 (false).

<b>Restrictions:</b>
None

<b>Exceptions:</b>
None
\END

INSTRUCTION_SGTIU_DOCUMENTATION.=<u>Set on greater than immediate unsigned</u>

<b>Format:</b>
sgtiu rt, rs, immediate

<b>Conversion:</b>
addiu $at, $zero, immediate
sltu rd, $at, rs

<b>Description:</b>
GPR[rd] <- (GPR[rs] > sign_extend(immediate))

Compare the contents of GPR <i>rs</i> and the 16-bit signed <i>immediate</i> as unsigned integers; record the boolean result of the comparision in GPR <i>rd</i>.
If GPR <i>rs</i> is greater than <i>immediate</i>, the result is 1 (true); otherwise, it is 0 (false).

<b>Restrictions:</b>
None

<b>Exceptions:</b>
None
\END

INSTRUCTION_SGTU_DOCUMENTATION.=<u>Set on greater than unsigned</u>

<b>Format:</b>
sgtu rd, rt, rs

<b>Conversion:</b>
sltu rd, rs, rt

<b>Description:</b>
GPR[rd] <- (GPR[rs] > GPR[rt])

Compare the contents of GPR <i>rs</i> and GPR <i>rt</i> as unsigned integers; record the boolean result of the comparision in GPR <i>rd</i>.
If GPR <i>rs</i> is greater than GPR <i>rt</i>, the result is 1 (true); otherwise, it is 0 (false).

<b>Restrictions:</b>
None

<b>Exceptions:</b>
None
\END

INSTRUCTION_SLE_DOCUMENTATION.=<u>Set on less than or equal</u>

<b>Format:</b>
sle rd, rt, rs

<b>Conversion:</b>
slt rd, rs, rt
ori $at, $zero, 1
subu rd, $at, rd

<b>Description:</b>
GPR[rd] <- (GPR[rs] <= GPR[rt])

Compare the contents of GPR <i>rs</i> and GPR <i>rt</i> as signed integers; record the boolean result of the comparision in GPR <i>rd</i>.
If GPR <i>rs</i> is less than or equal GPR <i>rt</i>, the result is 1 (true); otherwise, it is 0 (false).

<b>Restrictions:</b>
None

<b>Exceptions:</b>
None
\END

INSTRUCTION_SLEI_DOCUMENTATION.=<u>Set on less than or equal immediate</u>

<b>Format:</b>
slei rt, rs, immediate

<b>Conversion:</b>
addiu $at, $zero, immediate
slt rd, $at, rs
ori $at, $zero, 1
subu rd, $at, rd

<b>Description:</b>
GPR[rd] <- (GPR[rs] <= sign_extend(immediate))

Compare the contents of GPR <i>rs</i> and the 16-bit signed <i>immediate</i> as signed integers; record the boolean result of the comparision in GPR <i>rd</i>.
If GPR <i>rs</i> is less than or equal <i>immediate</i>, the result is 1 (true); otherwise, it is 0 (false).

<b>Restrictions:</b>
None

<b>Exceptions:</b>
None
\END

INSTRUCTION_SLEIU_DOCUMENTATION.=<u>Set on less than or equal immediate unsigned</u>

<b>Format:</b>
sleiu rt, rs, immediate

<b>Conversion:</b>
addiu $at, $zero, immediate
sltu rd, $at, rs
ori $at, $zero, 1
subu rd, $at, rd

<b>Description:</b>
GPR[rd] <- (GPR[rs] <= sign_extend(immediate))

Compare the contents of GPR <i>rs</i> and the 16-bit signed <i>immediate</i> as unsigned integers; record the boolean result of the comparision in GPR <i>rd</i>.
If GPR <i>rs</i> is less than or equal <i>immediate</i>, the result is 1 (true); otherwise, it is 0 (false).

<b>Restrictions:</b>
None

<b>Exceptions:</b>
None
\END

INSTRUCTION_SLEU_DOCUMENTATION.=<u>Set on less than or equal unsigned</u>

<b>Format:</b>
sleu rd, rt, rs

<b>Conversion:</b>
sltu rd, rs, rt
ori $at, $zero, 1
subu rd, $at, rd

<b>Description:</b>
GPR[rd] <- (GPR[rs] <= GPR[rt])

Compare the contents of GPR <i>rs</i> and GPR <i>rt</i> as unsigned integers; record the boolean result of the comparision in GPR <i>rd</i>.
If GPR <i>rs</i> is less than or equal GPR <i>rt</i>, the result is 1 (true); otherwise, it is 0 (false).

<b>Restrictions:</b>
None

<b>Exceptions:</b>
None
\END

DIRECTIVE_ALIGN_DOCUMENTATION.=<u>Align</u>

<b>Format:</b>
.align <0-3>

<b>Description:</b>
Aligns the next memory insertion to a 2^n multiple address.

\END

DIRECTIVE_ASCII_DOCUMENTATION.=<u>Insert ASCII strings</u>

<b>Format:</b>
.ascii {"Text"}

<b>Description:</b>
Inserts into the memory the given ASCII strings.

\END

DIRECTIVE_ASCIIZ_DOCUMENTATION.=<u>Insert ASCII strings, ending with a null character</u>

<b>Format:</b>
.asciiz {"Text"}

<b>Description:</b>
Inserts into the memory the given ASCII strings, adding at the end of each string a null (\0) character.

\END

DIRECTIVE_BYTE_DOCUMENTATION.=<u>Insert bytes</u>

<b>Format:</b>
.byte {byte | 'char'}

<b>Description:</b>
Inserts into the memory the given bytes.

\END

DIRECTIVE_DATA_DOCUMENTATION.=<u>Change to data section</u>

<b>Format:</b>
.data [address]

<b>Description:</b>
Makes the next memory insertions to be placed into the data section.
If an address is given, the next memory insertions will be placed starting from the given address.

\END

DIRECTIVE_BYTE_DOCUMENTATION.=<u>Insert doubles</u>

<b>Format:</b>
.byte {double}

<b>Description:</b>
Inserts into the memory the given doubles.

\END

DIRECTIVE_DWORD_DOCUMENTATION.=<u>Insert double words / longs</u>

<b>Format:</b>
.dword {dword}

<b>Description:</b>
Inserts into the memory the given double words.

\END

DIRECTIVE_ENDMACRO_DOCUMENTATION.=<u>End macro</u>

<b>Format:</b>
.endmacro

<b>Description:</b>
Ends the current macro definition.
If no macro is being defined this directive will be ignored.

\END

DIRECTIVE_EQV_DOCUMENTATION.=<u>Equivalent</u>

<b>Format:</b>
.eqv <key> <value>

<b>Description:</b>
Replaces the key in the following lines of the file with the value.

<b>Programming Notes:</b>
Avoid using this directive for complex replacements.
It should be used only for registers and immediates.

\END

DIRECTIVE_ERR_DOCUMENTATION.=<u>Error</u>

<b>Format:</b>
.err

<b>Description:</b>
Produces an assemble exception.

\END

DIRECTIVE_EXTERN_DOCUMENTATION.=<u>Allocate extern memory</u>

<b>Format:</b>
.extern <label> <amount>

<b>Description:</b>
Allocates the given amount of bytes into the extern section of the memory.
The created label will be considered a global label.

\END

DIRECTIVE_FLOAT_DOCUMENTATION.=<u>Insert float</u>

<b>Format:</b>
.float {float}

<b>Description:</b>
Inserts into the memory the given floats.

\END

DIRECTIVE_GLOBL_DOCUMENTATION.=<u>Make label global</u>

<b>Format:</b>
.globl <label>

<b>Description:</b>
Makes the given label global.

\END

DIRECTIVE_HALF_DOCUMENTATION.=<u>Insert half words</u>

<b>Format:</b>
.half {half word}

<b>Description:</b>
Inserts into the memory the given half words.

\END

DIRECTIVE_INCLUDE_DOCUMENTATION.=<u>Include file</u>

<b>Format:</b>
.include <file>

<b>Description:</b>

Replaces this directive with the contents of the given file.

<b>Programming Notes:</b>
Avoid using this directive: it may cause recursive loops and prevents the inspector from working properly.

\END

DIRECTIVE_KDATA_DOCUMENTATION.=<u>Change to kernel data section</u>

<b>Format:</b>
.kdata [address]

<b>Description:</b>
Makes the next memory insertions to be placed into the kernel data section.
If an address is given, the next memory insertions will be placed starting from the given address.

\END

DIRECTIVE_KTEXT_DOCUMENTATION.=<u>Change to kernel text section</u>

<b>Format:</b>
.ktext [address]

<b>Description:</b>
Makes the next memory insertions to be placed into the kernel text section.
If an address is given, the next memory insertions will be placed starting from the given address.

\END


DIRECTIVE_LAB_DOCUMENTATION.=<u>Create label</u>

<b>Format:</b>
.lab <label>

<b>Description:</b>
Creates the given label.

DIRECTIVE_MACRO_DOCUMENTATION.=<u>Macro</u>

<b>Format:</b>
.macro <name>
.macro <name> ()
.macro <name> ({%parameter})

<b>Description:</b>
Starts a macro definition.
A macro can be used to define a set of instructions that will be used constantly.
Macros can have parameters. All parameters should start with "%" and they will
replaced when a call to the macro is executed.

A macro call must have this format: name (param1, param2). The space between the name and the first parentheses can be replaced with a comma or a tab.

<b>Example:</b>

This code creates a macro that prints a string:

	.macro print (%string)
	.data
text:	.asciiz %string
	.text
	la $a0, text
	li $v0, 4
	syscall
	.endmacro
	.text
	print ("Hi!\n")
	print ("I'm using macros!\n")


Output:

Hi!
I'm using macros!

\END

DIRECTIVE_SPACE_DOCUMENTATION.=<u>Allocate memory</u>

<b>Format:</b>
.space <amount>

<b>Description:</b>
Allocates the given amount of bytes into memory.

\END

DIRECTIVE_KTEXT_DOCUMENTATION.=<u>Change to text section</u>

<b>Format:</b>
.text [address]

<b>Description:</b>
Makes the next memory insertions to be placed into the text section.
If an address is given, the next memory insertions will be placed starting from the given address.

\END

DIRECTIVE_WORD_DOCUMENTATION.=<u>Insert words</u>

<b>Format:</b>
.word {word | label}

<b>Description:</b>
Inserts into the memory the given words.
If a label is given, its address will be inserted instead.

\END

FLOAT_CONDITION_AF=Always false
FLOAT_CONDITION_UN=Unordered
FLOAT_CONDITION_EQ=Equal
FLOAT_CONDITION_UEQ=Unordered or equal
FLOAT_CONDITION_LT=Ordered less than
FLOAT_CONDITION_ULT=Unordered or less than
FLOAT_CONDITION_LE=Ordered less than or equal
FLOAT_CONDITION_ULE=Unordered or less than or equal
FLOAT_CONDITION_SAF=Signaling always false
FLOAT_CONDITION_SUN=Signaling unordered
FLOAT_CONDITION_SEQ=Ordered signaling equal
FLOAT_CONDITION_SUEQ=Signaling unordered or equal
FLOAT_CONDITION_SLT=Ordered signaling less than
FLOAT_CONDITION_SULT=Signaling unordered or less than
FLOAT_CONDITION_SLE=Ordered signaling less than or equal
FLOAT_CONDITION_SULE=Signaling unordered or less than or equal
FLOAT_CONDITION_OR=Ordered
FLOAT_CONDITION_UNE=Not equal
FLOAT_CONDITION_NE=Ordered not equal
FLOAT_CONDITION_SOR=Signalling ordered
FLOAT_CONDITION_SUNE=Signalling unordered or not equal
FLOAT_CONDITION_SNE=Signalling ordered not equal

FMT_SINGLE=single
FMT_DOUBLE=double
FMT_WORD=word
FMT_LONG=long

ABOUT=JAMS\nVersion {VERSION}\n\nCopyright 2020-2021\nMade by Gael Rial Costas