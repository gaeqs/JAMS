English

GENERAL_CONFIRM=Confirm
GENERAL_OK=Ok
GENERAL_FINISH=Finish
GENERAL_CANCEL=Cancel
GENERAL_CONFIRMATION=Confirmation
GENERAL_ADD=Add
GENERAL_REMOVE=Remove
GENERAL_COPY=Copy
GENERAL_PASTE=Paste
GENERAL_SORT=Sort

START_TITLE=JAMS
START_SUBTITLE=Version {VERSION}

MAIN_MENU_FILE=File
MAIN_MENU_EDIT=Edit
MAIN_MENU_MIPS=MIPS
MAIN_MENU_HELP=Help

MAIN_MENU_FILE_EXIT=Exit
MAIN_MENU_FILE_SETTINGS=Settings
MAIN_MENU_FILE_OPEN_PROJECT=Open project
MAIN_MENU_FILE_CREATE_PROJECT=Create project
MAIN_MENU_FILE_CREATE_PROJECT_TITLE=Create project
MAIN_MENU_FILE_CREATE_PROJECT_NAME=Name:
MAIN_MENU_FILE_CREATE_PROJECT_PATH=Path:

MAIN_MENU_HELP_ABOUT=About

PROJECT_TAB_STRUCTURE=Project structure
PROJECT_TAB_SIMULATION=Simulation

BAR_EXPLORER_NAME=Explorer
BAR_FILES_TO_ASSEMBLE_NAME=Files to assemble
BAR_LOG_NAME=Log

SIMULATION_CONFIGURATION_CONFIGURATIONS=Configurations:
SIMULATION_CONFIGURATION_INFO=Configurations settings
SIMULATION_CONFIGURATION_GENERAL=General
SIMULATION_CONFIGURATION_GENERAL_REGION=General settings
SIMULATION_CONFIGURATION_NAME=Name:
SIMULATION_CONFIGURATION_ARCHITECTURE=Architecture:
SIMULATION_CONFIGURATION_ARCHITECTURE_TOOLTIP=The architecture the simulation will use.\n\nSome options are only available in specific architectures.
SIMULATION_CONFIGURATION_MEMORY=Memory:
SIMULATION_CONFIGURATION_MEMORY_TOOLTIP=The memory the simulation will use.
SIMULATION_CONFIGURATION_CALL_EVENTS=Call memory, registers and instructions events.
SIMULATION_CONFIGURATION_CALL_EVENTS_TOOLTIP=Allows the simulation to notify memory, registers and instructions' changes.\n\nIf this option is disabled, the simulation will work faster, but some debugger and plug-ins' options won't work. Events will work when the simulation is stopped.
SIMULATION_CONFIGURATION_ENABLE_UNDO=Allow to undo steps
SIMULATION_CONFIGURATION_ENABLE_UNDO_TOOLTIP=Allows you to undo simulation's steps.\n\nIf this option is disabled, the simulation will work faster and it will consume less memory, but you will be unable to undo steps.\n\nThis option requires events to be activated.
SIMULATION_CONFIGURATION_ENABLE_FORWARDING=Enable forwarding
SIMULATION_CONFIGURATION_ENABLE_FORWARDING_TOOLTIP=Allows instructions to forward data on a pipelined architecture.
SIMULATION_CONFIGURATION_SOLVE_BRANCH_ON_DECODE=Solve branches on decode
SIMULATION_CONFIGURATION_SOLVE_BRANCH_ON_DECODE_TOOLTIP=Allows to solve branches on decode. This only works on architectures with multiple steps.
SIMULATION_CONFIGURATION_ENABLE_DELAY_SLOTS=Use delay slots
SIMULATION_CONFIGURATION_ENABLE_DELAY_SLOTS_TOOLTIP=Enable delay slots.\n\nIf this option is enabled, the instruction right after an non-compact transfer control instruction will be always executed.
SIMULATION_CONFIGURATION_SYSTEM_CALLS_TAB=System calls
SIMULATION_CONFIGURATION_SYSTEM_CALLS_TAB_LOAD_BUNDLE=Load bundle
SIMULATION_CONFIGURATION_SYSTEM_CALLS_TAB_PROPERTIES=Call properties
SIMULATION_CONFIGURATION_CACHES_TAB=Caches
SIMULATION_CONFIGURATION_CACHES_TAB_PROPERTIES=Cache properties
SIMULATION_CONFIGURATION_CACHES_TAB_INFO=Cache info
SIMULATION_CONFIGURATION_CACHES_TAB_SIZE=Cache size:


SYSCALL_RUN_EXCEPTION_HANDLER=X Run exception handler

SYSCALL_PRINT_INTEGER=SPIM 1 Print integer
SYSCALL_PRINT_INTEGER_PROPERTY_PRINT_HEX=Print hex number
SYSCALL_PRINT_INTEGER_PROPERTY_LINE_JUMP=Add line jump
SYSCALL_PRINT_INTEGER_PROPERTY_REGISTER=Register

SYSCALL_PRINT_FLOAT=SPIM 2 Print float
SYSCALL_PRINT_FLOAT_PROPERTY_PRINT_HEX=Print hex number
SYSCALL_PRINT_FLOAT_PROPERTY_LINE_JUMP=Add line jump
SYSCALL_PRINT_FLOAT_PROPERTY_REGISTER=Register

SYSCALL_PRINT_DOUBLE=SPIM 3 Print double
SYSCALL_PRINT_DOUBLE_PROPERTY_PRINT_HEX=Print hex number
SYSCALL_PRINT_DOUBLE_PROPERTY_LINE_JUMP=Add line jump
SYSCALL_PRINT_DOUBLE_PROPERTY_REGISTER=Register

SYSCALL_PRINT_STRING=SPIM 4 Print string
SYSCALL_PRINT_STRING_PROPERTY_LINE_JUMP=Add line jump
SYSCALL_PRINT_STRING_PROPERTY_MAX_CHARACTERS=Max characters
SYSCALL_PRINT_STRING_PROPERTY_REGISTER=Register

SYSCALL_READ_INTEGER=SPIM 5 Read integer
SYSCALL_READ_INTEGER_PROPERTY_LINE_JUMP=Add line jump
SYSCALL_READ_INTEGER_PROPERTY_REGISTER=Register

SYSCALL_READ_FLOAT=SPIM 6 Read float
SYSCALL_READ_FLOAT_PROPERTY_LINE_JUMP=Add line jump
SYSCALL_READ_FLOAT_PROPERTY_REGISTER=Register

SYSCALL_READ_DOUBLE=SPIM 7 Read double
SYSCALL_READ_DOUBLE_PROPERTY_LINE_JUMP=Add line jump
SYSCALL_READ_DOUBLE_PROPERTY_REGISTER=Register

SYSCALL_READ_STRING=SPIM 8 Read string
SYSCALL_READ_STRING_PROPERTY_LINE_JUMP=Add line jump
SYSCALL_READ_STRING_PROPERTY_ADDRESS_REGISTER=Address register
SYSCALL_READ_STRING_PROPERTY_MAX_CHARS_REGISTER=Max chars register

SYSCALL_ALLOCATE_MEMORY=SPIM 9 Allocate memory
SYSCALL_ALLOCATE_MEMORY_PROPERTY_AMOUNT_REGISTER=Amount register
SYSCALL_ALLOCATE_MEMORY_PROPERTY_ADDRESS_REGISTER=Address register

SYSCALL_EXIT=SPIM 10 Exit

SYSCALL_PRINT_CHARACTER=SPIM 11 Print char
SYSCALL_PRINT_CHARACTER_PROPERTY_LINE_JUMP=Add line jump
SYSCALL_PRINT_CHARACTER_PROPERTY_REGISTER=Register

SYSCALL_READ_CHARACTER=SPIM 12 Read char
SYSCALL_READ_CHARACTER_PROPERTY_LINE_JUMP=Add line jump
SYSCALL_READ_CHARACTER_PROPERTY_REGISTER=Register

SYSCALL_OPEN_FILE=SPIM 13 Open file
SYSCALL_OPEN_FILE_PROPERTY_NAME_REGISTER=Name register
SYSCALL_OPEN_FILE_PROPERTY_FLAG_REGISTER=Flag register
SYSCALL_OPEN_FILE_PROPERTY_MODE_REGISTER=Mode register
SYSCALL_OPEN_FILE_PROPERTY_RESULT_REGISTER=Result register

SYSCALL_READ_FILE=SPIM 14 Read from file
SYSCALL_READ_FILE_PROPERTY_ID_REGISTER=Id register
SYSCALL_READ_FILE_PROPERTY_ADDRESS_REGISTER=Address register
SYSCALL_READ_FILE_PROPERTY_MAX_BYTES_REGISTER=Max bytes register
SYSCALL_READ_FILE_PROPERTY_RESULT_REGISTER=Result register

SYSCALL_WRITE_FILE=SPIM 15 Write to file
SYSCALL_WRITE_FILE_PROPERTY_ID_REGISTER=Id register
SYSCALL_WRITE_FILE_PROPERTY_ADDRESS_REGISTER=Address register
SYSCALL_WRITE_FILE_PROPERTY_AMOUNT_REGISTER=Amount register
SYSCALL_WRITE_FILE_PROPERTY_RESULT_REGISTER=Result register

SYSCALL_CLOSE_FILE=SPIM 16 Close file
SYSCALL_CLOSE_FILE_PROPERTY_ID_REGISTER=Id register

SYSCALL_EXIT_WITH_VALUE=SPIM 17 Exit with value
SYSCALL_EXIT_WITH_VALUE_PROPERTY_REGISTER=Register

SYSCALL_SYSTEM_TIME=MARS 30 System time
SYSCALL_SYSTEM_TIME_PROPERTY_LOW_REGISTER=Low value register
SYSCALL_SYSTEM_TIME_PROPERTY_HIGH_REGISTER=High value register

SYSCALL_SLEEP=MARS 32 Sleep
SYSCALL_SLEEP_PROPERTY_REGISTER=Register

SYSCALL_PRINT_HEXADECIMAL_INTEGER=MARS 34 Print hexadecimal integer
SYSCALL_PRINT_HEXADECIMAL_INTEGER_PROPERTY_LINE_JUMP=Add line jump
SYSCALL_PRINT_HEXADECIMAL_INTEGER_PROPERTY_REGISTER=Register

SYSCALL_PRINT_BINARY_INTEGER=MARS 35 Print binary integer
SYSCALL_PRINT_BINARY_INTEGER_PROPERTY_LINE_JUMP=Add line jump
SYSCALL_PRINT_BINARY_INTEGER_PROPERTY_REGISTER=Register

SYSCALL_PRINT_UNSIGNED_INTEGER=MARS 36 Print unsigned integer
SYSCALL_PRINT_UNSIGNED_INTEGER_PROPERTY_LINE_JUMP=Add line jump
SYSCALL_PRINT_UNSIGNED_INTEGER_PROPERTY_REGISTER=Register

SYSCALL_SET_SEED=MARS 40 Set seed
SYSCALL_SET_SEED_PROPERTY_GENERATOR_REGISTER=Generator register
SYSCALL_SET_SEED_PROPERTY_SEED_REGISTER=Seed register

SYSCALL_RANDOM_INTEGER=MARS 41 Random integer
SYSCALL_RANDOM_INTEGER_PROPERTY_GENERATOR_REGISTER=Generator register
SYSCALL_RANDOM_INTEGER_PROPERTY_VALUE_REGISTER=Value register

SYSCALL_RANDOM_RANGED_INTEGER=MARS 42 Random ranged integer
SYSCALL_RANDOM_RANGED_INTEGER_PROPERTY_GENERATOR_REGISTER=Generator register
SYSCALL_RANDOM_RANGED_INTEGER_PROPERTY_RANGE_REGISTER=Range register
SYSCALL_RANDOM_RANGED_INTEGER_PROPERTY_VALUE_REGISTER=Value register

SYSCALL_RANDOM_FLOAT=MARS 43 Random float
SYSCALL_RANDOM_FLOAT_PROPERTY_GENERATOR_REGISTER=Generator register
SYSCALL_RANDOM_FLOAT_PROPERTY_VALUE_REGISTER=Value register

SYSCALL_RANDOM_DOUBLE=MARS 44 Random double
SYSCALL_RANDOM_DOUBLE_PROPERTY_GENERATOR_REGISTER=Generator register
SYSCALL_RANDOM_DOUBLE_PROPERTY_VALUE_REGISTER=Value register

CACHE_DIRECT=Direct mapping
CACHE_DIRECT_PROPERTY_WRITE_BACK=Write-back mode
CACHE_DIRECT_PROPERTY_BLOCK_SIZE=Block size (words)
CACHE_DIRECT_PROPERTY_BLOCKS_AMOUNT=Blocks

CACHE_ASSOCIATIVE=Associative mapping
CACHE_ASSOCIATIVE_PROPERTY_WRITE_BACK=Write-back mode
CACHE_ASSOCIATIVE_PROPERTY_BLOCK_SIZE=Block size (words)
CACHE_ASSOCIATIVE_PROPERTY_BLOCKS_AMOUNT=Blocks
CACHE_ASSOCIATIVE_PROPERTY_REPLACEMENT_POLICY=Replacement policy

CACHE_SET_ASSOCIATIVE=Set-associative mapping
CACHE_SET_ASSOCIATIVE_PROPERTY_WRITE_BACK=Write-back mode
CACHE_SET_ASSOCIATIVE_PROPERTY_BLOCK_SIZE=Block size (words)
CACHE_SET_ASSOCIATIVE_PROPERTY_BLOCKS_AMOUNT=Blocks
CACHE_SET_ASSOCIATIVE_PROPERTY_SET_SIZE=Set size
CACHE_SET_ASSOCIATIVE_PROPERTY_REPLACEMENT_POLICY=Replacement policy

SIMULATION_BUTTON_TOOLTIP_EXECUTE_ALL=Execute all instructions
SIMULATION_BUTTON_TOOLTIP_STOP=Stop
SIMULATION_BUTTON_TOOLTIP_EXECUTE_ONE=Execute one step
SIMULATION_BUTTON_TOOLTIP_UNDO=Undo one step
SIMULATION_BUTTON_TOOLTIP_RESET=Reset

BAR_REGISTERS_NAME=Registers
BAR_MEMORY_NAME=Memory
BAR_FLOW_NAME=Flow
BAR_CONSOLE_NAME=Console
BAR_LABELS_NAME=Labels
BAR_CACHES_NAME=Caches

INSTRUCTIONS_USER=Text
INSTRUCTIONS_KERNEL=Kernel

INSTRUCTIONS_BREAKPOINT=Brk.
INSTRUCTIONS_ADDRESS=Address
INSTRUCTIONS_CODE=Code
INSTRUCTIONS_INSTRUCTION=Instruction
INSTRUCTIONS_ORIGINAL=Original

REGISTERS_GENERAL=General
REGISTERS_COP0=COP0
REGISTERS_COP1=COP1
REGISTERS_ID=Id
REGISTERS_SELECTION=Sel
REGISTERS_NAME=Name
REGISTERS_VALUE=Value
REGISTERS_HEX=Hex

MEMORY_ADDRESS=Address

LABELS_NAME=Name
LABELS_ADDRESS=Address
LABELS_CONTEXT_SHOW_IN_MEMORY=Show in memory
LABELS_CONTEXT_SHOW_IN_INSTRUCTION=Show in instruction table

CACHE_HITS=Hits
CACHE_MISSES=Misses
CACHE_STATS=Stats
CACHE_STATS_OPERATIONS=Operations:
CACHE_STATS_HITS=Hits:
CACHE_STATS_MISSES=Misses:
CACHE_RESET=Reset caches
CACHE_LOG=Log
CACHE_LOG_HIT=Operation {OPERATION}. Hit.
CACHE_LOG_MISS=Operation {OPERATION}. Miss.
CACHE_LOG_INDEX=Index {INDEX} ({TAG})
CACHE_LOG_CLEAR=Clear log
CACHE_LOG_CLEAR_ALL=Clear all logs

FLOW_CYCLE=Cycle: {CYCLE}

CONFIG=Configuration

CONFIG_ACTION=Actions
CONFIG_ACTION_SEARCH=Search...
CONFIG_ACTION_BIND_TITLE=Bind combination to action
CONFIG_ACTION_BIND_ENTER=Press the combination of keys to bind
CONFIG_ACTION_BIND_CONFIRM=The following actions will be unbind from the given combination:
CONFIG_ACTION_BIND_CONFIRM_2=Do you want to continue?
CONFIG_ACTION_UNBIND=Are you sure you want to unbind this combination?

CONFIG_APPEARANCE=Appearance
CONFIG_APPEARANCE_REGION_THEME=Theme
CONFIG_APPEARANCE_REGION_TWEAKS=Tweaks
CONFIG_APPEARANCE_THEME=Theme:
CONFIG_APPEARANCE_THEME_TOOLTIP=Themes changes the whole appearance of the application.
CONFIG_APPEARANCE_GENERAL_FONT=General font:
CONFIG_APPEARANCE_GENERAL_FONT_TOOLTIP=This font is used on all JAMS except text editors.
CONFIG_APPEARANCE_CODE_FONT=Editor font:
CONFIG_APPEARANCE_CODE_FONT_TOOLTIP=This font is used on text editors.
CONFIG_APPEARANCE_HIDE_TOP_BAR=Hide top bar\t(Windows only, requires restart)
CONFIG_APPEARANCE_HIDE_TOP_BAR_TOOLTIP=This option integrates the main window's bar into the taskbar.
CONFIG_APPEARANCE_ANTIALIASING=Antialiasing\t(Requires restart)
CONFIG_APPEARANCE_ANTIALIASING_TOOLTIP=Enables the antialiasing in all scenes.

CONFIG_EDITOR=Editor
CONFIG_EDITOR_REGION_MOUSE_CONTROL=Mouse control
CONFIG_EDITOR_ZOOM_USING_MOUSE_WHEEL=Zoom with Shortcut+Mouse Wheel
CONFIG_EDITOR_ZOOM_USING_MOUSE_WHEEL_TOOLTIP=If this option is enable you can zoom using the mouse wheel while pressing the Shortcut key.
CONFIG_EDITOR_RESET_ZOOM_USING_MIDDLE_BUTTON=Reset zoom with Shortcut+Mouse Middle Button
CONFIG_EDITOR_RESET_ZOOM_USING_MIDDLE_BUTTON_TOOLTIP=If this option is enable you can reset the zoom using the mouse middle button while pressing the Shortcut key.

CONFIG_EDITOR_MIPS=MIPS
CONFIG_EDITOR_MIPS_REGION_TABS=Tabs
CONFIG_EDITOR_MIPS_REGION_SPACES=Spaces
CONFIG_EDITOR_MIPS_REGION_BLANK_LINES=Blank lines
CONFIG_EDITOR_MIPS_USE_TABS=Use tabs character
CONFIG_EDITOR_MIPS_USE_TABS_TOOLTIP=If this option is enabled JAMS will use TABs instead of spaces on the code editor.
CONFIG_EDITOR_MIPS_PRESERVE_TABS=Preserve tabs after the label
CONFIG_EDITOR_MIPS_PRESERVE_TABS_TOOLTIP=This option sets whether tabs added by the user between the label and the instruction / directive should be preserved when formatting.
CONFIG_EDITOR_MIPS_PRESERVE_TABS_BEFORE_LABELS=Preserve tabs before the label
CONFIG_EDITOR_MIPS_PRESERVE_TABS_BEFORE_LABELS_TOOLTIP=This option sets whether tabs added before labels should be preserved when formatting.
CONFIG_EDITOR_MIPS_SPACE_AFTER_INSTRUCTION=After instruction:
CONFIG_EDITOR_MIPS_SPACE_AFTER_INSTRUCTION_TOOLTIP=This option tells JAMS what to add after an instruction.
CONFIG_EDITOR_MIPS_SPACE_AFTER_INSTRUCTION_PARAMETER=After instruction parameter:
CONFIG_EDITOR_MIPS_SPACE_AFTER_INSTRUCTION_PARAMETER_TOOLTIP=This option tells JAMS what to add after an instruction's parameter.
CONFIG_EDITOR_MIPS_SPACE_AFTER_DIRECTIVE=After directive:
CONFIG_EDITOR_MIPS_SPACE_AFTER_DIRECTIVE_TOOLTIP=This option tells JAMS what to add after a directive.
CONFIG_EDITOR_MIPS_SPACE_AFTER_DIRECTIVE_PARAMETER=After directive parameter:
CONFIG_EDITOR_MIPS_SPACE_AFTER_DIRECTIVE_PARAMETER_TOOLTIP=This option tells JAMS what to add after a directive's parameter.
CONFIG_EDITOR_MIPS_MAXIMUM_BLANK_LINES=Maximum blank lines:
CONFIG_EDITOR_MIPS_MAXIMUM_BLANK_LINES_TOOLTIP=The maximum amount of blank lines JAMS will keep on formatting.

CONFIG_EXPLORER=Explorer
CONFIG_EXPLORER_REGION_SIZE=Size
CONFIG_EXPLORER_SECTION_SEPARATOR_WIDTH=Width per hierarchy level for sections
CONFIG_EXPLORER_SECTION_SEPARATOR_WIDTH_TOOLTIP=Represents the width that a section will shift per hierarchy level
CONFIG_EXPLORER_ELEMENT_SEPARATOR_WIDTH=Width per hierarchy level for elements
CONFIG_EXPLORER_ELEMENT_SEPARATOR_WIDTH_TOOLTIP=Represents the width that an element will shift per hierarchy level
CONFIG_EXPLORER_MIPS=MIPS
CONFIG_EXPLORER_MIPS_REGION_CREATION=Creation
CONFIG_EXPLORER_MIPS_ADD_CREATED_ASM_FILES_TO_ASSEMBLE=Add created asm files to assemble automatically
CONFIG_EXPLORER_MIPS_ADD_CREATED_ASM_FILES_TO_ASSEMBLE_TOOLTIP=Assembly files will be added automatically into the assembly list if this option is enabled.\n\nThis option can be changed when you create an assembly file.

CONFIG_LANGUAGE=Language
CONFIG_LANGUAGE_REGION_LANGUAGE=Language
CONFIG_LANGUAGE_DEFAULT=Fallback language:
CONFIG_LANGUAGE_DEFAULT_TOOLTIP=This language will be used when the selected language doesn't have the required message.\n\nThis language is the English language by default.
CONFIG_LANGUAGE_SELECTED=Selected language:
CONFIG_LANGUAGE_SELECTED_TOOLTIP=This language will be used by JAMS to show all its messages.

CONFIG_SIMULATION=Simulation
CONFIG_SIMULATION_MIPS=MIPS
CONFIG_SIMULATION_REGION_ASSEMBLY=Assembly
CONFIG_SIMULATION_OPEN_LOG_ON_ASSEMBLE=Open log pane when assembling.
CONFIG_SIMULATION_REGION_MEMORY=Memory
CONFIG_SIMULATION_MEMORY_ROWS=Rows:
CONFIG_SIMULATION_MEMORY_ROWS_TOOLTIP=The amount of rows the memory display can show at the same time.
CONFIG_SIMULATION_MIPS_REGION_FLOW=Flow
CONFIG_SIMULATION_MIPS_FLOW_MAX_ITEMS=Maximum entries:
CONFIG_SIMULATION_MIPS_FLOW_MAX_ITEMS_TOOLTIP=The maximum amount of entries the flow pane can hold at the same time.

EDITOR_MIPS_ERROR_ILLEGAL_LABEL=The label '{TEXT}' has an invalid name.
EDITOR_MIPS_ERROR_LABEL_NOT_FOUND=Couldn't found label '{TEXT}'.
EDITOR_MIPS_ERROR_DUPLICATE_LABEL=Found duplicated label '{TEXT}'.
EDITOR_MIPS_ERROR_DUPLICATE_GLOBAL_LABEL=Found duplicated global label '{TEXT}' on file '{FILE}'.
EDITOR_MIPS_ERROR_DIRECTIVE_NOT_FOUND=Couldn't found directive '{TEXT}'.
EDITOR_MIPS_ERROR_INVALID_DIRECTIVE_PARAMETER=The parameter '{TEXT}' is invalid.
EDITOR_MIPS_ERROR_INSTRUCTION_NOT_FOUND=Couldn't found instruction '{TEXT}' with the given parameters.
EDITOR_MIPS_ERROR_INVALID_INSTRUCTION_PARAMETER=The parameter '{TEXT}' is invalid.

ACTION_REGION_GENERAL=General
ACTION_GENERAL_CREATE_PROJECT=Create project
ACTION_GENERAL_OPEN_PROJECT=Open project
ACTION_GENERAL_SETTINGS=Settings
ACTION_GENERAL_ASSEMBLE=Assemble code

ACTION_REGION_TEXT_EDITOR=Text editor
ACTION_TEXT_EDITOR_REFORMAT=Reformat code
ACTION_TEXT_EDITOR_SAVE=Save file
ACTION_TEXT_EDITOR_SHOW_AUTOCOMPLETION_POPUP=Show autocompletion popup
ACTION_TEXT_EDITOR_SHOW_DOCUMENTATION_POPUP=Show documentation popup
ACTION_TEXT_EDITOR_PREVIOUS_FILE=Move to the previous file
ACTION_TEXT_EDITOR_NEXT_FILE=Move to the next file
ACTION_TEXT_EDITOR_REFRESH_FROM_DISK=Refresh from disk
ACTION_TEXT_EDITOR_COPY=Copy
ACTION_TEXT_EDITOR_PASTE=Paste
ACTION_TEXT_EDITOR_CUT=Cut
ACTION_TEXT_EDITOR_UNDO=Undo
ACTION_TEXT_EDITOR_REDO=Redo
ACTION_TEXT_EDITOR_SELECT_ALL=Select all
ACTION_TEXT_EDITOR_DUPLICATE_LINE=Duplicate line

ACTION_REGION_EXPLORER_ELEMENT=Explorer elements
ACTION_EXPLORER_ELEMENT_CONTRACT_OR_SELECT_PARENT=Contract folder / Select parent
ACTION_EXPLORER_ELEMENT_EXPAND_OR_NEXT=Expand folder / Select next
ACTION_EXPLORER_ELEMENT_SELECT_NEXT=Select next
ACTION_EXPLORER_ELEMENT_SELECT_NEXT_MULTIPLE=Select next (multi-selection)
ACTION_EXPLORER_ELEMENT_SELECT_PREVIOUS=Select previous
ACTION_EXPLORER_ELEMENT_SELECT_PREVIOUS_MULTIPLE=Select previous (multi-selection)
ACTION_EXPLORER_ELEMENT_SELECT_ALL=Select all

ACTION_REGION_FOLDER_EXPLORER_ELEMENT=Folder explorer elements
ACTION_FOLDER_EXPLORER_ELEMENT_COPY=Copy
ACTION_FOLDER_EXPLORER_ELEMENT_DELETE=Delete
ACTION_FOLDER_EXPLORER_ELEMENT_PASTE=Paste
ACTION_FOLDER_EXPLORER_ELEMENT_SHOW_IN_FILES=Show in files
ACTION_FOLDER_EXPLORER_ELEMENT_NEW=New
ACTION_FOLDER_EXPLORER_ELEMENT_NEW_FILE=File
ACTION_FOLDER_EXPLORER_ELEMENT_NEW_ASSEMBLY_FILE=Assembly file
ACTION_FOLDER_EXPLORER_ELEMENT_NEW_FOLDER=Folder
ACTION_FOLDER_EXPLORER_ELEMENT_ADD_FILE_TO_ASSEMBLER=Add file to the assembler
ACTION_FOLDER_EXPLORER_ELEMENT_REMOVE_FILE_FROM_ASSEMBLER=Remove file from the assembler

ACTION_REGION_EDITOR_TAB=Editor tab
ACTION_EDITOR_TAB_SPLIT_HORIZONTALLY=Split horizontally
ACTION_EDITOR_TAB_SPLIT_VERTICALLY=Split vertically

ACTION_REGION_MIPS_FILE_TO_ASSEMBLE=Files to assemble
ACTION_MIPS_FILES_TO_ASSEMBLE_REMOVE=Remover from assembler

ACTION_REGION_MIPS_SIMULATION=MIPS Simulation
ACTION_MIPS_SIMULATION_EXECUTE_ALL_INSTRUCTIONS=Execute all instructions
ACTION_MIPS_SIMULATION_EXECUTE_ONE_STEP=Execute one step
ACTION_MIPS_SIMULATION_RESET=Reset
ACTION_MIPS_SIMULATION_STOP=Stop
ACTION_MIPS_SIMULATION_UNDO_ONE_STEP=Undo one step

NUMBER_FORMAT_HEXADECIMAL=Hexadecimal
NUMBER_FORMAT_DECIMAL=Decimal
NUMBER_FORMAT_OCTAL=Octal
NUMBER_FORMAT_BINARY=Binary
NUMBER_FORMAT_LONG=Long
NUMBER_FORMAT_FLOAT=Float
NUMBER_FORMAT_DOUBLE=Double
NUMBER_FORMAT_CHAR=Characters
NUMBER_FORMAT_RGB=RGB
NUMBER_FORMAT_RGBA=RGBA
NUMBER_FORMAT_ENGLISH=English text
NUMBER_FORMAT_ROMAN=Roman

//INSTRUCTIONS

INSTRUCTION_ABS_D=Absolute (double)
INSTRUCTION_ABS_S=Absolute (single)
INSTRUCTION_ADD=Addition
INSTRUCTION_ADD_D=Addition (double)
INSTRUCTION_ADDIU=Immediate addition without overflow
INSTRUCTION_ADDIUPC=Immediate addition to PC without overflow
INSTRUCTION_ADD_S=Addition (single)
INSTRUCTION_ADDU=Addition without overflow
INSTRUCTION_ALIGN=Concatenate two GRPs extracting a contiguous subset at a byte position
INSTRUCTION_ALUIPC=Aligned add upper immediate on PC
INSTRUCTION_AND=And
INSTRUCTION_ANDI=Immediate and
INSTRUCTION_AUI=Immediate addition to upper bits
INSTRUCTION_AUIPC=Immediate addition to PC upper bits
INSTRUCTION_BAL=Branch and link
INSTRUCTION_BALC=Branch and link compact
INSTRUCTION_BC=Branch compact
INSTRUCTION_BC1EQZ=Branch if COP1 register bit 0 is zero
INSTRUCTION_BC1NEZ=Branch if COP1 register bit 0 is not zero
INSTRUCTION_BEQ=Branch on equal
INSTRUCTION_BEQC=Branch on equal compact
INSTRUCTION_BEQZALC=Branch and link on equal to zero compact
INSTRUCTION_BEQZC=Branch on equal to zero compact
INSTRUCTION_BGEC=Branch on greater than or equal compact
INSTRUCTION_BGEUC=Branch on greater than or equal unsigned compact
INSTRUCTION_BGEZ=Branch on greater than or equal to zero
INSTRUCTION_BGEZALC=Branch and link on greater than or equal to zero compact
INSTRUCTION_BGEZC=Branch on greater than or equal to zero compact
INSTRUCTION_BGTZ=Branch on greater than zero
INSTRUCTION_BGTZALC=Branch and link on greater than zero compact
INSTRUCTION_BGTZC=Branch on greater than zero compact
INSTRUCTION_BITSWAP=Swap bits in each byte
INSTRUCTION_BLEZ=Branch on less than or equal to zero
INSTRUCTION_BLEZALC=Branch and link on less than or equal to zero compact
INSTRUCTION_BLEZC=Branch on less than or equal to zero compact
INSTRUCTION_BLTC=Branch on less than compact
INSTRUCTION_BLTUC=Branch on less than unsigned compact
INSTRUCTION_BLTZ=Branch on less than zero
INSTRUCTION_BLTZALC=Branch and link on less than zero compact
INSTRUCTION_BLTZC=Branch on less than zero compact
INSTRUCTION_BNE=Branch on not equal
INSTRUCTION_BNEC=Branch on not equal compact
INSTRUCTION_BNEZALC=Branch and link on not equal to zero compact
INSTRUCTION_BNEZC=Branch on not equal to zero compact
INSTRUCTION_BNVC=Branch on no overflow compact
INSTRUCTION_BOVC=Branch on overflow compact
INSTRUCTION_BREAK=Breakpoint
INSTRUCTION_CEIL_L_D=Ceiling double to long
INSTRUCTION_CEIL_L_S=Ceiling single to long
INSTRUCTION_CEIL_W_D=Ceiling double to word
INSTRUCTION_CEIL_W_S=Ceiling single to word
INSTRUCTION_CLO=Count leading ones in word
INSTRUCTION_CLZ=Count leading zeros in word
INSTRUCTION_CMP_D=Floating point compare ({TYPE}) (double)
INSTRUCTION_CMP_S=Floating point compare ({TYPE}) (single)
INSTRUCTION_CVT=Convert from {FROM} to {TO}
INSTRUCTION_DIV=Division
INSTRUCTION_DIV_D=Division (double)
INSTRUCTION_DIV_S=Division (single)
INSTRUCTION_DIVU=Unsigned division
INSTRUCTION_ERET=Exception return
INSTRUCTION_J=Jump
INSTRUCTION_JAL=Jump and link
INSTRUCTION_JALR=Jump and link register
INSTRUCTION_LB=Load byte
INSTRUCTION_LW=Load word
INSTRUCTION_MFC0=Move from coprocessor 0
INSTRUCTION_MFC1=Move from coprocessor 1
INSTRUCTION_MOD=Module
INSTRUCTION_MODU=Unsigned module
INSTRUCTION_MFC0=Move to coprocessor 0
INSTRUCTION_MFC1=Move to coprocessor 1
INSTRUCTION_MUH=Multiplication and return high word
INSTRUCTION_MUHU=Unsigned multiplication and return high word
INSTRUCTION_MUL=Multiplication and return low word
INSTRUCTION_MUL_D=Multiplication (double)
INSTRUCTION_MUL_S=Multiplication (single)
INSTRUCTION_MULU=Unsigned multiplication and return low word
INSTRUCTION_OR=Or
INSTRUCTION_ORI=Immediate or
INSTRUCTION_SB=Save byte
INSTRUCTION_SLL=Shift word left logical
INSTRUCTION_SLLV=Shift word left logical variable
INSTRUCTION_SLT=Set on less than
INSTRUCTION_SLTI=Set on less than immediate
INSTRUCTION_SLTIU=Set on less than immediate unsigned
INSTRUCTION_SLTU=Set on less than unsigned
INSTRUCTION_SRL=Shift word right logical
INSTRUCTION_SRLV=Shift word right logical variable
INSTRUCTION_SUB=Subtraction
INSTRUCTION_SUB_D=Subtraction (double)
INSTRUCTION_SUB_S=Subtraction (single)
INSTRUCTION_SUBU=Subtraction without overflow
INSTRUCTION_SW=Save word
INSTRUCTION_SYSCALL=System call

//PSEUDO INSTRUCTIONS

INSTRUCTION_B=Unconditional branch
INSTRUCTION_JR=Jump register
INSTRUCTION_LA=Load address
INSTRUCTION_LI=Load immediate
INSTRUCTION_LUI=Load upper immediate
INSTRUCTION_LIF=Load immediate float
INSTRUCTION_MOVE=Value movement
INSTRUCTION_NOP=No operation
INSTRUCTION_SGE=Set on greater than or equal
INSTRUCTION_SGEI=Set on greater than or equal immediate
INSTRUCTION_SGEIU=Set on greater than or equal immediate unsigned
INSTRUCTION_SGEU=Set on greater than or equal unsigned
INSTRUCTION_SGT=Set on greater than
INSTRUCTION_SGTI=Set on greater than immediate
INSTRUCTION_SGTIU=Set on greater than immediate unsigned
INSTRUCTION_SGTU=Set on greater than unsigned
INSTRUCTION_SLE=Set on lower than or equal
INSTRUCTION_SLEI=Set on lower than or equal immediate
INSTRUCTION_SLEIU=Set on lower than or equal immediate unsigned
INSTRUCTION_SLEU=Set on lower than or equal unsigned

//INSTRUCTIONS DOCUMENTATION

INSTRUCTION_ABS_D_DOCUMENTATION.=<u>Double precision floating point absolute value</u>

<b>Format:</b>
abs.d fd, fs

| COP1      fmt      0      fs      fd      ABS   |
|010001    10001   00000                   000101 |
|  6         5       5      5       5        6    |


<b>Description:</b>
FPR[fd] <- abs(FPR[fs])

Places the absolute value of <i>fs</i> in <i>fd</i>. The operand and result are values in double precision floating point.

<b>Restrictions:</b>
The fields <i>fs</i> and <i>fd</i> must be even FPRs. If the fields are not valid, the result is <black>UNPREDICTABLE</black>.
The operand must be a value in double precision floating point. If it is not, the result is <black>UNPREDICTABLE</black>.

<b>Operation:</b>
fmt <- double
StoreFPR(fd, fmt, AbsoluteValue(ValueFPR(fs, fmt)))

<b>Exceptions:</b>
None
\END

INSTRUCTION_ABS_S_DOCUMENTATION.=<u>Floating point absolute value</u>

<b>Format:</b>
abs.s fd, fs

| COP1      fmt      0      fs      fd      ABS   |
|010001    10000   00000                   000101 |
|  6         5       5      5       5        6    |


<b>Description:</b>
FPR[fd] <- abs(FPR[fs])

Places the absolute value of <i>fs</i> in <i>fd</i>. The operand and result are values in floating point.

<b>Restrictions:</b>
The operand must be a value in floating point. If it is not, the result is <black>UNPREDICTABLE</black>.

<b>Operation:</b>
fmt <- float
StoreFPR(fd, fmt, AbsoluteValue(ValueFPR(fs, fmt)))

<b>Exceptions:</b>
None
\END

INSTRUCTION_ADD_DOCUMENTATION.=<u>Addition</u>

<b>Format:</b>
add rd, rs, rt

|SPECIAL     rs      rt     rd      0       ADD   |
|000000                                    100000 |
|  6         5       5      5       5        6    |


<b>Description:</b>
GPR[rd] <- GPR[rs] + GPR[rt]

The 32-bit word value in GPR <i>rt</i> is added to the 32-bit value in GPR <i>rs</i> to produce a 32-bit result.
 - If the adition results in 32-bit 2's complement arithmetic overflow, the destination register is not modified and an <black>Integer Overflow</black> exception occurs.
 - If the addition does not overflow, the 32-bit result is placed intoto GPR <i>rd</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>
temp <- (GPR[rs]<sub>31</sub> || GPR[rs]<sub>31..0</sub>) + (GPR[rt]<sub>31</sub> || GPR[rt]<sub>31..0</sub>)
if temp<sub>32</sub> != temp<sub>31</sub> then
    SignalException(IntegerOverflow)
else
    GPR[rd] <- temp
endif

<b>Exceptions:</b>
Integer Overflow

<b>Programming Notes:</b>
<black>addu</black> performs the same arithmetic operation but does not trap on overflow.
\END

INSTRUCTION_ADD_D_DOCUMENTATION.=<u>Double precision floating point addition</u>

<b>Format:</b>
add.d fd, fs, ft

| COP1      fmt      0      fs      fd      ABS   |
|010001    10001   00000                   000000 |
|  6         5       5      5       5        6    |


<b>Description:</b>
FPR[fd] <- FPR[fs] + FPR[ft]

The value in FPR <i>ft</i> is added to the value in FPR <i>fs</i>. The result is calculated to infinite precision, rounded using the <i>Java</i> rounding mode, and placed into FPR <i>fd</i>.
The operands and result are values in double precision floating point.

<b>Restrictions:</b>
The fields <i>fs</i>, <i>ft</i> and <i>fd</i> must be even FPRs. If the fields are not valid, the result is <black>UNPREDICTABLE</black>.
The operand must be a value in double precision floating point. If it is not, the result is <black>UNPREDICTABLE</black>.

<b>Operation:</b>
fmt <- double
StoreFPR(fd, fmt, ValueFPR(fs, fmt) +<sub>fmt</sub> ValueFPR(ft, fmt))

<b>Exceptions:</b>
None
\END

INSTRUCTION_ADD_S_DOCUMENTATION.=<u>Floating point addition</u>

<b>Format:</b>
add.s fd, fs, ft

| COP1      fmt      0      fs      fd      ABS   |
|010001    10000   00000                   000000 |
|  6         5       5      5       5        6    |


<b>Description:</b>
FPR[fd] <- FPR[fs] + FPR[ft]

The value in FPR <i>ft</i> is added to the value in FPR <i>fs</i>. The result is calculated to infinite precision, rounded using the <i>Java</i> rounding mode, and placed into FPR <i>fd</i>.
The operands and result are values in floating point.

<b>Restrictions:</b>
The operand must be a value in floating point. If it is not, the result is <black>UNPREDICTABLE</black>.

<b>Operation:</b>
fmt <- float
StoreFPR(fd, fmt, ValueFPR(fs, fmt) +<sub>fmt</sub> ValueFPR(ft, fmt))

<b>Exceptions:</b>
None
\END

INSTRUCTION_ADDIU_DOCUMENTATION.=<u>Immediate unsigned addition</u>

<b>Format:</b>
addiu rt, rs, immediate

| ADDIU      rs     rt     immediate |
|001001                              |
|  6         5      5         16     |


<b>Description:</b>
GPR[rt] <- GPR[rs] + immediate

The 16-bit signed <i>immediate</i> is added to the 32-bit value in GRP <i>rs</i> and the 32-bit arithmetic result is placed into GPR <i>rt</i>.
No <black>Integer Overflow</black> exception occurs under any circumstances.

<b>Restrictions:</b>
None

<b>Operation:</b>
temp <- GPR[rs] + sign_extend(immediate)
GPR[rt] <- temp

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
The term <i>unsigned</i> in the instruction name is a misnomer; this operation is a 32-bit modulo arithmetic that does not trap on overflow. This instruction is appropiate for unsigned arithmetic, such as address arithmetic, or integer arithmetic environments that ignore overflow, such as the C language arithmetic.
\END

INSTRUCTION_ADDIUPC_DOCUMENTATION.=<u>Immediate unsigned addition to PC</u>

<b>Format:</b>
addiupc rs, immediate

| PCREL      rs   ADDIUPC   immediate |
|111011              00               |
|  6         5       2         19     |


<b>Description:</b>
GPR[rs] <- PC + sign_extend(immediate << 2)

This instruction performs a PC-relative address calculation. The 19-bit <i>immediate</i> is shifted left by 2 bits, sign-extended and added to the address of the instruction.
The result is placed into GPR <i>rs</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>
GPR[rs] <- PC + sign_extend(immediate << 2)

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
The term <i>unsigned</i> in the instruction name is a misnomer. <i>Unsigned</i> here means <i>non-trapping</i>. It does not trap on a signed 32-bit overflow. <black>addiupc</black> corresponds to unsigned <black>addiu</black>, which does not trap on overflow.
\END

INSTRUCTION_ADDU_DOCUMENTATION.=<u>Unsigned addition</u>

<b>Format:</b>
addu rd, rs, rt

|SPECIAL     rs      rt     rd      0       ADD   |
|000000                                    100001 |
|  6         5       5      5       5        6    |


<b>Description:</b>
GPR[rd] <- GPR[rs] + GPR[rt]

The 32-bit word value in GPR <i>rt</i> is added to the 32-bit value in GPR <i>rs</i> to produce a 32-bit result.
The 32-bit result is placed into GPR <i>rd</i>.
No <black>Integer Overflow</black> exception occurs under any circumstances.

<b>Restrictions:</b>
None

<b>Operation:</b>
temp <- GPR[rs] + GPR[rt]
GPR[rd] <- temp

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
The term <i>unsigned</i> in the instruction name is a misnomer; this operation is a 32-bit modulo arithmetic that does not trap on overflow. This instruction is appropiate for unsigned arithmetic, such as address arithmetic, or integer arithmetic environments that ignore overflow, such as the C language arithmetic.
\END

INSTRUCTION_ALIGN_DOCUMENTATION.=<u>Concatenate two GRPs extracting a contiguous subset at a byte position</u>

<b>Format:</b>
align rd, rs, rt, bp

|SPECIAL3    rs    rt    rd    ALIGN   bp   BSGFL  |
| 011111                        010         100000 |
|   6        5     5     5       3     2      6    |


<b>Description:</b>
GPR[rd] <- (GPR[rt] << 8 * bp) or (GPR[rs] >> 8 * (4 - bp))

The input registers GPR <i>rt</i> and GPR <i>rs</i> are concatenated, and a register width contiguous subset is extracted, which is specified by the byte pointer <i>bp</i>.
The <black>align</black> instruction operates on 32-bit words, and has a 2-bit byte position field <i>bp</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>
tmp_rt_hi <- unsigned_word(GPR[rt]) << 8 * bp
tmp_rs_lo <- unsigned_word(GPR[rs]) >> 8 * (4 - bp)
GPR[rd] <- tmp_rt_hi or tmp_rs_lo

<b>Exceptions:</b>
None
\END

INSTRUCTION_ALUIPC_DOCUMENTATION.=<u>Aligned add upper immediate on PC</u>

<b>Format:</b>
aluipc rs, immediate

| PCREL     rs     ALUIPC   immediate |
|111011            11111              |
|  6        5        5         16     |


<b>Description:</b>
GPR[rs] <- not 0x0FFFF and PC + sign_extend(immediate << 16)

This instruction performs a PC-relative address calculation. The 16-bit <i>immediate</i> is shifted left by 16 bits, sign-extended and added to the address of the instruction.
The low 16 bits of the result are cleard. The result is placed into GPR <i>rs</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>
GPR[rs] <- not 0x0FFFF and PC + sign_extend(immediate << 16)

<b>Exceptions:</b>
None
\END

INSTRUCTION_AND_DOCUMENTATION.=<u>And</u>

<b>Format:</b>
and rd, rs, rt

|SPECIAL     rs      rt     rd      0       AND   |
|000000                                    100100 |
|  6         5       5      5       5        6    |


<b>Description:</b>
GPR[rd] <- GPR[rs] and GPR[rt]

Performs a bitwise logical AND using the values inside GPR <i>rs</i> and GPR <i>rt</i>.
The result is placed into GPR <i>rd</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>
GPR[rd] <- GPR[rs] and GPR[rt]

<b>Exceptions:</b>
None
\END

INSTRUCTION_ANDI_DOCUMENTATION.=<u>Immediate and</u>

<b>Format:</b>
andi rt, rs, immediate

| ANDI      rs     rt     immediate |
|001100                             |
|  6        5      5         16     |


<b>Description:</b>
GPR[rt] <- GPR[rs] and zero_extend(immediate)

The 16-bit <i>immediate</i> is zero-extended to the left and combined with the value of GPR <i>rs</i> in a bitwise logical AND operation.
The result is placed into GPR <i>rt</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>
GPR[rt] <- GPR[rs] and zero_extend(immediate)

<b>Exceptions:</b>
None
\END

INSTRUCTION_AUI_DOCUMENTATION.=<u>Add immediate to upper bits</u>

<b>Format:</b>
aui rt, rs, immediate

| AUI       rs     rt     immediate |
|001111                             |
|  6        5      5         16     |


<b>Description:</b>
GPR[rt] <- GPR[rs] + sign_extend(immediate << 16)

The 16-bit <i>immediate</i> is shifted left 16 bits, sign-extended and added to the GPR <i>rs</i>.
The result is placed into GPR <i>rt</i>.
In MIPS32r6, <black>lui</black> is an assembly idiom for <black>aui</black> with <i>rs</i> = 0.

<b>Restrictions:</b>
None

<b>Operation:</b>
GPR[rt] <- GPR[rs] + sign_extend(immediate << 16)

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
<black>aui</black> can be used to synthesize large constants in situations where it is not convenient to load a large constant from memory.
\END

INSTRUCTION_AUIPC_DOCUMENTATION.=<u>Add immediate to PC upper bits</u>

<b>Format:</b>
auipc rs, immediate

| PCREL    rs    AUIPC    immediate |
|111011          11110              |
|  6       5       5         16     |


<b>Description:</b>
GPR[rs] <- PC + (immediate << 16)

This instruction performs a PC-relative address calculation. The 16-bit <i>immediate</i> is shifted left by 16 bits and added to the address of the instruction.
The result is placed into GPR <i>rs</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>
GPR[rs] <- PC + (immediate << 16)

<b>Exceptions:</b>
None
\END

INSTRUCTION_BAL_DOCUMENTATION.=<u>Branch and link</u>

<b>Format:</b>
b offset

|REGIMM      0      BAL      offset  |
|000001    00000   10001             |
|  6         5       5        16     |


<b>Description:</b>
Places the return address link in GPR <i>31</i>. The return link is the address of the instruction where the execution continues after a procedure call.
An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
<black>I:</black>
target_offset <- sign_extend(offset || 00)
GPR[31] <- PC + 4

<black>I+1:</black>
PC <- PC + target_offset

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
<black>bal</black> without a corresponding return should NOT be used to read the PC. Doing so is likely to cause a performance loss on processors with a return address predictor.
\END

INSTRUCTION_BALC_DOCUMENTATION.=<u>Branch and link compact</u>

<b>Format:</b>
balc offset

| BALC      offset  |
|111010             |
|  6         26     |


<b>Description:</b>
Places the return address link in GPR <i>31</i>. The return link is the address of the instruction where the execution continues after a procedure call.
An 28-bit signed offset (the 26-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
This instruction performs a compact branch. Compact branches don't have delay slots.

<b>Restrictions:</b>
This instruction is an unconditional, always taken, compact branch. It does not have a forbidden slot nor a delay slot.

<b>Operation:</b>
target_offset <- sign_extend(offset || 00)
GPR[31] <- PC + 4
PC <- PC + 4 + target_offset

<b>Exceptions:</b>
None
\END

INSTRUCTION_BC_DOCUMENTATION.=<u>Branch compact</u>

<b>Format:</b>
bc offset

|  BC       offset  |
|110010             |
|  6         26     |


<b>Description:</b>
A 28-bit signed offset (the 26-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
This instruction performs a compact branch. Compact branches don't have delay slots.

<b>Restrictions:</b>
This instruction is an unconditional, always taken, compact branch. It does not have a forbidden slot nor a delay slot.

<b>Operation:</b>
target_offset <- sign_extend(offset || 00)
PC <- PC + 4 + target_offset

<b>Exceptions:</b>
None
\END

INSTRUCTION_BC1EQZ_DOCUMENTATION.=<u>Branch if COP1 register bit 0 is zero</u>

<b>Format:</b>
bc1eqz ft, offset

| COP1      BC1EQZ     ft     offset  |
|010001     01001                     |
|  6          5        5        16    |


<b>Description:</b>
if FPR[ft] & 1 = 0 then branch

The condition is true if and ofly if bit 0 of the FPR <i>ft</i> is zero.
If the condition is false, the branch is not taken and execution continues with the next instruction.
An 18-bit signed offset (the 26-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
temp = ValueFPR(ft, UNINTERPRETED_WORD)
cond = temp & 1 = 0
if cond then
    <black>I:</black>
    target_PC <- PC + 4 + sign_extend(offset << 2)
    <black>I+1:</black>
    PC <- target_PC
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_BC1NEZ_DOCUMENTATION.=<u>Branch if COP1 register bit 0 is not zero</u>

<b>Format:</b>
bc1nez ft, offset

| COP1      BC1NEZ     ft     offset  |
|010001     01101                     |
|  6          5        5        16    |


<b>Description:</b>
if FPR[ft] & 1 != 0 then branch

The condition is true if and ofly if bit 0 of the FPR <i>ft</i> is not zero.
If the condition is false, the branch is not taken and execution continues with the next instruction.
An 18-bit signed offset (the 26-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
temp = ValueFPR(ft, UNINTERPRETED_WORD)
cond = temp & 1 != 0
if cond then
    <black>I:</black>
    target_PC <- PC + 4 + sign_extend(offset << 2)
    <black>I+1:</black>
    PC <- target_PC
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_BEQ_DOCUMENTATION.=<u>Branch on equal</u>

<b>Format:</b>
beq rs, rt, offset

| BEQ       rs     rt     offset  |
|000100                           |
|  6        5      5       16     |


<b>Description:</b>
if GPR[rs] = GPR[rt] then branch

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rt</i> and GPR <i>rs</i> are equal, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
<black>I:</black>
target_offset <- sign_extend(offset || 00)
condition <- GPR[rs] = GPR[rt]
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
With the 18-bit signed instruction offset, the conditional branch range is ±128KBytes. Use jump (<black>j</black>) or jump register (<black>jr</black>) to branch to addresses outside this range.
<black>beq $zero, $zero, offset</black>, expressed as <black>b offset</black>, is the assembly idiom used to denote an unconditional branch.
\END

INSTRUCTION_BGEZ_DOCUMENTATION.=<u>Branch on greater than or equal to zero</u>

<b>Format:</b>
bgez rs, offset

|REGIMM     rs    BGEZ    offset  |
|000001          00001            |
|  6        5      5        16    |


<b>Description:</b>
if GPR[rs] >= 0 then branch

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rs</i> are greater than or equal to zero, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
<black>I:</black>
target_offset <- sign_extend(offset || 00)
condition <- GPR[rs] >= 0
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
With the 18-bit signed instruction offset, the conditional branch range is ±128KBytes. Use jump (<black>j</black>) or jump register (<black>jr</black>) to branch to addresses outside this range.
\END

INSTRUCTION_BLEZALC_DOCUMENTATION.=<u>Branch and link on less than or equal to zero compact</u>

<b>Format:</b>
blezalc rt, offset

| POP06     0    rt != 0   offset  |
|000110   00000                    |
|  6        5       5        16    |


<b>Description:</b>
Compact branch and link if GPR[rt] <= 0.

Places the return address link in GPR <i>31</i>. The return link is the address of the instruction where the execution continues after a procedure call.

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rt</i> are less than or equal to zero, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

GPR <i>31</i> must not be used by the sorce register, because such instructions don't have the same effect when re-executed. The result of executing such an instruction is <black>UNPREDICTABLE</black>. This restriction permits an exception handler to resume execution by re-executing the branch when an exception occurs in the branch delay slot.

<b>Operation:</b>
<black>I:</black>
GPR[31] <- PC + 4
target_offset <- sign_extend(offset || 00)
condition <- GPR[rt] <= 0
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
With the 18-bit signed instruction offset, the conditional branch range is ±128KBytes. Use jump (<black>j</black>) or jump register (<black>jr</black>) to branch to addresses outside this range.
\END

INSTRUCTION_BGEZALC_DOCUMENTATION.=<u>Branch and link on greater than or equal to zero compact</u>

<b>Format:</b>
bgezalc rt, offset

| POP06     rs      rt     offset  |
|000110    rs = rt != 0            |
|  6        5       5        16    |


<b>Description:</b>
Compact branch and link if GPR[rt] >= 0.

Places the return address link in GPR <i>31</i>. The return link is the address of the instruction where the execution continues after a procedure call.
An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rt</i> are greater than or equal to zero, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.
GPR <i>31</i> must not be used by the sorce register, because such instructions don't have the same effect when re-executed. The result of executing such an instruction is <black>UNPREDICTABLE</black>. This restriction permits an exception handler to resume execution by re-executing the branch when an exception occurs in the branch delay slot.

<b>Operation:</b>
<black>I:</black>
GPR[31] <- PC + 4
target_offset <- sign_extend(offset || 00)
condition <- GPR[rt] >= 0
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
With the 18-bit signed instruction offset, the conditional branch range is ±128KBytes. Use jump (<black>j</black>) or jump register (<black>jr</black>) to branch to addresses outside this range.
\END

INSTRUCTION_BGTZALC_DOCUMENTATION.=<u>Branch and link on greater than zero compact</u>

<b>Format:</b>
bgtzalc rt, offset

| POP07     0    rt != 0   offset  |
|000111   00000                    |
|  6        5       5        16    |


<b>Description:</b>
Compact branch and link if GPR[rt] > 0.

Places the return address link in GPR <i>31</i>. The return link is the address of the instruction where the execution continues after a procedure call.

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rt</i> are greater than zero, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

GPR <i>31</i> must not be used by the sorce register, because such instructions don't have the same effect when re-executed. The result of executing such an instruction is <black>UNPREDICTABLE</black>. This restriction permits an exception handler to resume execution by re-executing the branch when an exception occurs in the branch delay slot.

<b>Operation:</b>
<black>I:</black>
GPR[31] <- PC + 4
target_offset <- sign_extend(offset || 00)
condition <- GPR[rt] > 0
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
With the 18-bit signed instruction offset, the conditional branch range is ±128KBytes. Use jump (<black>j</black>) or jump register (<black>jr</black>) to branch to addresses outside this range.
\END

INSTRUCTION_BLTZALC_DOCUMENTATION.=<u>Branch and link on less than zero compact</u>

<b>Format:</b>
bltzalc rt, offset

| POP07     rs      rt     offset  |
|000111    rs = rt != 0            |
|  6        5       5        16    |


<b>Description:</b>
Compact branch and link if GPR[rt] < 0.

Places the return address link in GPR <i>31</i>. The return link is the address of the instruction where the execution continues after a procedure call.

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rt</i> are lower than zero, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

GPR <i>31</i> must not be used by the sorce register, because such instructions don't have the same effect when re-executed. The result of executing such an instruction is <black>UNPREDICTABLE</black>. This restriction permits an exception handler to resume execution by re-executing the branch when an exception occurs in the branch delay slot.

<b>Operation:</b>
<black>I:</black>
GPR[31] <- PC + 4
target_offset <- sign_extend(offset || 00)
condition <- GPR[rt] < 0
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
With the 18-bit signed instruction offset, the conditional branch range is ±128KBytes. Use jump (<black>j</black>) or jump register (<black>jr</black>) to branch to addresses outside this range.
\END

INSTRUCTION_BEQZALC_DOCUMENTATION.=<u>Branch and link on equal to zero compact</u>

<b>Format:</b>
beqzalc rt, offset

| POP10     rs     rt != 0    offset  |
|001000       rs < rt                 |
|  6        5         5         16    |


<b>Description:</b>
Compact branch and link if GPR[rt] = 0.

Places the return address link in GPR <i>31</i>. The return link is the address of the instruction where the execution continues after a procedure call.

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rt</i> are equal to zero, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

GPR <i>31</i> must not be used by the sorce register, because such instructions don't have the same effect when re-executed. The result of executing such an instruction is <black>UNPREDICTABLE</black>. This restriction permits an exception handler to resume execution by re-executing the branch when an exception occurs in the branch delay slot.

<b>Operation:</b>
<black>I:</black>
GPR[31] <- PC + 4
target_offset <- sign_extend(offset || 00)
condition <- GPR[rt] = 0
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
With the 18-bit signed instruction offset, the conditional branch range is ±128KBytes. Use jump (<black>j</black>) or jump register (<black>jr</black>) to branch to addresses outside this range.
\END

INSTRUCTION_BNEZALC_DOCUMENTATION.=<u>Branch and link on not equal to zero compact</u>

<b>Format:</b>
bnezalc rt, offset

| POP30     rs     rt != 0    offset  |
|011000       rs < rt                 |
|  6        5         5         16    |


<b>Description:</b>
Compact branch and link if GPR[rt] != 0.

Places the return address link in GPR <i>31</i>. The return link is the address of the instruction where the execution continues after a procedure call.

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rt</i> are not equal to zero, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

GPR <i>31</i> must not be used by the sorce register, because such instructions don't have the same effect when re-executed. The result of executing such an instruction is <black>UNPREDICTABLE</black>. This restriction permits an exception handler to resume execution by re-executing the branch when an exception occurs in the branch delay slot.

<b>Operation:</b>
<black>I:</black>
GPR[31] <- PC + 4
target_offset <- sign_extend(offset || 00)
condition <- GPR[rt] != 0
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
With the 18-bit signed instruction offset, the conditional branch range is ±128KBytes. Use jump (<black>j</black>) or jump register (<black>jr</black>) to branch to addresses outside this range.
\END

INSTRUCTION_BLEZC_DOCUMENTATION.=<u>Branch on less than or equal to zero compact</u>

<b>Format:</b>
blezc rt, offset

| POP26     0      rt != 0    offset  |
|010110   00000                       |
|  6        5         5         16    |


<b>Description:</b>
Compact branch if GPR[rt] <= 0.

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rt</i> less than or equal to zero, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
target_offset <- sign_extend(offset || 00)
condition <- GPR[rt] <= 0
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_BGEZC_DOCUMENTATION.=<u>Branch on greater than or equal to zero compact</u>

<b>Format:</b>
bgezc rt, offset

| POP26  rs != 0   rt != 0    offset  |
|010110       rs = rt                 |
|  6        5         5         16    |


<b>Description:</b>
Compact branch if GPR[rt] >= 0.

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rt</i> greater than or equal to zero, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
target_offset <- sign_extend(offset || 00)
condition <- GPR[rt] >= 0
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_BGTZC_DOCUMENTATION.=<u>Branch on greater than zero compact</u>

<b>Format:</b>
bgtzc rt, offset

| POP27     0      rt != 0    offset  |
|010111   00000                       |
|  6        5         5         16    |


<b>Description:</b>
Compact branch if GPR[rt] > 0.

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rt</i> greater than zero, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
target_offset <- sign_extend(offset || 00)
condition <- GPR[rt] > 0
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_BLTZC_DOCUMENTATION.=<u>Branch on less than zero compact</u>

<b>Format:</b>
bltzc rt, offset

| POP27  rs != 0   rt != 0    offset  |
|010111       rs = rt                 |
|  6        5         5         16    |


<b>Description:</b>
Compact branch if GPR[rt] < 0.

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rt</i> less than zero, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
target_offset <- sign_extend(offset || 00)
condition <- GPR[rt] < 0
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_BGEC_DOCUMENTATION.=<u>Branch on greater than or equal compact</u>

<b>Format:</b>
bgec rs, rt, offset

| POP26  rs != 0   rt != 0    offset  |
|010110       rs != rt                |
|  6        5         5         16    |


<b>Description:</b>
Compact branch if GPR[rs] >= GPR[rt].

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rs</i> are greater than or equal to the contents of GPR <i>rt</i>, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
target_offset <- sign_extend(offset || 00)
condition <- GPR[rs] >= GPR[rt]
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_BLTC_DOCUMENTATION.=<u>Branch on less than or equal compact</u>

<b>Format:</b>
bltc rs, rt, offset

| POP27  rs != 0   rt != 0    offset  |
|010111       rs != rt                |
|  6        5         5         16    |


<b>Description:</b>
Compact branch if GPR[rs] < GPR[rt].

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rs</i> are less than the contents of GPR <i>rt</i>, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
target_offset <- sign_extend(offset || 00)
condition <- GPR[rt] < GPR[rt]
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_BGEUC_DOCUMENTATION.=<u>Branch on greater than or equal unsigned compact</u>

<b>Format:</b>
bgeuc rs, rt, offset

| POP06  rs != 0   rt != 0    offset  |
|000110       rs != rt                |
|  6        5         5         16    |


<b>Description:</b>
Compact branch if GPR[rs] >= GPR[rt].

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rs</i> are greater than or equal to the contents of GPR <i>rt</i>, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
target_offset <- sign_extend(offset || 00)
condition <- unsigned_word(GPR[rt]) >= unsigned_word(GPR[rt])
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_BLTUC_DOCUMENTATION.=<u>Branch on less than or equal unsigned compact</u>

<b>Format:</b>
bltuc rs, rt, offset

| POP07  rs != 0   rt != 0    offset  |
|000111       rs != rt                |
|  6        5         5         16    |


<b>Description:</b>
Compact branch if GPR[rs] < GPR[rt].

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rs</i> are less than the contents of GPR <i>rt</i>, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
target_offset <- sign_extend(offset || 00)
condition <- unsigned_word(GPR[rt]) < unsigned_word(GPR[rt])
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_BEQC_DOCUMENTATION.=<u>Branch on equal compact</u>

<b>Format:</b>
beqc rs, rt, offset

| POP10  rs != 0   rt != 0    offset  |
|001000       rs < rt                 |
|  6        5         5         16    |


<b>Description:</b>
Compact branch if GPR[rs] = GPR[rt].

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rs</i> are equal to the contents of GPR <i>rt</i>, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
target_offset <- sign_extend(offset || 00)
condition <- GPR[rt] = GPR[rt]
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_BNEC_DOCUMENTATION.=<u>Branch on not equal compact</u>

<b>Format:</b>
bnec rs, rt, offset

| POP30  rs != 0   rt != 0    offset  |
|011000       rs < rt                 |
|  6        5         5         16    |


<b>Description:</b>
Compact branch if GPR[rs] != GPR[rt].

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rs</i> are not equal to the contents of GPR <i>rt</i>, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
target_offset <- sign_extend(offset || 00)
condition <- GPR[rt] != GPR[rt]
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_BEQZC_DOCUMENTATION.=<u>Branch on equal to zero compact</u>

<b>Format:</b>
beqzc rs, offset

| POP66   BEQZC    offset  |
|110110  rs != 0           |
|  6        5        16    |


<b>Description:</b>
Compact branch if GPR[rs] == 0.

An 23-bit signed offset (the 21-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rs</i> are equal to zero, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
target_offset <- sign_extend(offset || 00)
condition <- GPR[rt] == 0
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_BNEZC_DOCUMENTATION.=<u>Branch on not equal to zero compact</u>

<b>Format:</b>
bnezc rs, offset

| POP76   BNEZC    offset  |
|111110  rs != 0           |
|  6        5        16    |


<b>Description:</b>
Compact branch if GPR[rs] != 0.

An 23-bit signed offset (the 21-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rs</i> are not equal to zero, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
target_offset <- sign_extend(offset || 00)
condition <- GPR[rt] != 0
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_BGTZ_DOCUMENTATION.=<u>Branch on greater than zero</u>

<b>Format:</b>
bgtz rs, offset

| BGTZ      rs     0      offset  |
|000111          00000            |
|  6        5      5        16    |


<b>Description:</b>
if GPR[rs] > 0 then branch

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rs</i> are greater than zero, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
<black>I:</black>
target_offset <- sign_extend(offset || 00)
condition <- GPR[rs] > 0
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
With the 18-bit signed instruction offset, the conditional branch range is ±128KBytes. Use jump (<black>j</black>) or jump register (<black>jr</black>) to branch to addresses outside this range.
\END

INSTRUCTION_BITSWAP_DOCUMENTATION.=<u>Swap bits in each byte</u>

<b>Format:</b>
bitswap rd, rt

|SPECIAL3    0    rt    rd    BITSWAP   BSGFL  |
| 011111   00000               00000    100000 |
|   6        5     5     5       5        6    |


<b>Description:</b>
GPR[rd].byte[i] <- reverse_bits(GPR[rt].byte[i]), for all bytes i

Each byte in GPR <i>rt</i> has its bytes reversed and moved to the same position in GPR <i>rd</i>.
This instruction operates on all 4 bytes of a 32-bit word.

<b>Restrictions:</b>
None

<b>Operation:</b>

function reverse_bits (in)
    out<sub>7</sub> <- in<sub>0</sub>
    out<sub>6</sub> <- in<sub>1</sub>
    out<sub>5</sub> <- in<sub>2</sub>
    out<sub>4</sub> <- in<sub>3</sub>
    out<sub>3</sub> <- in<sub>4</sub>
    out<sub>2</sub> <- in<sub>5</sub>
    out<sub>1</sub> <- in<sub>6</sub>
    out<sub>0</sub> <- in<sub>7</sub>
    return out
end function

for i in 0 to 3 do
    GPR[rd].byte[i] <- reverse_bits(GPR[rt].byte[i])
endfor

<b>Exceptions:</b>
None
\END

INSTRUCTION_BLEZ_DOCUMENTATION.=<u>Branch on less than or equal to zero</u>

<b>Format:</b>
blez rs, offset

| BLEZ      rs     0      offset  |
|000110          00000            |
|  6        5      5        16    |


<b>Description:</b>
if GPR[rs] <= 0 then branch

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rs</i> are less than or equal to zero, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
<black>I:</black>
target_offset <- sign_extend(offset || 00)
condition <- GPR[rs] <= 0
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
With the 18-bit signed instruction offset, the conditional branch range is ±128KBytes. Use jump (<black>j</black>) or jump register (<black>jr</black>) to branch to addresses outside this range.
\END

INSTRUCTION_BLTZ_DOCUMENTATION.=<u>Branch on less than zero</u>

<b>Format:</b>
bltz rs, offset

|REGIMM     rs    BLTZ    offset  |
|000001          00000            |
|  6        5      5        16    |


<b>Description:</b>
if GPR[rs] < 0 then branch

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rs</i> are less than zero, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
<black>I:</black>
target_offset <- sign_extend(offset || 00)
condition <- GPR[rs] < 0
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
With the 18-bit signed instruction offset, the conditional branch range is ±128KBytes. Use jump (<black>j</black>) or jump register (<black>jr</black>) to branch to addresses outside this range.
\END

INSTRUCTION_BNE_DOCUMENTATION.=<u>Branch on not equal</u>

<b>Format:</b>
bne rs, rt, offset

| BNE       rs     rt     offset  |
|000101                           |
|  6        5      5       16     |


<b>Description:</b>
if GPR[rs] != GPR[rt] then branch

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rt</i> and GPR <i>rs</i> are not equal, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
<black>I:</black>
target_offset <- sign_extend(offset || 00)
condition <- GPR[rs] != GPR[rt]
<black>I+1:</black>
if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None

<b>Programming Notes:</b>
With the 18-bit signed instruction offset, the conditional branch range is ±128KBytes. Use jump (<black>j</black>) or jump register (<black>jr</black>) to branch to addresses outside this range.
\END

INSTRUCTION_BOVC_DOCUMENTATION.=<u>Branch on overflow compact</u>

<b>Format:</b>
bovc rs, rt, offset

| POP10     rs        rt      offset  |
|001000       rs >= rt                |
|  6        5         5         16    |


<b>Description:</b>
Compact branch if GPR[rs] + GPR[rt] overflows

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rs</i> plus the contents of GPR <i>rt</i> overflow, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
target_offset <- sign_extend(offset || 00)
temp_d = GPR[rs] + GPR[rt]
condition <- temp_d<sub>32</sub> != temp_d<sub>31</sub>

if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_BNVC_DOCUMENTATION.=<u>Branch on no overflow compact</u>

<b>Format:</b>
bnvc rs, rt, offset

| POP30     rs        rt      offset  |
|011000       rs >= rt                |
|  6        5         5         16    |


<b>Description:</b>
Compact branch if GPR[rs] + GPR[rt] doesn't overflow

An 18-bit signed offset (the 16-bit <i>offset</i> field shifted left 2 bits) is added to the address of the instruction following the branch, to form a PC-relative effective target address.
If the contents of GPR <i>rs</i> plus the contents of GPR <i>rt</i> don't overflow, branch to the effective target address.

<b>Restrictions:</b>
<i>Control Transfer Instructions (CTIs)</i> <black>should not</black> be placed in branch delay slots or Release 6 forbidden slots. CTIs include all branches and jumps, <black>nal</black>, <black>nal</black>, <black>eret</black>, <black>eretnc</black>, <black>deret</black>, <black>wait</black> and <black>pause</black>.
If a CTI is executed in the delay slot of a branch or jump, Release 6 implementations are required to signal a <black>Reserved Instruction</black> exception.

<b>Operation:</b>
target_offset <- sign_extend(offset || 00)
temp_d = GPR[rs] + GPR[rt]
condition <- temp_d<sub>32</sub> = temp_d<sub>31</sub>

if condition then
    PC <- PC + target_offset
endif

<b>Exceptions:</b>
None
\END

INSTRUCTION_BREAK_DOCUMENTATION.=<u>Breakpoint</u>

<b>Format:</b>
break

|SPECIAL    0       BREAK  |
|000000                    |
|  6        20     001101  |


<b>Description:</b>
Breakpoint

A breakpoint exception occurs, immediately and unconditionally transfering control to the exception handler.

<b>Restrictions:</b>
None

<b>Operation:</b>
SignalException(Breakpoint)

<b>Exceptions:</b>
Breakpoint
\END

INSTRUCTION_CEIL_L_D_DOCUMENTATION.=<u>Ceiling double to long</u>

<b>Format:</b>
ceil.l.d fd, fs

| COP1      fmt      0      fs      fd     CEIL.L |
|010001    10001   00000                   001010 |
|  6         5       5      5       5        6    |


<b>Description:</b>
FPR[fd] <- convert_and_round(FPR[fs])

The double precission floating point value of FPR <i>fs</i> is converted to a ceiled 64-bit word.
The result is placed in FPR <i>fd</i>.

When the source value is <black>Infinity</black>, <black>NaN</black> or is outside of a 64-bit word, the result cannot be represented correctly. These cases are handled by the JVM itself.

<b>Restrictions:</b>
The fields <i>fs</i> and <i>fd</i> must be even FPRs. If the fields are not valid, the result is <black>UNPREDICTABLE</black>.
The operand must be a value in double precision floating point. If it is not, the result is <black>UNPREDICTABLE</black>.

<b>Operation:</b>
fmt <- double
StoreFPR(fd, L, ConvertFmt(ValueFPR(fs, fmt), fmt, L))

<b>Exceptions:</b>
None
\END

INSTRUCTION_CEIL_W_D_DOCUMENTATION.=<u>Ceiling double to word</u>

<b>Format:</b>
ceil.w.d fd, fs

| COP1      fmt      0      fs      fd     CEIL.W |
|010001    10001   00000                   001110 |
|  6         5       5      5       5        6    |


<b>Description:</b>
FPR[fd] <- convert_and_round(FPR[fs])

The double precission floating point value of FPR <i>fs</i> is converted to a ceiled 32-bit word.
The result is placed in FPR <i>fd</i>.

When the source value is <black>Infinity</black>, <black>NaN</black> or is outside of a 32-bit word, the result cannot be represented correctly. These cases are handled by the JVM itself.

<b>Restrictions:</b>
The field <i>fs</i> must be a even FPR. If the field is not valid, the result is <black>UNPREDICTABLE</black>.
The operand must be a value in double precision floating point. If it is not, the result is <black>UNPREDICTABLE</black>.

<b>Operation:</b>
fmt <- double
StoreFPR(fd, W, ConvertFmt(ValueFPR(fs, fmt), fmt, W))

<b>Exceptions:</b>
None
\END


INSTRUCTION_CEIL_L_S_DOCUMENTATION.=<u>Ceiling float to long</u>

<b>Format:</b>
ceil.l.s fd, fs

| COP1      fmt      0      fs      fd     CEIL.L |
|010001    10000   00000                   001010 |
|  6         5       5      5       5        6    |


<b>Description:</b>
FPR[fd] <- convert_and_round(FPR[fs])

The floating point value of FPR <i>fs</i> is converted to a ceiled 64-bit word.
The result is placed in FPR <i>fd</i>.

When the source value is <black>Infinity</black>, <black>NaN</black> or is outside of a 64-bit word, the result cannot be represented correctly. These cases are handled by the JVM itself.

<b>Restrictions:</b>
The field <i>fd</i> must be a even FPR. If the field is not valid, the result is <black>UNPREDICTABLE</black>.
The operand must be a value in floating point. If it is not, the result is <black>UNPREDICTABLE</black>.

<b>Operation:</b>
fmt <- float
StoreFPR(fd, L, ConvertFmt(ValueFPR(fs, fmt), fmt, L))

<b>Exceptions:</b>
None
\END

INSTRUCTION_CEIL_W_S_DOCUMENTATION.=<u>Ceiling float to word</u>

<b>Format:</b>
ceil.w.s fd, fs

| COP1      fmt      0      fs      fd     CEIL.W |
|010001    10000   00000                   001110 |
|  6         5       5      5       5        6    |


<b>Description:</b>
FPR[fd] <- convert_and_round(FPR[fs])

The floating point value of FPR <i>fs</i> is converted to a ceiled 32-bit word.
The result is placed in FPR <i>fd</i>.

When the source value is <black>Infinity</black>, <black>NaN</black> or is outside of a 32-bit word, the result cannot be represented correctly. These cases are handled by the JVM itself.

<b>Restrictions:</b>
The operand must be a value in floating point. If it is not, the result is <black>UNPREDICTABLE</black>.

<b>Operation:</b>
fmt <- float
StoreFPR(fd, W, ConvertFmt(ValueFPR(fs, fmt), fmt, W))

<b>Exceptions:</b>
None
\END

INSTRUCTION_CLO_DOCUMENTATION.=<u>Count leading ones in word</u>

<b>Format:</b>
clo rd, rs

|SPECIAL     rs      0      rd      1       CLO   |
|000000            00000          00001    010001 |
|  6         5       5      5       5        6    |


<b>Description:</b>
GPR[rd] <- count_leading_ones(GPR[rs])

Bits 31 to 0 of GPR <i>rs</i> are scanned from most significant to least significant bit. The number of leading ones is counted and the result is written to GPR <i>rd</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>

temp <- 32
for i in 31 to 0
    if GPR[rs]<sub>i</sub> = 0 then
        temp <- 31 - i
        break
    endif
endfor
GPR[rd] <- temp

<b>Exceptions:</b>
None
\END


INSTRUCTION_CLZ_DOCUMENTATION.=<u>Count leading zeros in word</u>

<b>Format:</b>
clz rd, rs

|SPECIAL     rs      0      rd      1       CLZ   |
|000000            00000          00001    010000 |
|  6         5       5      5       5        6    |


<b>Description:</b>
GPR[rd] <- count_leading_zeros(GPR[rs])

Bits 31 to 0 of GPR <i>rs</i> are scanned from most significant to least significant bit. The number of leading zeros is counted and the result is written to GPR <i>rd</i>.

<b>Restrictions:</b>
None

<b>Operation:</b>

temp <- 32
for i in 31 to 0
    if GPR[rs]<sub>i</sub> = 1 then
        temp <- 31 - i
        break
    endif
endfor
GPR[rd] <- temp

<b>Exceptions:</b>
None
\END

INSTRUCTION_CMP_D_DOCUMENTATION.=<u>Floating point compare ({TYPE}) (double)</u>

<b>Format:</b>
cmp.{MNEMONIC}.d fd, fs, ft

| COP1    CMP.c.D   ft   fs   fd   0   {MNEMONIC}\t|
|000001    10101                   0   {CODE}\t|
|  6         5      5    5    5    1     5     \t|


<b>Description:</b>
FPR[fd] <- FPR[fs] compare_cond FPR[ft] where compare_cond = {TYPE}.

The value in FPR <i>fs</i> is compared to the value in FPR <i>ft</i>.
The FPR <i>fd</i> is filled with zeros if the result is false or ones of the result is true.

Each bit 2 to 0 in the condition repesents a check. If one of these bits is active the check linked to it will be executed.
The result is true when any of these checks return true.

The checks linked to the bits are the next:
- Bit 0: unordered.
- Bit 1: equal.
- Bit 2: less than.

If bit 4 is active the result is negated.
If bit 3 is active and any of the operands are <black>NaN</black>, a Floating Point Exception will be thrown.

<b>Restrictions:</b>
The fields <i>fs</i>, <i>ft</i> and <i>fd</i> must be even FPRs. If the fields are not valid, the result is <black>UNPREDICTABLE</black>.
Operands must be values in double precision floating point. If they are not, the result is <black>UNPREDICTABLE</black>.

<b>Operation:</b>
fmt <- double
fsv <- ValueFPR(fs, fmt)
ftv <- ValueFPR(ft, fmt)

if is_NaN(fsv) or is_NaN(ftv) then
    less <- false
    equal <- false
    unordered <- true
    if cond<sub>3</sub> then
        SignalException(FloatingPointException)
    endif
else
    less <- fsv <<sub>fmt</sub> ftv
    less <- fsv =<sub>fmt</sub> ftv
    unordered <- false
endif

condition <- cond<sub>4</sub> xor ((cond<sub>2</sub> and less) or (cond<sub>1</sub> and equal) or (cond<sub>0</sub> and unordered))
StoreFPR(fd, fmt, extend_bit.fmt(condition))

<b>Exceptions:</b>
Floating Point Exception
\END

INSTRUCTION_CMP_S_DOCUMENTATION.=<u>Floating point compare ({TYPE}) (single)</u>

<b>Format:</b>
cmp.{MNEMONIC}.s fd, fs, ft

| COP1    CMP.c.S   ft   fs   fd   0   {MNEMONIC}\t|
|000001    10100                   0   {CODE}\t|
|  6         5      5    5    5    1     5     \t|


<b>Description:</b>
FPR[fd] <- FPR[fs] compare_cond FPR[ft] where compare_cond = {TYPE}.

The value in FPR <i>fs</i> is compared to the value in FPR <i>ft</i>.
The FPR <i>fd</i> is filled with zeros if the result is false or ones of the result is true.

Each bit 2 to 0 in the condition repesents a check. If one of these bits is active the check linked to it will be executed.
The result is true when any of these checks return true.

The checks linked to the bits are the next:
- Bit 0: unordered.
- Bit 1: equal.
- Bit 2: less than.

If bit 4 is active the result is negated.
If bit 3 is active and any of the operands are <black>NaN</black>, a Floating Point Exception will be thrown.

<b>Restrictions:</b>
Operands must be values in floating point. If they are not, the result is <black>UNPREDICTABLE</black>.

<b>Operation:</b>
fmt <- float
fsv <- ValueFPR(fs, fmt)
ftv <- ValueFPR(ft, fmt)

if is_NaN(fsv) or is_NaN(ftv) then
    less <- false
    equal <- false
    unordered <- true
    if cond<sub>3</sub> then
        SignalException(FloatingPointException)
    endif
else
    less <- fsv <<sub>fmt</sub> ftv
    less <- fsv =<sub>fmt</sub> ftv
    unordered <- false
endif

condition <- cond<sub>4</sub> xor ((cond<sub>2</sub> and less) or (cond<sub>1</sub> and equal) or (cond<sub>0</sub> and unordered))
StoreFPR(fd, fmt, extend_bit.fmt(condition))

<b>Exceptions:</b>
Floating Point Exception
\END


INSTRUCTION_CVT_DOCUMENTATION.=<u>Convert from {FROM} to {TO}</u>

<b>Format:</b>
cvt.{TO_MNEMONIC}.{FROM_MNEMONIC} fd, fs

| COP1      fmt      0      fs      fd      CVT.{TO_MNEMONIC}  |
|010001    {FROM_FMT}   00000                   {TO_CVT}  |
|  6         5       5      5       5        6     |


<b>Description:</b>
FPR[fd] <- convert_and_round(FPR[fs])

The value of FPR <i>fs</i> in the format of {FROM} is converted to a value in the format of {TO}.
The result is placed in FPR <i>fd</i>.

<b>Restrictions:</b>
Values whose format rely on two register must be placed on an even FPR. If they are not, the result is <black>UNPREDICTABLE</black>.
The operand must be in the value of its respective format. If it is not, the result is <black>UNPREDICTABLE</black>.

<b>Operation:</b>
from <- {FROM_MNEMONIC}
to <- {TO_MNEMONIC}
StoreFPR(fd, to, ConvertFmt(ValueFPR(fs, from), from, to))

<b>Exceptions:</b>
None
\END

FLOAT_CONDITION_AF=Always false
FLOAT_CONDITION_UN=Unordered
FLOAT_CONDITION_EQ=Equal
FLOAT_CONDITION_UEQ=Unordered or equal
FLOAT_CONDITION_LT=Ordered less than
FLOAT_CONDITION_ULT=Unordered or less than
FLOAT_CONDITION_LE=Ordered less than or equal
FLOAT_CONDITION_ULE=Unordered or less than or equal
FLOAT_CONDITION_SAF=Signaling always false
FLOAT_CONDITION_SUN=Signaling unordered
FLOAT_CONDITION_SEQ=Ordered signaling equal
FLOAT_CONDITION_SUEQ=Signaling unordered or equal
FLOAT_CONDITION_SLT=Ordered signaling less than
FLOAT_CONDITION_SULT=Signaling unordered or less than
FLOAT_CONDITION_SLE=Ordered signaling less than or equal
FLOAT_CONDITION_SULE=Signaling unordered or less than or equal
FLOAT_CONDITION_OR=Ordered
FLOAT_CONDITION_UNE=Not equal
FLOAT_CONDITION_NE=Ordered not equal
FLOAT_CONDITION_SOR=Signalling ordered
FLOAT_CONDITION_SUNE=Signalling unordered or not equal
FLOAT_CONDITION_SNE=Signalling ordered not equal

FMT_SINGLE=single
FMT_DOUBLE=double
FMT_WORD=word
FMT_LONG=long

ABOUT=JAMS\nVersion {VERSION}\n\nCopyright 2020-2021\nMade by Gael Rial Costas